{"version":3,"file":"991.js","mappings":"+mGAAA,iBACA,cAEA,cAEMA,EAAoB,CAAC,QAAS,cAAe,SAAU,UAAW,SAE3D,EAAAC,aAAe,CAC1BC,MAAO,QACPC,OAAQ,UAOG,EAAAC,SAAW,CACtBC,OAAQ,SACRC,SAAU,YAYZ,iBAWE,WAAY,G,IAAEC,EAAE,KAAEC,EAAQ,WAAEC,EAAG,MAAEC,EAAK,QAAEC,EAAI,OAAEC,EAAQ,WASpD,GAnBK,KAAAC,KAAO,EAAAT,SAASE,SAOhB,KAAAQ,QAAS,EAIdC,KAAKR,GAAKA,EACVQ,KAAKP,SAAWA,EAChBO,KAAKL,MAAQA,EACbK,KAAKJ,KAAOA,EAGZI,KAAKH,SAAWA,GAAY,EAAAX,aAAaC,MAErCa,KAAKH,WAAa,EAAAX,aAAaC,OAASa,KAAKH,WAAa,EAAAX,aAAaE,OACzE,MAAM,IAAIa,MAAM,8BAGlB,IAEE,GAAIhB,EAAkBiB,MAAK,SAAAC,GAAS,OAAuB,IAAvBT,EAAIU,QAAQD,EAAZ,IAElC,YADAH,KAAKN,IAAMA,GAIb,IAAMW,EAAS,IAAIC,IAAIZ,GACvBM,KAAKN,IAAMW,EAAOE,I,CAClB,MAAOC,GACP,UAAOC,IAAI,sBAAuBf,GAClCM,KAAKN,IAAMA,C,CAEf,CAiFF,OA/EE,YAAAgB,aAAA,SAAuCC,GACrC,OAAIA,aAAqBC,GAChBZ,KAAKN,MAAQiB,EAAUjB,GAGlC,EAEA,YAAAmB,mBAAA,SAA6CF,GAC3C,OAAO,CACT,EAEM,YAAAG,KAAN,W,uGACOd,KAAKe,UAAN,OACF,EAAAf,KAAiB,GAAM,UAAOgB,OAC5BC,KAAKC,UAAU,CAAEvB,MAAOK,KAAKL,MAAOD,IAAKM,KAAKN,S,OADhD,EAAKqB,UAAY,S,iBAInB,MAAO,CAAP,EAAOf,KAAKe,W,QAGd,YAAAI,MAAA,SAAMC,GACJ,OAAO,IAAIR,EAASZ,KACtB,EAEA,YAAAqB,kBAAA,SAA4CD,EAAkBvB,GAC5D,OAAO,IAAIe,EAAS,EAAD,KACdZ,MAAI,CACPH,SAAQ,IAEZ,EAEA,YAAAyB,YAAA,W,MACE,OAAO,EAAP,IAAUtB,KAAKR,IAAKQ,KAAI,CAC1B,EAGA,YAAAuB,SAAA,SAASzB,EAAgBN,GACvB,MAAa,aAATM,GAAuB0B,OAAOhC,KAAQgC,OAAOxB,KAAKR,IAC7CQ,KAEF,IACT,EAGA,YAAAyB,eAAA,SAAe3B,EAAgB4B,EAA6BC,GAC1D,YAD0D,IAAAA,IAAAA,EAAA,WAAwC,WAC9F7B,IAAS,EAAAT,SAASE,UAAYmC,EAAG1B,MAC5BA,KAEF,IACT,EAEA,YAAA4B,MAAA,WACE,OAAO,CACT,EAEA,YAAAC,QAAA,SAAQC,GACN,YADM,IAAAA,IAAAA,EAAA,GAEJC,MAAMD,EAAQ,EAAI,EAAIA,GACnBE,KAAK,MACLC,KAAK,IACR,aAAMjC,KAAKR,GAAE,YAAIQ,KAAKL,MAAK,aAAKK,KAAKN,IAAG,uBAAeM,KAAKP,SAEhE,EAEA,YAAAyC,YAAA,SAAYC,GACV,OAAOA,EAASC,eAAepC,KACjC,EAEA,YAAAqC,YAAA,SAAYF,GACV,OAAOA,EAASG,eAAetC,KACjC,EAEA,YAAAuC,YAAA,SAAYJ,GACV,OAAOA,EAASK,eAAexC,KACjC,EAEO,EAAAyC,QAAP,SAAyCC,GACvC,OAAO,IAAI9B,EAAS8B,EACtB,EACF,EAtHA,GAAa,EAAA9B,SAAAA,EAwHb,iBAYE,WAAY,G,IAAEpB,EAAE,KAAEC,EAAQ,WAAEE,EAAK,QAAEgD,EAAQ,WAAE5B,EAAS,YAAE6B,EAAM,SAAE/C,EAAQ,WAAEE,EAAM,SAuB9E,GAlCK,KAAAD,KAAO,EAAAT,SAASC,OAMhB,KAAAS,QAAS,EACT,KAAA6C,QAAS,EAgBd5C,KAAKR,GAAKA,EACVQ,KAAKP,SAAWA,EAChBO,KAAKL,MAAQA,EACbK,KAAK2C,SAAWA,GAAY,GAC5B3C,KAAKe,UAAY,EAAH,GAAOA,GACrBf,KAAK4C,QAAoB,IAAXA,EACd5C,KAAKD,OAASA,EAGdC,KAAKH,SAAWA,GAAY,EAAAX,aAAaC,MAErCa,KAAKH,WAAa,EAAAX,aAAaC,OAASa,KAAKH,WAAa,EAAAX,aAAaE,OACzE,MAAM,IAAIa,MAAM,6BAEpB,CAuOF,OApOE,YAAAwB,eAAA,SAAe3B,EAAgB4B,EAAoBC,GAMjD,YANiD,IAAAA,IAAAA,EAAA,WAA8B,WAC1E3B,KAAK6C,OACR7C,KAAKsB,cAEYwB,OAAOC,OAAO/C,KAAK6C,MAAM/C,IAAOkD,OAAOtB,GAExCuB,MAAK,SAACC,EAAEC,GAAM,OAAAxB,EAAOuB,GAAKvB,EAAOwB,EAAnB,IAAuBC,KACzD,EAEA,YAAAC,WAAA,SAAW7D,GACT,OAAIgC,OAAOxB,KAAKR,MAAQgC,OAAOhC,GACtBQ,KAGLA,KAAK6C,MACA7C,KAAK6C,MAAMS,OAAO9D,GAIpBQ,KAAK2C,SACTK,QAAO,SAAAO,GAAS,OAAAA,aAAiBC,CAAjB,IAChBC,KAAI,SAAAH,GAAU,OAAAA,CAAA,IACdG,KAAI,SAAAH,GAAU,OAAAA,EAAOD,WAAW7D,EAAlB,IACdwD,QAAO,SAAAM,GAAU,QAAEA,CAAF,IAAU,EAChC,EAEA,YAAAI,aAAA,SAAalE,GACX,OAAIQ,KAAK6C,MACA7C,KAAK6C,MAAMc,SAASnE,GAEPQ,KAAK2C,SACxBK,QAAO,SAAAO,GAAS,OAAAA,aAAiB3C,CAAjB,IAChB6C,KAAI,SAAAF,GAAS,OAAAA,CAAA,IACbK,MAAK,SAAAC,GAAM,OAAArC,OAAOqC,EAAGrE,MAAQgC,OAAOhC,EAAzB,KAKPQ,KAAK2C,SACTK,QAAO,SAAAO,GAAS,OAAAA,aAAiBC,CAAjB,IAChBC,KAAI,SAAAH,GAAU,OAAAA,CAAA,IACdG,KAAI,SAAAH,GAAU,OAAAA,EAAOI,aAAalE,EAApB,IACdwD,QAAO,SAAAW,GAAY,QAAEA,CAAF,IAAY,EACpC,EAGA,YAAApC,SAAA,SAASzB,EAAgBN,GACvB,OAAIM,IAAS,EAAAT,SAASC,OACbU,KAAKqD,WAAW7D,GAEhBQ,KAAK0D,aAAalE,EAE7B,EAEM,YAAAsE,SAAN,SAAepC,G,qGACb,SAAMqC,EAASC,KAAKhE,KAAK2C,UAAU,SAAMsB,GAAI,qC,kDAC3C,SAAMvC,EAAGuC,EAAMjE,O,cAAf,SACkB,WAAdiE,EAAKnE,KAAL,MAEF,GAAMoE,QAAQC,W,OACd,OADA,SACA,GAAMF,EAAKH,SAASpC,I,OAApB,S,oCAED,K,cAPH,S,YAWF,YAAAhB,aAAA,SAAuCC,GACrC,OAAIA,aAAqB6C,GAChBxD,KAAKL,QAAUgB,EAAUhB,KAGpC,EAEA,YAAAkB,mBAAA,SAA6CF,GAC3C,OAAIA,aAAqB6C,EAChBxD,KAAK2C,SAASyB,QACnB,SAACxC,EAAOqC,GACN,OAAAtD,EAAUgC,SAASiB,MAAK,SAAAS,GAAK,OAAAA,EAAE1E,QAAUsE,EAAKtE,KAAjB,IAA0BiC,EAAQ,EAAIA,CAAnE,GACF,GACE0C,KAAKC,IAAIvE,KAAK2C,SAAS6B,OAAQ7D,EAAUgC,SAAS6B,QAEjD,CACT,EAEM,YAAA1D,KAAN,SAAW2D,G,YAAA,IAAAA,IAAAA,GAAA,G,uGACT,GAAIzE,KAAKe,WAAaf,KAAKe,UAAUS,OAAOiD,IAC1C,MAAO,CAAP,EAAOzE,KAAKe,UAAUS,OAAOiD,KAG/B,IAAKzE,KAAK4C,OACR,MAAM,IAAI3C,MAAM,0DAoBJ,OAjBR0C,EAAW3C,KAAK2C,SAAS+B,QAC1BD,GAEH9B,EAASM,MAAK,SAAC0B,EAAIC,GACjB,OAAID,EAAGhF,MAAQiF,EAAGjF,OACR,EAENiF,EAAGjF,MAAQgF,EAAGhF,MACT,EAEF,CACT,IAEGK,KAAKe,YAAWf,KAAKe,UAAY,CAAC,GACvC,EAAAf,KAAKe,UAAU,EAAAS,OAAOiD,GAAwB,gBAAOzD,OACnD,KAAAC,MAAKC,U,GACHvB,MAAOK,KAAKL,OACF,GAAMoE,EAASN,IACvBzD,KAAK2C,UACL,SAAAY,GAAS,OAAAA,EAAMzC,KAAK2D,EAAX,GACT,I,OANkC,SAAM,WAC5C,YAEE,EAAA9B,SAAU,S,eAOd,OAVA,KAAwC,SAUjC,CAAP,EAAO3C,KAAKe,UAAUS,OAAOiD,K,QAG/B,YAAAtD,MAAA,SAAMC,GACJ,OAAO,IAAIoC,EAAO,EAAD,OACZxD,OACEoB,GAAY,CAAEL,UAAW,CAAC,IAAI,CACnC4B,SAAU3C,KAAK2C,SAASc,KAAI,SAAAF,GAAS,OAAAA,EAAMpC,MAAMC,EAAZ,MAEzC,EAEA,YAAAC,kBAAA,SAA4CD,EAAkBvB,GAC5D,OAAO,IAAI2D,EAAO,EAAD,SACZxD,MAAI,CACPH,SAAQ,KACHuB,GAAY,CAAEL,UAAW,CAAC,IAAI,CACnC4B,SAAU3C,KAAK2C,SAASc,KAAI,SAAAF,GAAS,OAAAA,EAAMlC,kBAAkBD,EAAUvB,EAAlC,MAEzC,EAEA,YAAA+B,MAAA,WAIE,OAHK5B,KAAK6C,OACR7C,KAAKsB,cAEAwB,OAAO+B,KAAK7E,KAAK6C,MAAMc,UAAUa,MAC1C,EAEA,YAAAM,aAAA,WAIE,OAHK9E,KAAK6C,OACR7C,KAAKsB,cAEAwB,OAAO+B,KAAK7E,KAAK6C,MAAMS,QAAQkB,MACxC,EAEA,YAAAlD,YAAA,W,MAAA,OAkBE,OAjBAtB,KAAK6C,MAAQ,CACXS,QAAM,KAAI,EAACtD,KAAKR,IAAKQ,KAAI,GACzB2D,SAAU3D,KAAK2C,SACZK,QAAO,SAAAO,GAAS,OAAAA,aAAiB3C,CAAjB,IAChBwD,QAAO,SAAC1B,EAAKa,GAEZ,OADAb,EAAIa,EAAM/D,IAAM+D,EACTb,CACT,GAAG,CAAC,IAGR1C,KAAK2C,SACFK,QAAO,SAAAO,GAAS,OAAAA,aAAiBC,CAAjB,IAChBC,KAAI,SAAAF,GAAS,OAAAA,EAAMjC,aAAN,IACbyD,SAAQ,SAAAC,GACPlC,OAAOmC,OAAO,EAAKpC,MAAMS,OAAQ0B,EAAS1B,QAC1CR,OAAOmC,OAAO,EAAKpC,MAAMc,SAAUqB,EAASrB,SAC9C,IACK3D,KAAK6C,KACd,EAEA,YAAAhB,QAAA,SAAQC,GACN,YADM,IAAAA,IAAAA,EAAA,GAEJC,MAAMD,EAAQ,EAAI,EAAIA,GACnBE,KAAK,MACLC,KAAK,IACR,aAAMjC,KAAKR,GAAE,YAAIQ,KAAKL,MAAK,uBAAeK,KAAKP,SAAQ,mBAAWO,KAC/De,UAAUS,QAAO,KAAUxB,KAAKe,UAAUS,QAAO,IAAO,MAC3DxB,KAAK2C,SACFc,KAAI,SAAAF,GACH,OAAAA,GAASA,EAAM1B,QAAU0B,EAAM1B,QAAQC,EAAQ,GAAKN,OAAO+B,EAA3D,IAEDtB,KAAK,KAEZ,EAEA,YAAAC,YAAA,SAAYC,GACV,OAAOA,EAAS+C,aAAalF,KAC/B,EAEA,YAAAqC,YAAA,SAAYF,GACV,OAAOA,EAASgD,aAAanF,KAC/B,EAEA,YAAAuC,YAAA,SAAYJ,GACV,OAAOA,EAASiD,aAAapF,KAC/B,EAEO,EAAAyC,QAAP,SAAyCC,GACvC,OAAO,IAAIc,EAAO,EAAD,KACZd,GAAG,CACNC,SAAUD,EAAIC,SACVD,EAAIC,SAASc,KAAI,SAAAF,GAEjB,MAAI,QAASA,GAA8B,iBAAdA,EAAM7D,IAC1BkB,EAAS6B,QAAQc,GAEjBC,EAAOf,QAAQc,EAE1B,IACE,OAER,EAEO,EAAA8B,eAAP,SAAgDpB,EAAiBqB,GAG/D,IAFA,IAAMC,EAAY,CAACtB,GACfuB,EAASvB,EACNzC,OAAOgE,EAAOhG,MAAQgC,OAAO8D,EAAK9F,KAGvC,GAFA+F,EAAUE,KAAKD,KACfA,EAASF,EAAK/D,SAAS,EAAAlC,SAASC,OAAQkG,EAAO/F,WAE7C,MAAM,IAAIQ,MAAM,+CAIpB,OADAsF,EAAUG,UACHH,CACT,EACF,EA7QA,GAAa,EAAA/B,OAAAA,EAiRb,mBAAiDd,GAC/C,GAAIA,EAAI5C,OAAS,EAAAT,SAASC,OACxB,OAAOkE,EAAOf,QAAWC,GAE3B,GAAIA,EAAI5C,OAAS,EAAAT,SAASE,SACxB,OAAOqB,EAAS6B,QAAWC,GAE7B,MAAM,IAAIzC,MAAM,gCAAyBgB,KAAKC,UAAUwB,IAC1D,C,y+CC/aA,cAEA,0BAwFA,QApFe,EAAA1B,OAAb,SAAoB2E,G,kGAEC,OADbC,GAAY,IAAIC,aAAcC,OAAOH,GACxB,GAAMI,OAAOC,OAAOC,OAAO,UAAWL,I,OAEzD,OAFMM,EAAa,SAEZ,CAAP,EADgBlG,KAAKmG,eAAe,IAAIC,WAAWF,K,QAI9C,EAAAC,eAAP,SAAsBE,GACpB,OAAOtE,MAAMuE,KAAK,IAAIF,WAAWC,IAC9B5C,KAAI,SAAAN,GAAK,OAAC,KAAOA,EAAEoD,SAAS,KAAK7B,OAAO,EAA/B,IACTzC,KAAK,GACV,EAEO,EAAAuE,eAAP,SAAsBC,GACpB,IACE,IAAIC,EAAQ,IAAIN,WAAWK,EAAIjC,OAAS,GAAImC,EAAI,EAChDA,EAAIF,EAAIjC,OACRmC,GAAK,EAELD,EAAMC,EAAI,GAAKC,SAASH,EAAII,OAAOF,EAAG,GAAI,IAE5C,OAAOD,CACT,EAEa,EAAAI,WAAb,SAAwBC,EAAoBC,G,sGAI9B,OAHNC,EAAM,IAAIpB,YACVqB,EAAkBD,EAAInB,OAAOiB,GAC7BI,EAAYF,EAAInB,OAAOkB,GACjB,GAAMjB,OAAOC,OAAOoB,UAAU,MAAOF,EAAiB,UAAU,EAAO,CAAC,e,OACpF,OADMG,EAAM,SACL,CAAP,EAAOtB,OAAOC,OAAOsB,UACnB,CACEC,KAAM,SACNzG,KAAM,UACNkG,KAAMG,EACNK,WAAYC,EAAOD,YAErBH,EACA,CACEE,KAAM,UACN/C,OAAQ,MAEV,EACA,CAAC,UAAW,a,QAIH,EAAAkD,WAAb,SAAwBL,EAAaM,EAAiBX,G,wGAClC,SAAMhH,KAAK8G,WAAWO,EAAKL,I,OAKtB,OALjBY,EAAY,SACZvB,GAAS,IAAAwB,cAAaF,GACtBG,EAAKzB,EAAO3B,MAAM,EAAG1E,KAAK+H,UAC1BC,EAAa3B,EAAO3B,MAAM1E,KAAK+H,UAEd,GAAMhC,OAAOC,OAAOiC,QAAQ,CAAEV,KAAM,UAAWO,GAAE,GAAIF,EAAWI,I,OACvF,OADME,EAAiB,SAChB,CAAP,GAAO,IAAIC,aAAcC,OAAOF,I,QAGrB,EAAAG,WAAb,SAAwBhB,EAAa1B,EAAiBqB,G,wGAIlC,OAFZc,EAAK9H,KAAKsI,eAAetI,KAAK+H,UAC9BQ,GAAe,IAAI1C,aAAcC,OAAOH,GAC5B,GAAM3F,KAAK8G,WAAWO,EAAKL,I,OAC1B,OADbY,EAAY,SACC,GAAM7B,OAAOC,OAAOwC,QACrC,CAAEjB,KAAM,UAAWO,GAAE,GACrBF,EACAW,I,OAKF,OARMP,EAAa,SAMbS,EAAczI,KAAK0I,YAAYZ,EAAI,IAAI1B,WAAW4B,IAEjD,CAAP,GAAO,IAAAW,gBAAeF,I,QAGjB,EAAAC,YAAP,SAAmBE,EAAoBC,GACrC,IAAMC,EAAS,IAAI1C,WAAWwC,EAAOpE,OAASqE,EAAOrE,QAGrD,OAFAsE,EAAOC,IAAIH,EAAQ,GACnBE,EAAOC,IAAIF,EAAQD,EAAOpE,QACnBsE,CACT,EAEO,EAAAR,eAAP,SAAsBU,GACpB,IAAMC,EAAO,IAAI7C,WAAW4C,GAE5B,OADAjD,OAAOmD,gBAAgBD,GAChBA,CACT,EAtFO,EAAAzB,WAAa,KACb,EAAAO,SAAW,GAsFpB,C,CAxFA,G,UAAqBN,C,skDCFrB,kBACA,cAKM0B,EAAU,SAchB,aAKE,WAAYC,GAHJ,KAAAA,OAAS,KAIfpJ,KAAKqJ,QAAU,CAACD,GAChBpJ,KAAKsJ,gBAAkB,UACvBtJ,KAAKuJ,SAAW,SAClB,CAsEF,OApEE,YAAAC,WAAA,SAAWH,GACTrJ,KAAKqJ,QAAUA,CACjB,EAEM,YAAAI,KAAN,W,gHACuB,EAAAzJ,KAAKqJ,Q,sBAAL,YAAY,YAAtBD,EAAM,K,iBAGI,O,sBADXM,EAAW,KAAON,EAAOO,QAAQ,IAAK,KAAO,iBAClC,GAAMR,EAAQO,I,OAI/B,OAJME,EAAW,SACjBC,QAAQpJ,IAAImJ,GACZ5J,KAAKuJ,SAAWK,EAChB5J,KAAKoJ,OAASA,EACd,M,yBAEAS,QAAQC,KAAK,G,aAII,O,sBADXJ,EAAW,KAAON,EAAOW,MAAM,KAAK,GAAK,iBAC9B,GAAMZ,EAAQO,I,OAI/B,OAJME,EAAW,SACjBC,QAAQpJ,IAAImJ,GACZ5J,KAAKuJ,SAAWK,EAChB5J,KAAKoJ,OAASA,EAAOW,MAAM,KAAK,GAChC,M,yBAEAF,QAAQC,KAAK,G,oBAnBI,I,+BA2BhB,YAAAE,WAAP,SAAkBC,EAAqBC,EAAeC,GACpD,IAAMC,EAASpK,KAAKqK,aAAaJ,GACjC,GAAIG,EAAQ,CACV,IAAMzE,EAAU,IAAI,UAAkByE,EAAOzE,QAAS3F,KAAKoJ,OAAQe,GAASG,OAAOJ,GACnF,OAAKvE,EAGD5D,MAAMwI,QAAQ5E,GACTA,EAAQ1D,KAAK,IAEf0D,EALEsE,C,CAOX,OAAOA,CACT,EAKQ,YAAAO,wBAAR,SAAgCP,GAC9B,OAAKnH,OAAO2H,eAAeC,KAAK1K,KAAKsJ,gBAAiBW,GAI/CjK,KAAKsJ,gBAAgBW,IAH1BJ,QAAQC,KAAK,2CAAoCG,EAAW,0BACrD,KAGX,EAKQ,YAAAI,aAAR,SAAqBJ,GACnB,OAAKjK,KAAKuJ,UAAazG,OAAO2H,eAAeC,KAAK1K,KAAKuJ,SAAUU,GAI1DjK,KAAKuJ,SAASU,IAHnBJ,QAAQC,KAAK,qCAA8BG,EAAW,sBAAcjK,KAAKoJ,OAAM,gCACxEpJ,KAAKwK,wBAAwBP,GAGxC,EACF,EA/EA,G,YAiFa,EAAAU,KAAO,IAAIC,EAAK,K,k6ECrG7B,cASA,cACA,cASA,cACA,cACA,WACA,cAGA,WAEA,cACA,cAEMC,EAAqB,GAE3B,aA6CE,WACEC,EACAC,EACAC,EACAC,GAvCQ,KAAAC,cAAmD,KACnD,KAAAC,eAAqD,KAGrD,KAAAC,gBAAwE,KACxE,KAAAC,iBAA0E,KAoB1E,KAAAC,YAAc,EACd,KAAAC,eAAiB,EAIjB,KAAAC,mBAA0B,KAWlCxL,KAAK8K,SAAWA,EAChB9K,KAAK+K,UAAYA,EACjB/K,KAAKgL,OAASA,EAEdhL,KAAKyE,cAAgB,gBAAiBzE,KAAKgL,OAE3ChL,KAAKiL,YAAa,IAAAQ,UAAS,KAAK,EAAMR,GACtCjL,KAAK0L,UAAW,EAChB1L,KAAK2L,UAAuC,mBAA3BC,KAAK/L,SAASgM,QACjC,CA2zCF,OAzzCE,YAAAC,oBAAA,WACE,MAAO,CAEL,kBACA,mBAGA,kBACA,mBAGA,kBACA,mBAGA,gBACA,iBACA,gBACA,iBAGA,mBACA,oBAEJ,EAEA,YAAAC,oBAAA,WACE,OAAO/L,KAAK8K,QACd,EAEA,YAAAkB,aAAA,SAAaC,GACXjM,KAAKkM,cAAgBD,CACvB,EAEO,YAAAE,cAAP,SAA+CC,GAC7C,OAAQA,IAAmB,EAAAlN,aAAaE,OAASY,KAAKmL,eAAiBnL,KAAKkL,aAC9E,EAEM,YAAAmB,OAAN,W,0EACErM,KAAK0L,UAAW,EAChB1L,KAAKgL,OAAOqB,S,WAGd,YAAAC,eAAA,gBACkC,IAArBtM,KAAKsL,cACdtL,KAAKsL,YAAc,GAErBtL,KAAKsL,cACLtL,KAAKiL,WACH3G,KAAKiI,IACH,EACA,GAAOvM,KAAKsL,aAAetL,KAAKuL,eAAiB,GAAM,IAEzDvL,KAAKsL,aAEP,UAAO7K,IAAI,mBAAYT,KAAKsL,YAAW,yBAAiBtL,KAAKuL,eAAc,YAC7E,EAEA,YAAAiB,YAAA,SAAY,G,IAAClB,EAAW,cAAEC,EAAc,iBACtCvL,KAAKsL,YAAcA,EACnBtL,KAAKuL,eAAiBA,EACtBvL,KAAKiL,WACH3G,KAAKiI,IACH,EACA,GAAOvM,KAAKsL,aAAetL,KAAKuL,eAAiB,GAAM,IAEzDvL,KAAKsL,YAET,EAEA,YAAAmB,aAAA,SAAaC,GACX,MAAM,IAAIzM,MAAM,qBAClB,EAEM,YAAA0M,KAAN,W,0GAKE,OAHA3M,KAAKiL,WAAW,KAEhBjL,KAAK4M,eAAiB,EAAA1N,aAAaC,MACnC,GAAMa,KAAK6M,e,OAKX,GALA,SAGA7M,KAAKiL,WAAW,KAEZjL,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mB,OAGZ,UAAOrM,IAAI,CAACyK,cAAelL,KAAKkL,cAAeC,eAAgBnL,KAAKmL,eAAgBe,cAAelM,KAAKkM,gBAEnGlM,KAAKoL,iBAAoBpL,KAAKqL,iBAA/B,MAC4C,GAAMrL,KAAK+M,Y,OAAnD,EAAwC,SAAtC3B,EAAe,kBAAEC,EAAgB,mBACzC,UAAO5K,IAAI,CAAE2K,gBAAe,EAAEC,iBAAgB,IAC9CrL,KAAKoL,gBAAkBA,EACvBpL,KAAKqL,iBAAmBA,EACxBrL,KAAKiL,WAAW,K,iBAGlB,GAAIjL,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mB,OAGP9M,KAAKgN,iBAAN,OACF,EAAAhN,KAAwB,GAAMA,KAAKiN,eAAejN,KAAKoL,gBAAiBpL,KAAKqL,iBAAkB,EAAAnM,aAAaE,U,OAA5G,EAAK4N,iBAAmB,S,iBAG1B,GAAIhN,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mB,OAGP9M,KAAKkN,gBAAN,OACF,EAAAlN,KAAuB,GAAMA,KAAKiN,eAAejN,KAAKqL,iBAAkBrL,KAAKoL,gBAAiB,EAAAlM,aAAaC,S,OAA3G,EAAK+N,gBAAkB,S,iBAmBzB,GAdKlN,KAAKmN,mBAERC,EAAmBpN,KAAK8K,SAASuC,cACjC,UAAO5M,IAAI,uBAEXT,KAAKmN,iBAAmB,CACtBG,OAAQtN,KAAKgN,iBAAiBM,OAAO7J,IAAI2J,EAAkB,EAAAlO,aAAaE,QACxEmO,OAAQvN,KAAKgN,iBAAiBO,OAAO9J,IAAI2J,EAAkB,EAAAlO,aAAaE,QACxEoO,KAAMxN,KAAKgN,iBAAiBQ,KAC5BC,OAAQzN,KAAKgN,iBAAiBS,OAAOhK,IAAI2J,EAAkB,EAAAlO,aAAaE,QACxEsO,QAAS1N,KAAKgN,iBAAiBU,UAI/B1N,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAiBZ,GAdK9M,KAAK2N,kBAEHP,IAAkBA,EAAmBpN,KAAK8K,SAASuC,eACxD,UAAO5M,IAAI,sBAEXT,KAAK2N,gBAAkB,CACrBL,OAAQtN,KAAKkN,gBAAgBI,OAAO7J,IAAI2J,EAAkB,EAAAlO,aAAaC,OACvEoO,OAAQvN,KAAKkN,gBAAgBK,OAAO9J,IAAI2J,EAAkB,EAAAlO,aAAaC,OACvEqO,KAAMxN,KAAKkN,gBAAgBM,KAC3BC,OAAQzN,KAAKkN,gBAAgBO,OAAOhK,IAAI2J,EAAkB,EAAAlO,aAAaC,OACvEuO,QAAS1N,KAAKkN,gBAAgBQ,UAI9B1N,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAoCZ,OAjCA,UAAOrM,IAAI,CAACmN,UAAW5N,KAAK2N,gBAAiBE,WAAY7N,KAAKmN,mBAE9DnN,KAAK8N,cAAc9N,KAAK2N,gBAAgBF,QAEnCzN,KAAK+N,gBACR/N,KAAK+N,cAAgB,CACnBT,OAAQ,IAAI,UACZC,OAAQ,IAAI,UACZC,KAAM,IAAI,UACVC,OAAQ,IAAI,UACZC,QAAS,IAAI,WAGf1N,KAAKgO,eAAiB,CACpBV,OAAQ,IAAI,UACZC,OAAQ,IAAI,UACZC,KAAM,IAAI,UACVC,OAAQ,IAAI,UACZC,QAAS,IAAI,YAIZ1N,KAAKiO,gBACRjO,KAAKiO,cAAgBjO,KAAK2N,gBAAgBD,QAC1C1N,KAAKkO,eAAiBlO,KAAKmN,iBAAiBO,SAGzC1N,KAAKuL,iBACRvL,KAAKuL,eAAiBzI,OAAOC,OAAO/C,KAAKmN,kBAAkB/I,QAAO,SAAC+J,EAAKC,GAAS,OAAAA,EAAKC,aAAa7J,OAAS2J,CAA3B,GAAgC,GAC/GrL,OAAOC,OAAO/C,KAAK2N,iBAAiBvJ,QAAO,SAAC+J,EAAKC,GAAS,OAAAA,EAAKC,aAAa7J,OAAS2J,CAA3B,GAAgC,IAG9F,UAAO1N,IAAI,yBACX,GAAMT,KAAKsO,QAAQtO,KAAKgL,OAAQhL,KAAKmN,iBAAkB,EAAAjO,aAAaE,OAAQY,KAAKgO,eAAgBhO,KAAKkO,iB,OAEtG,GAFA,SAEIlO,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAIZ,OADA,UAAOrM,IAAI,wBACX,GAAMT,KAAKsO,QAAQtO,KAAK+K,UAAW/K,KAAK2N,gBAAiB,EAAAzO,aAAaC,MAAOa,KAAK+N,cAAe/N,KAAKiO,gB,OAEtG,GAFA,SAEIjO,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAUZ,GAPI,gBAAiB9M,KAAKgL,SAAWhL,KAAKuO,qBAExCnB,EAAmBpN,KAAK8K,SAASuC,cACjCrN,KAAKuO,mBAAqBvO,KAAKwO,qBAAqBxO,KAAKiO,cAAejO,KAAKgO,eAAgB,EAAA9O,aAAaC,MAAOiO,GACjHpN,KAAKyO,mBAAqBzO,KAAKwO,qBAAqBxO,KAAKkO,eAAgBlO,KAAK+N,cAAe,EAAA7O,aAAaE,OAAQgO,IAGhHpN,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mB,MAGR,gBAAiB9M,KAAKgL,QACxB,UAAOvK,IAAI,yBACX,GAAMyD,QAAQwK,IAAI,CAChB1O,KAAK2O,mBAAmB3O,KAAKgL,OAAQhL,KAAKyO,oBAC1CzO,KAAK2O,mBAAmB3O,KAAK+K,UAAW/K,KAAKuO,wBAJ7C,O,QAEF,S,qCAOY,YAAA1B,YAAhB,W,2GACO7M,KAAKkL,cAAN,OACF,UAAOzK,IAAI,yBACW,GAAMT,KAAK+K,UAAU6D,qB,cAArC1D,EAAgB,SACtB,UAAOzK,IAAI,4CACXT,KAAK6O,6BAA6B3D,GAC9BlL,KAAKgL,kBAAkB,WACzB,UAAOvK,IAAI,qCACX,GAAMT,KAAK8O,mCAAmC5D,KAF5C,M,OAEF,S,iBAEFlL,KAAKkL,cAAgBA,E,iBAMvB,GAFAlL,KAAKkM,cAAc1M,GAAKQ,KAAKkL,cAAc1L,GAEvCQ,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mB,OAGP9M,KAAKmL,eAAN,OACF,UAAO1K,IAAI,0BACY,GAAMT,KAAKgL,OAAO4D,qB,OAIzC,GAJMzD,EAAiB,SACvB,UAAO1K,IAAI,0CACXT,KAAK+O,0BAA0B5D,GAE3BnL,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAGZ,SAAM9M,KAAK8K,SAASkE,UAAU,CAAEC,QAASjP,KAAKkL,cAAc1L,GAAI0P,SAAU/D,EAAe3L,M,cAAzF,SACM4N,EAAmBpN,KAAK8K,SAASuC,cAEnC,uBAAwBrN,KAAKgL,QAC/B,UAAOvK,IAAI,oCAEX,GAAMT,KAAKmP,aAAahE,EAAgBiC,GAAkB,KAHxD,M,OAGF,S,iBAEFpN,KAAKmL,eAAiBA,E,wBAIxB,UAAO1K,IAAI,qCACXT,KAAKkL,cAAc5J,cACnB,UAAOb,IAAI,qCACXT,KAAKkM,cAAc5K,cACnB,UAAOb,IAAI,sCACXT,KAAKmL,eAAe7J,c,YAGZ,YAAAwM,cAAV,SAAwBsB,GACtB,IAAMC,EAAkBrP,KAAKkL,cAActJ,QACrC0N,EAAoBF,EAASf,aAAajK,QAAO,SAACxC,EAAO2N,GAAW,OAAA3N,EAAQ2N,EAAO5H,QAAQ/F,OAAvB,GAAgC,GAG1G,GADA,UAAOnB,IAAI,sBAAwB6O,EAAoB,IAAMD,EAAkB,IAAOC,EAAoBD,GACtGA,EAAkB,GAAKC,EAAoBD,EAAkB,GAAK,CACpE,IAAMG,EAAWxP,KAAKgL,OAAOyE,UAAUD,SACvC,IAAiB,IAAbA,QAA0C,IAAbA,EAC/B,MAAM,IAAI,EAAAE,cAAcpL,KAAKqL,KAAML,EAAoBD,EAAmB,K,CAGhF,EAEA,YAAAR,6BAAA,SAA6BvJ,GAA7B,WACEA,EAAK3C,SAAW2C,EAAK3C,SAASK,QAAO,SAAAO,GACnC,OAAIA,aAAiB,EAAA3C,SACZ,EAAKoK,OAAO4E,gBAAgBrM,IAEnC,EAAKsL,6BAA6BtL,IAC3B,EAEX,GACF,EAEA,YAAAwL,0BAAA,SAA0BzJ,GAA1B,WACEA,EAAK3C,SAAW2C,EAAK3C,SAASK,QAAO,SAAAO,GACnC,GAAIA,aAAiB,EAAA3C,SAAU,CAE7B,GAAI,EAAK+K,WAAapI,EAAM7D,IAAImQ,WAAW,UACzC,OAAO,EAGT,GAAkB,OAAdtM,EAAM7D,IACR,OAAO,C,MAGT,EAAKqP,0BAA0BxL,GAEjC,OAAO,CACT,GACF,EAEM,YAAAuL,mCAAN,SAAyCxJ,G,yFACjCwK,EAAU,CAAC,EACXC,EAAa,GACnBzK,EAAK3C,SAAW2C,EAAK3C,SAASK,QAAO,SAAAO,GACnC,GAAIA,EAAMzD,OAAS,EAAAT,SAASE,SAAU,CACpC,GAAIuQ,EAAQvM,EAAM7D,KAEhB,OADAqQ,EAAWtK,KAAKlC,IACT,EAETuM,EAAQvM,EAAM7D,KAAO6D,C,MAErB,EAAKuL,mCAAmCvL,GAE1C,OAAO,CACT,IACAwM,EAAWvL,QACT,UAAO/D,IACL,uDACAsP,G,WAIA,YAAAhD,SAAN,W,iHAwG0B,OAvGlBK,EAAmBpN,KAAK8K,SAASuC,cAEjC2C,EAAc,GAGoB,cAApChQ,KAAK+K,UAAUkF,YAAY1I,MAE7B2I,EAAe,IAAI,UACjBlQ,KAAKkM,cACLlM,KAAKkL,eAGL,SAACiF,EAASC,GACR,QAAID,EAAQrQ,OAASsQ,EAAQtQ,MAGR,aAAjBqQ,EAAQrQ,MAAwC,aAAjBsQ,EAAQtQ,MAAuBqQ,EAAQzQ,MAAQ0Q,EAAQ1Q,MAGtF,UAAS2Q,SAASjD,EAAkB+C,EAASC,KAG5B,WAAjBD,EAAQrQ,OAAqBqQ,EAAQzP,aAAa0P,IAIxD,GACApQ,KAAKyE,eAEP6L,EAAgB,IAAI,UAClBtQ,KAAKkM,cACLlM,KAAKmL,gBAKL,SAACgF,EAASC,GACR,OAAID,EAAQrQ,OAASsQ,EAAQtQ,OAGR,aAAjBqQ,EAAQrQ,MAAwC,aAAjBsQ,EAAQtQ,MAAuBqQ,EAAQzQ,MAAQ0Q,EAAQ1Q,OAGtF,UAAS2Q,SAASjD,EAAkB+C,EAASC,MAI7CD,EAAQzP,aAAa0P,MAHvBJ,EAAYvK,KAAK,CAAC0K,EAASC,KACpB,EAOX,GACApQ,KAAKyE,iBAIPyL,EAAe,IAAI,UACjBlQ,KAAKkM,cACLlM,KAAKkL,eACL,SAACiF,EAASC,GACR,OAAID,EAAQrQ,OAASsQ,EAAQtQ,OAIR,aAAjBqQ,EAAQrQ,MAAwC,aAAjBsQ,EAAQtQ,MAAuBqQ,EAAQzQ,MAAQ0Q,EAAQ1Q,QAGtF,UAAS2Q,SAASjD,EAAkB+C,EAASC,EAInD,GACApQ,KAAKyE,eAEP6L,EAAgB,IAAI,UAClBtQ,KAAKkM,cACLlM,KAAKmL,gBAEL,SAACgF,EAASC,GACR,OAAID,EAAQrQ,OAASsQ,EAAQtQ,OAIR,aAAjBqQ,EAAQrQ,MAAwC,aAAjBsQ,EAAQtQ,MAAuBqQ,EAAQzQ,MAAQ0Q,EAAQ1Q,OAGtF,UAAS2Q,SAASjD,EAAkB+C,EAASC,MAI5B,aAAjBD,EAAQrQ,MAAwC,aAAjBsQ,EAAQtQ,OACrCqQ,EAAQzP,aAAa0P,OAJzBJ,EAAYvK,KAAK,CAAC0K,EAASC,KACpB,EASX,GACApQ,KAAKyE,gBAGT,UAAOhE,IAAI,uEACa,GAAMyP,EAAaK,O,OAClB,OADnBnF,EAAkB,SACC,GAAMkF,EAAcC,O,OAC7C,OADMlF,EAAmB,SACzB,GAAMtH,EAASN,IAAIuM,GAAa,SAAC,G,IAACQ,EAAS,KAAEC,EAAU,KAAM,SAAKC,WAAW,EAAK1F,OAAQwF,EAAWC,EAAWjR,GAAnD,GAAwD,K,OACrH,OADA,SACO,CAAP,EAAO,CAAC4L,gBAAe,EAAEC,iBAAgB,I,QAGrC,YAAA4B,eAAN,SACE0D,EACAC,EACAxE,G,iIAkCA,OAhCA,UAAO3L,IAAI,2CAA6C2L,GAClDgB,EAAmBpN,KAAK8K,SAASuC,cAEjCwD,EAAkBD,EAAiBtD,OAAOe,aAC1CyC,EAAiBF,EAAiBnD,OAAOY,aACzC0C,EAAcH,EAAiBpD,KAAKa,aACpC2C,EAAgBJ,EAAiBrD,OAAOc,aACxC4C,EAAiBL,EAAiBlD,QAAQW,aAE1C6C,EAAkBP,EAAiBrD,OAAOe,aAC1C8C,EAAiBR,EAAiBlD,OAAOY,aACzC+C,EAAcT,EAAiBnD,KAAKa,aAEpCgD,EAA8CjF,IAAmB,EAAAlN,aAAaC,MAAQa,KAAKkL,cAAgBlL,KAAKmL,eAChHmG,EAA2BlF,IAAmB,EAAAlN,aAAaC,MAAQa,KAAKmL,eAAiBnL,KAAKkL,cAE9FqG,EAA2BZ,EAAiBrD,OAAOe,aACtDmD,OAAOb,EAAiBnD,KAAKa,cAC7BmD,OAAOZ,EAAiBtD,OAAOe,cAC/BmD,OAAOZ,EAAiBpD,KAAKa,cAE1BoD,EAAsB,CAAC,EAGvBC,EAAiC,CACrCpE,OAAQ,IAAI,UACZC,OAAQ,IAAI,UACZC,KAAM,IAAI,UACVC,OAAQ,IAAI,UACZC,QAAS,IAAI,WAGf,GAAM3J,EAASC,KAAK2M,EAAiBlD,OAAOY,cAAc,SAAMkB,GAAM,qC,2BAIpE,OAH0BuB,EAAelN,MAAK,SAAA+N,GAC5C,OAACpC,EAAO5H,QAAQ7H,OAAS6R,EAAchK,QAAQ7H,MAAQ,UAASuQ,SAASjD,EAAkBmC,EAAO5H,QAASgK,EAAchK,UACzH,UAAKiK,UAAUxE,EAAkBmE,EAAyBF,EAAY9B,EAAO5H,QAASgK,EADtF,KAOqBZ,EAAYnN,MAAK,SAAAiO,GACtC,OAAAtC,EAAO5H,QAAQ7H,OAAS+R,EAAWlK,QAAQ7H,MAAQ,UAASuQ,SAASjD,EAAkBmC,EAAO5H,QAASkK,EAAWlK,QAAlH,KAEoByE,IAAmBpM,KAAK4M,gBAK9C8E,EAAWjE,OAAOqE,OAAOvC,GAXvB,G,SAYD1E,I,OAEH,OApBA,SAoBA,GAAM9G,EAASC,KAAK2M,EAAiBrD,OAAOe,cAAc,SAAMkB,GAAM,qC,wEAC9DwC,EAAqBlB,EAAgBjN,MAAK,SAAAV,GAAK,OACnDqM,EAAO5H,QAAQlI,WAAa,UAASuS,YAAY5E,EAAkBlK,EAAEyE,QAAS4H,EAAO5H,QAAQ9H,WAC7F0P,EAAO5H,QAAQjH,aAAawC,EAAEyE,QAFqB,MAM7C,EAAc,GAepB,GAdmB,IAAI,UACrBoK,EAAmBpK,QACnB4H,EAAO5H,SACP,SAACwI,EAASC,GACR,QAAID,EAAQrQ,OAASsQ,EAAQtQ,OAAQqQ,EAAQzP,aAAa0P,KAExD,EAAY3K,KAAK,CAAC0K,EAASC,EAAQ5Q,KAC5B,GAGX,GACAQ,KAAKyE,eACL,GAEe8L,QAjBf,M,OAmBF,OAFA,SACA,EAAY9K,KAAK,CAACsM,EAAmBpK,QAAS4H,EAAO5H,QAAQnI,KAC7D,GAAMuE,EAASC,KAAK,GAAa,SAAM,G,IAACmM,EAAO,KAAE8B,EAAK,K,uFACpD,SAAMjS,KAAK0Q,WAAWnB,EAAO5H,QAAQ9H,WAAa,EAAAX,aAAaC,MAAQa,KAAK+K,UAAY/K,KAAKgL,OAAQmF,EAAS8B,I,cAA9G,S,aACA,I,OAEF,OAJA,SAIA,I,OAMF,OAJ0BrB,EAAiBnD,OAAOY,aAAazK,MAAK,SAAA+N,GAElE,iBAAKC,UAAUxE,EAAkBmE,EAAyBD,EAAY/B,EAAO5H,QAASgK,EAAtF,KAGAF,EAAoBlC,EAAO5H,QAAQlI,WAAY,EAE/C,MAGFiS,EAAWpE,OAAOwE,OAAOvC,G,cACxB1E,I,OAEH,OA3CA,SA2CA,GAAM9G,EAASC,KAAK2M,EAAiBnD,KAAKa,cAAc,SAAMkB,GAAM,qC,6CAClE,OAAInD,IAAmBpM,KAAK4M,gBACHmE,EAAYnN,MAAK,SAAAV,GACtC,OAAAqM,EAAO5H,QAAQ7H,OAASoD,EAAEyE,QAAQ7H,MAAQ,UAASuQ,SAASjD,EAAkBmC,EAAO5H,QAASzE,EAAEyE,QAAhG,IAGA,KAIEuK,EAA6BpB,EAAelN,MAAK,SAAA+N,GACrD,OAAO,UAAKC,UAAUxE,EAAkBmE,EAAyBD,EAAY/B,EAAO5H,QAASgK,EAC/F,IACMQ,EAAgCrB,EAAelN,MAAK,SAAA+N,GACxD,OAACpC,EAAO5H,QAAQ7H,OAAS6R,EAAchK,QAAQ7H,MAAQ,UAASuQ,SAASjD,EAAkBmC,EAAO5H,QAASgK,EAAchK,UACzH,UAAKiK,UAAUxE,EAAkBmE,EAAyBD,EAAY/B,EAAOY,QAASwB,EADtF,IAGIS,EAAgCjB,EAAevN,MAAK,SAAAyO,GACxD,OAAO,UAAKT,UAAUxE,EAAkBmE,EAAyBF,EAAY9B,EAAOY,QAASkC,EAC/F,IACMC,EAAgCnB,EAAevN,MAAK,SAAAyO,GAExD,iBAAKT,UAAUxE,EAAkBmE,EAAyB,IAAI,EAAA/N,OAAO,CAAChE,GAAI,EAAGK,SAAUuM,IAAkBmD,EAAO5H,QAAS0K,EAAzH,IAEEH,GAEGC,GAAkCC,IAGrCV,EAAWjE,OAAOqE,OAAO,CAAEhS,KAAM,EAAAyS,WAAW9E,OAAQ9F,QAAS4H,EAAOY,QAASA,QAAS,OACtFqC,EAAYC,uBAAuBrF,EAAkBuD,EAAiBjD,QAAS6B,EAAOY,SACtFsB,EAAoBlC,EAAO5H,QAAQnI,KAAM,GAG3C,KAEE8S,GAEElG,IAAmBpM,KAAK4M,gBAC1B8E,EAAWjE,OAAOqE,OAAO,CAAEhS,KAAM,EAAAyS,WAAW9E,OAAQ9F,QAAS4H,EAAOY,QAASA,QAAS,OAExFqC,EAAYC,uBAAuBrF,EAAkBuD,EAAiBjD,QAAS6B,EAAOY,SACtFsB,EAAoBlC,EAAO5H,QAAQnI,KAAM,EACzC,KAEE2S,GAEE/F,IAAmBpM,KAAK4M,iBAEpB8F,EAAmBxB,EAAgBtN,MAAK,SAAA+O,GAAY,OAAAA,EAAShL,QAAQpG,SAAS,EAAAlC,SAASC,OAAQiQ,EAAO5H,QAAQlI,SAA1D,KAGpDmT,EAAarD,EAAO5H,QAAQxG,SACnBrB,OAAS,EAAAT,SAASC,QAC/BsT,EAAW9O,UAAS,SAACG,EAAMX,GACzB,IAAMuP,EAAU1B,EAAevN,MAAK,SAAAV,GAAK,iBAASmN,SAASjD,EAAkBnJ,EAAMf,EAAEyE,QAA5C,IACnCmL,EAAY1B,EAAYxN,MAAK,SAAAV,GAAK,iBAASmN,SAASjD,EAAkBnJ,EAAMf,EAAEyE,QAA5C,KACpCkL,GAAYC,GAAa,UAASd,YAAY5E,EAAkB0F,EAAUnL,QAAS1D,EAAKpE,YAAcoE,EAAKxE,WAC7G6D,EAAOX,SAASoQ,OAAOzP,EAAOX,SAASvC,QAAQ6D,GAAO,EAE1D,IAGEyO,GAAoBA,EAAiB/K,QAAQ7H,OAAS,EAAAT,SAASC,OAElDoT,EAAiB/K,QAAQtE,WAAWkM,EAAO5H,QAAQlI,UAC3DkD,SAASoQ,OAAOxD,EAAO1M,MAAO,EAAG+P,GAExClB,EAAWpE,OAAOwE,OAAO,CAAEhS,KAAM,EAAAyS,WAAWjF,OAAQ6C,QAAS,KAAMxI,QAASiL,KAGhF,MAGII,EAA+BjC,EAAY/N,QAAO,SAAA6O,GACtD,OAAO,UAAKD,UAAUxE,EAAkBmE,EAAyBD,EAAY/B,EAAO5H,QAASkK,IAC3F,UAAKD,UAAUxE,EAAkBmE,EAAyBF,EAAYQ,EAAWlK,QAAS4H,EAC9F,KACiC/K,QAC3B4H,IAAmBpM,KAAK4M,gBAC1B8E,EAAWlE,KAAKsE,OAAOvC,GAEvByD,EAA6BjO,SAAQ,SAAA7B,GAEnC,IAAMyE,EAAUzE,EAAEiN,QAAQ9O,mBAAkB,EAAOkO,EAAO5H,QAAQ9H,UAC5DsQ,EAAUjN,EAAEyE,QAAQtG,mBAAkB,EAAOkO,EAAOY,QAAQtQ,UAClEsQ,EAAQ3Q,GAAK,UAASyT,MAAM7F,EAAkBlK,EAAEyE,QAAS4H,EAAOY,QAAQtQ,UACxEsQ,EAAQ1Q,SAAW,UAASuS,YAAY5E,EAAkBlK,EAAEyE,QAAS4H,EAAOY,QAAQtQ,UAIlF6R,EAAWlE,KAAKa,aAAazK,MAAK,SAAAsP,GAAQ,OAAA1R,OAAO0R,EAAKvL,QAAQnI,MAAQgC,OAAOmG,EAAQnI,GAA3C,KAC1C4R,EAAYxN,MAAK,SAAAsP,GAAQ,OAAA1R,OAAO0R,EAAKvL,QAAQnI,MAAQgC,OAAOmG,EAAQnI,GAA3C,KAEzBsR,EAAelN,MAAK,SAAAuP,GAAU,iBAAKvB,UAAUxE,EAAkBmE,EAAyBD,EAAY/B,EAAO5H,QAASwL,EAAtF,KAC9BhC,EAAevN,MAAK,SAAAuP,GAAU,iBAAKvB,UAAUxE,EAAkBmE,EAAyBF,EAAY9B,EAAO5H,QAASwL,EAAtF,MAMhCzB,EAAWlE,KAAKsE,OAAO,EAAD,KAAM5O,GAAC,CAAEyE,QAAO,EAAEwI,QAAO,KAC/CqC,EAAYC,uBAAuBrF,EAAkBuD,EAAiBjD,QAAS/F,GAC/E6K,EAAYC,uBAAuBrF,EAAkBuD,EAAiBjD,QAASyC,GACjF,MAEAqC,EAAYC,uBAAuBrF,EAAkBuD,EAAiBjD,QAAS6B,EAAOY,SACtFqC,EAAYC,uBAAuBrF,EAAkBuD,EAAiBjD,QAAS6B,EAAO5H,UAExF,MAGF+J,EAAWlE,KAAKsE,OAAOvC,G,cACtB,I,OAEH,OAnHA,SAmHA,GAAMxL,EAASC,KAAK2M,EAAiBpD,OAAOc,cAAc,SAAMkB,GAAM,qC,2BAGpE,OAFyByB,EAAcpN,MAAK,SAAAV,GAC1C,OAAAqM,EAAO5H,QAAQ7H,OAASoD,EAAEyE,QAAQ7H,MAAQ,UAASuQ,SAASjD,EAAkBmC,EAAO5H,QAASzE,EAAEyE,QAAhG,KACsByE,IAAmBpM,KAAK4M,gBAItBkE,EAAelN,MAAK,SAAAV,GAC5C,OAAAA,EAAEyE,QAAQpG,SAASgO,EAAO5H,QAAQ7H,KAAM,UAASmT,MAAM7F,EAAkBmC,EAAO5H,QAASzE,EAAEyE,QAAQ9H,YACnGqD,EAAEyE,QAAQpG,SAAS,EAAAlC,SAASC,OAAQ,UAAS0S,YAAY5E,EAAkBmC,EAAO5H,QAASzE,EAAEyE,QAAQ9H,UADrG,KAOF6R,EAAWnE,OAAOuE,OAAOvC,GAVvB,G,kBAaJ,OAlBA,SAkBA,GAAMxL,EAASC,KAAK2M,EAAiBjD,QAAQW,cAAc,SAAMkB,GAAM,qC,2BACrE,OAAIkC,EAAoBlC,EAAO5H,QAAQnI,KAInC4M,IAAmBpM,KAAK4M,gBACAqE,EAAerN,MAAK,SAAAV,GAC5C,OAAAqM,EAAO5H,QAAQ7H,OAASoD,EAAEyE,QAAQ7H,MAAQ,UAASuQ,SAASjD,EAAkBmC,EAAO5H,QAASzE,EAAEyE,QAAhG,KAMsBmJ,EAAelN,MAAK,SAAAV,GAC5C,OAAAA,EAAEyE,QAAQpG,SAAS,SAAUgO,EAAO5H,QAAQnI,GAA5C,KAMFkS,EAAWhE,QAAQoE,OAAOvC,GAlBxB,G,kBAqBJ,OAvBA,SAuBO,CAAP,EAAOmC,G,QAGH,YAAApD,QAAN,SACEnM,EACAiR,EACAhH,EACAiH,EACAC,G,6GACA,UAAO7S,IAAI,aAAe2L,EAAiB,cAEvCmH,EAAgBH,EAAW9F,OAAOe,a,wBAC/BkF,EAAc/O,OAAS,GAC5B,UAAO/D,IAAI2L,EAAiB,uBAC5B,GAAMrI,EAASC,KACbuP,GACA,SAAChE,GAAW,SAAKiE,cAAcrR,EAAUoN,EAAQnD,EAAgBgH,EAAW9F,OAAQgG,EAAUD,EAAlF,GACZxI,KAL2B,M,cAE7B,SAKA0I,EAAgBH,EAAW9F,OAAOe,a,aAGpC,GAAIrO,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAKZ,OAFA,UAAOrM,IAAI2L,EAAiB,uBAE5B,GAAMrI,EAASC,KACboP,EAAW7F,OAAOc,cAClB,SAACkB,GAAW,SAAKkE,cAActR,EAAUoN,EAAQnD,EAAgBgH,EAAW7F,OAAQ8F,EAAxE,GACZxI,I,OAGF,GANA,SAMI7K,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAcZ,GAXMM,EAAmBpN,KAAK8K,SAASuC,cACvC,UAAO5M,IAAI2L,EAAiB,mBAEtBsH,EAAsF,CAC1FpG,OAAQ8F,EAAW9F,OACnBC,OAAQ6F,EAAW7F,OACnBC,KAAM4F,EAAW5F,KAAK/J,IAAI2J,EAAkBhB,GAC5CqB,OAAQ2F,EAAW3F,OACnBC,QAAS0F,EAAW1F,SAGlB1N,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAKZ,GAFM6G,EAAU,UAAKC,UAAUF,EAAWlG,KAAKa,aAAcrO,KAAKmM,cAAcC,IAE5EpM,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAIZ,OADA,UAAOrM,IAAI2L,EAAiB,qBAC5B,GAAMrI,EAASC,KAAK2P,GAAS,SAAAE,GAAS,OAAA9P,EAASC,KAAK6P,GAAO,SAACtE,GAC1D,OAAO,EAAKkE,cAActR,EAAUoN,EAAQnD,EAAgBsH,EAAWlG,KAAM6F,EAC/E,GAAGxI,EAFmC,GAEd,I,OAExB,GAJA,SAII7K,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAIZ,OADA,UAAOrM,IAAI2L,EAAiB,uBAC5B,GAAMrI,EAASC,KAAK0P,EAAWjG,OAAOY,cAAc,SAACkB,GACnD,OAAO,EAAKuE,cAAc3R,EAAUoN,EAAQnD,EAAgBsH,EAAWjG,OAAQ4F,EACjF,GAAGxI,I,cAFH,S,YAKI,YAAA2I,cAAN,SACErR,EACAoN,EACAnD,EACAgC,EACAkF,EACAD,G,+HAGA,SAAMnP,QAAQC,W,OAGd,GAHA,SACA,UAAO1D,IAAI,oBAAqB8O,GAE5BvP,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBASD,OANLiH,EAAO,WACX3F,EAAK4F,QAAQzE,GACb8D,EAAS/F,OAAOwE,OAAOvC,GACvB,EAAKjD,gBACP,EAEW,GAAMiD,EAAO5H,QAAQzF,YAAYC,I,OAC5C,YAAkB,KADZ3C,EAAK,WAGTuU,IACA,MAGFxE,EAAO5H,QAAQnI,GAAKA,EAEhB+P,EAAOY,QACT,GAAMnQ,KAAK0Q,WAAWvO,EAAUoN,EAAOY,QAAS3Q,IAD9C,O,OACF,S,iBAGF,GAAI+P,EAAO5H,mBAAmB,EAAAnE,UAAY+L,EAAOY,mBAAmB,EAAA3M,QAClE,MAAM,IAAIvD,MAAM,kD,KAGdsP,EAAO5H,mBAAmB,EAAAnE,QAAU+L,EAAO5H,QAAQhF,SAAS6B,QAAU+K,EAAOY,mBAAmB,EAAA3M,QAAhG,a,GAEF+L,EAAO5H,QAAQhF,SAASoC,SAAQ,SAACd,GAC/BA,EAAKxE,SAAWD,CAClB,MAEI,qBAAsB2C,GAAtB,a,KACEoN,EAAO5H,QAAQ/F,QAAU,IAAM5B,KAAKgL,kBAAkB,WAAtD,aACF,UAAOvK,IAAI,+B,iBAGQ,O,wBAAA,GAAM0B,EAAS8R,iBAAiBzU,EAAI+P,EAAOY,QAAQ9O,mBAAkB,EAAOkO,EAAO5H,QAAQ9H,Y,OAgB5G,OAhBM,EAAW,SACX,EAAc,GAepB,GAdmB,IAAI,UACrB0P,EAAOY,QACP,GACA,SAACA,EAASC,GACR,QAAID,EAAQrQ,OAASsQ,EAAQtQ,OAAQqQ,EAAQzP,aAAa0P,KAExD,EAAY3K,KAAK,CAAC0K,EAASC,EAAQ5Q,KAC5B,GAGX,GACAQ,KAAKyE,eACL,GAEe8L,O,OACjB,OADA,SACA,GAAMxM,EAASC,KAAK,GAAa,SAAM,G,IAACmM,EAAO,KAAE8B,EAAK,K,uFACpD,SAAMjS,KAAK0Q,WAAWvO,EAAUgO,EAAS8B,I,cAAzC,S,aACC,K,cAFH,SAII,gBAAiB9P,GACb,EAAmBnC,KAAK8K,SAASuC,cACvCrN,KAAKuL,iBACL+H,EAASxB,OAAO,CACdhS,KAAM,EAAAyS,WAAW7E,QACjByC,QAAS,EACTxI,QAAS4H,EAAOY,QAEhB+D,MAAO3E,EAAOY,QAAQxN,SAASc,KAAI,SAAAY,GAAK,OAAGvE,KAAMuE,EAAEvE,KAAMN,GAAI6E,EAAE7E,GAAvB,MAE1C,GAAM+P,EAAOY,QAAQrM,UAAS,SAACqQ,GAC7B,GAAIA,aAAwB,EAAA3Q,QAAU2Q,EAAaxR,SAAS6B,OAAS,EAAG,CAGtE,IAAMmD,EAAU,EAAStE,WAAW,UAAS4P,MAAM,EAAkBkB,EAAc/H,IAEnF,EAAKb,iBACL+H,EAASxB,OAAO,CACdhS,KAAM,EAAAyS,WAAW7E,QACjByC,QAASxI,EACTA,QAASwM,EACTD,MAAOC,EAAaxR,SAASc,KAAI,SAAAY,GAAK,OAAGvE,KAAMuE,EAAEvE,KAAMN,GAAI6E,EAAE7E,GAAvB,K,CAG5C,MAxBE,O,OAUF,S,mBAkBF,OADAuU,IACA,I,0BAEA,UAAOtT,IAAI,sDAAuD,G,6DAK5D2T,EAAW7E,EAAOY,QAAQ9O,mBAAkB,EAAOkO,EAAO5H,QAAQ9H,UAClEwU,EAAYD,EAASzR,SAASK,QAAO,SAAAO,GAAS,OAAAA,aAAiB,EAAA3C,QAAjB,I,uEAIjC,OAFjB,UAAOH,IAAI,kCACX2T,EAASzR,SAAW0R,EAAUtB,OAAO,EAAG,IACvB,GAAM5Q,EAAS8R,iBAAiB1E,EAAO5H,QAAQnI,GAAI4U,I,OAgBpE,OAhBMxK,EAAW,SACXoG,EAAc,GAepB,GAdmB,IAAI,UACrBoE,EACAxK,GACA,SAACuG,EAASC,GACR,QAAID,EAAQrQ,OAASsQ,EAAQtQ,OAAQqQ,EAAQzP,aAAa0P,KAExDJ,EAAYvK,KAAK,CAAC0K,EAASC,EAAQ5Q,KAC5B,GAGX,GACA,EAAKiF,eACL,GAEe8L,O,OACjB,OADA,SACA,GAAMxM,EAASC,KAAKgM,GAAa,SAAM,G,IAACG,EAAO,KAAE8B,EAAK,K,uFACpD,SAAMjS,KAAK0Q,WAAWvO,EAAUgO,EAAS8B,I,cAAzC,S,aACC,K,cAFH,S,0CApBKoC,EAAU7P,OAAS,E,QAAC,O,uCAyD3B,OA9BM,EAAmBxE,KAAK8K,SAASuC,cAEvBkC,EAAO5H,QAAQhF,SAC5BK,QAAO,SAAAiB,GAAQ,OAAAA,aAAgB,EAAAT,MAAhB,IACfR,QAAO,SAAAiB,GAAQ,OAAAA,CAAA,IAGfc,SAAQ,SAACxB,GAER,IAAMoE,EAAUpE,EAChBoE,EAAQlI,SAAW,UAASuS,YAAY,EAAkBzO,EAAO6I,GACjE,IAAM+D,EAAUZ,EAAOY,QAAQ5O,SAASgC,EAAMzD,KAAMyD,EAAM/D,IACpD8U,EAAY,CAAExU,KAAM,EAAAyS,WAAWjF,OAAQ3F,QAAO,EAAEwI,QAAO,GAC7D,EAAK5E,iBACL6C,EAAK0D,OAAOwC,EACd,IAEE,gBAAiBnS,IAEnBnC,KAAKuL,iBACL+H,EAASxB,OAAO,CACdhS,KAAM,EAAAyS,WAAW7E,QACjByC,QAASZ,EAAO5H,QAChBA,QAAS4H,EAAOY,QAEhB+D,MAAO3E,EAAO5H,QAAQhF,SAASc,KAAI,SAAAY,GAAK,OAAGvE,KAAMuE,EAAEvE,KAAMN,GAAI6E,EAAE7E,GAAvB,OAI5CuU,IACA,I,0BAEA,UAAOtT,IAAI,sDAAuD,G,eAMlE,EAAmBT,KAAK8K,SAASuC,cACvCkC,EAAO5H,QAAQhF,SACZoC,SAAQ,SAACxB,GAERA,EAAM9D,SAAW,UAASuS,YAAY,EAAkBzO,EAAO6I,GAC/D,IAAM+D,EAAUZ,EAAOY,QAAQ5O,SAASgC,EAAMzD,KAAMyD,EAAM/D,IACpD8U,EAAY,CAAExU,KAAM,EAAAyS,WAAWjF,OAAQ3F,QAASpE,EAAO4M,QAAO,GACpE,EAAK5E,iBACL6C,EAAK0D,OAAOwC,EACd,IAEE,gBAAiBnS,IAEnBnC,KAAKuL,iBACL+H,EAASxB,OAAO,CACdhS,KAAM,EAAAyS,WAAW7E,QACjByC,QAASZ,EAAO5H,QAChBA,QAAS4H,EAAOY,QAChB+D,MAAO3E,EAAOY,QAAQxN,SAASc,KAAI,SAAAY,GAAK,OAAGvE,KAAMuE,EAAEvE,KAAMN,GAAI6E,EAAE7E,GAAvB,O,0BAK9CuU,I,YAGI,YAAAD,cAAN,SACE3R,EACAoN,EACAnD,EACAgC,EACAiF,G,0FAGA,SAAMnP,QAAQC,W,OAGd,GAHA,SACA,UAAO1D,IAAI,oBAAqB8O,GAE5BvP,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAGZ,SAAMyC,EAAO5H,QAAQpF,YAAYJ,I,OACjC,OADA,SACA,GAAMnC,KAAKuU,cAAcpS,EAAUoN,EAAO5H,U,cAA1C,SACAyG,EAAK4F,QAAQzE,GACb8D,EAAS5F,OAAOqE,OAAOvC,GACvBvP,KAAKsM,iB,YAGD,YAAAmH,cAAN,SACEtR,EACAoN,EACAnD,EACAgC,EACAiF,G,0FAEA,SAAMnP,QAAQC,W,OAGd,GAHA,SACA,UAAO1D,IAAI,oBAAqB8O,GAE5BvP,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAGZ,SAAMyC,EAAO5H,QAAQtF,YAAYF,I,OACjC,OADA,SACA,GAAMnC,KAAK0Q,WAAWvO,EAAUoN,EAAOY,QAASZ,EAAO5H,QAAQnI,K,cAA/D,SACA4O,EAAK4F,QAAQzE,GACTA,EAAOzP,OAAS,EAAAyS,WAAWhF,OAC7B8F,EAAS9F,OAAOuE,OAAOvC,GAEvB8D,EAAS7F,KAAKsE,OAAOvC,GAEvBvP,KAAKsM,iB,YAGP,YAAAkC,qBAAA,SACEyC,EACAuD,EACApI,EACAqI,GAEA,UAAOhU,IAAI,yCAEX,IAAMyQ,EAAkBsD,EAAelH,OAAOe,aACxC8C,EAAiBqD,EAAe/G,OAAOY,aACvC+C,EAAcoD,EAAehH,KAAKa,aAElCqG,EAAc,IAAI,UAwExB,OAtEAzD,EACG5C,aAGAtJ,SAAQ,SAAA4P,GAEP,IAAMC,EAAgB,EAAH,KAAOD,GAAgB,CAAET,MAAOS,EAAiBT,MAAMxP,UAI1E,IAFgByM,EACbnO,QAAO,SAAA6R,GAAW,OAAAA,EAAQlN,QAAQpG,SAASqT,EAAcjN,QAAQ7H,KAAM+U,EAAQlN,QAAQnI,GAArE,IACTgF,OAAZ,CAKA,IAAMsQ,EAAiB1D,EACpBpO,QAAO,SAAAkQ,GACN,OAAC1R,OAAOoT,EAAcjN,QAAQnI,MAAQgC,OAAO0R,EAAKvL,QAAQlI,WACtDmV,EAAcV,MAAMtQ,MAAK,SAAAK,GAAQ,OAAAzC,OAAOyC,EAAKzE,MAAQgC,OAAO0R,EAAKvL,QAAQnI,KAAOyE,EAAKnE,OAASoT,EAAKvL,QAAQ7H,IAA1E,GADrC,IAKEiV,EAAqB5D,EACxBnO,QAAO,SAAA6R,GAAW,OAAAD,EAAcV,MAAMtQ,MAAK,SAAAK,GAAQ,OAAAzC,OAAOyC,EAAKzE,MAAQgC,OAAOqT,EAAQlN,QAAQnI,KAAOyE,EAAKnE,OAAS+U,EAAQlN,QAAQ7H,IAAhF,GAAjC,IAGrB8U,EAAcV,MAAQU,EAAcV,MAAMlR,QAAO,SAAAiB,GAC/C,IAAIsL,EACJ,OAEEA,EAASuF,EAAelR,MAAK,SAAAsP,GAC3B,OAAA1R,OAAOyC,EAAKzE,MAAQgC,OAAO0R,EAAKvL,QAAQnI,KAAO0T,EAAKvL,QAAQ7H,OAASmE,EAAKnE,IAA1E,MACF,UAAOW,IAAI,oDAAqD,CAACyS,KAAM3D,EAAQyF,QAASJ,KACjF,KAKPrF,EAASwF,EAAmBnR,MAAK,SAAAiR,GAC/B,OAAArT,OAAOyC,EAAKzE,MAAQgC,OAAOqT,EAAQlN,QAAQnI,KAAOqV,EAAQlN,QAAQ7H,OAASmE,EAAKnE,IAAhF,OAEF,UAAOW,IAAI,sDAAuD,CAACwD,KAAI,EAAE+Q,QAASJ,EAAeC,QAAStF,KACnG,EAGX,IAG4B2B,EACzBlO,QAAO,SAAA2P,GAAY,OAAAnR,OAAOoT,EAAcjN,QAAQnI,MAAQgC,OAAOmR,EAAShL,QAAQlI,SAA7D,IAEnBsF,SAAQ,SAAA7B,GACP,UAAOzC,IAAI,uDAAwD,CAACkS,SAAUzP,EAAG8R,QAASJ,IAC1FA,EAAcV,MAAMnB,OAAO7P,EAAEL,MAAO,EAAG,CAAE/C,KAAMoD,EAAEyE,QAAQ7H,KAAMN,GAAI0D,EAAEyE,QAAQnI,IAC/E,IAGY4R,EACXpO,QAAO,SAAAkQ,GACN,OAAA1R,OAAOoT,EAAcjN,QAAQnI,MAAQgC,OAAO0R,EAAKvL,QAAQlI,YAClDmV,EAAcV,MAAMtQ,MAAK,SAAAK,GAAQ,OAAAzC,OAAOyC,EAAKzE,MAAQgC,OAAO0R,EAAKvL,QAAQnI,KAAOyE,EAAKnE,OAASoT,EAAKvL,QAAQ7H,IAA1E,GADxC,IAGEiF,SAAQ,SAAA7B,GACZ,UAAOzC,IAAI,qDAAsD,CAACyS,KAAMhQ,EAAG8R,QAASJ,IACpFA,EAAcV,MAAMnB,OAAO7P,EAAEL,MAAO,EAAG,CAAE/C,KAAMoD,EAAEyE,QAAQ7H,KAAMN,GAAI0D,EAAEyE,QAAQnI,IAC/E,IAEAkV,EAAY5C,OAAO8C,E,CACrB,IAEKF,EAAYjR,IAAIgR,EAAiBrI,EAC1C,EAEM,YAAAuC,mBAAN,SAAyBxM,EAA6C8S,G,qGAIpE,OAHA,UAAOxU,IAAI,yBACX,UAAOA,IAAI,CAAEwU,YAAW,IAExB,GAAMlR,EAASC,KAAKiR,EAAY5G,cAAc,SAAMkB,GAAM,qC,4DAIxD,GAHA,UAAO9O,IAAI,2BAA4B,UAAG8O,EAAOzP,KAAI,sBAAcyP,EAAO5H,QAAQnI,GAAE,YAAI+P,EAAO5H,QAAQhI,MAAK,YAAI,QAAS4P,EAAO5H,QAAU,WAAI4H,EAAO5H,QAAQjI,IAAG,KAAM,GAAE,sBAAc6P,EAAO5H,QAAQlI,WAC/LwE,EAAOsL,EAAO5H,QAEhB3H,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAGZ,GAAIyC,EAAO2E,MAAM1P,QAAU,EACzB,UAGI0Q,EAAQ,CAAC,E,iBAEb,O,sBAAA,GAAM/S,EAASgT,YAAYlR,EAAKzE,GAAI+P,EAAO2E,MAIxClR,QAAO,SAAAiB,GACN,OAAIiR,EAAMjR,EAAKnE,KAAO,GAAKmE,EAAKzE,MAGhC0V,EAAMjR,EAAKnE,KAAO,GAAKmE,EAAKzE,KAAM,EAC3ByE,EAAKzE,GACd,M,cAVF,S,+BAaA,UAAOiB,IAAI,8BAAgC,EAAEkF,QAAU,gBACvD,UAAOlF,IAAI,G,oBAEbwU,EAAYjB,QAAQzE,GACpBvP,KAAKsM,iB,aACJzB,I,cAhCH,S,YAmCI,YAAA6F,WAAN,SAAiBvO,EAAmC8B,EAA2BgO,G,kGAC7E,SAAM/N,QAAQC,W,cAAd,SAEIhC,IAAanC,KAAKgL,QACpBiE,EAAUhL,EAAKzE,GACf0P,EAAW+C,IAEXhD,EAAUgD,EACV/C,EAAWjL,EAAKzE,IAEA,WAAdyE,EAAKnE,KAAL,MACF,GAAME,KAAK8K,SAASkE,UAAU,CAAEC,QAAO,EAAEC,SAAQ,K,cAAjD,S,aAEA,SAAMlP,KAAK8K,SAASsK,YAAY,CAAEnG,QAAO,EAAEC,SAAQ,K,OAAnD,S,mCAIE,YAAAqF,cAAN,SAAoBpS,EAAmC8B,G,yGAEjD9B,IAAanC,KAAKgL,OACpBkE,EAAWjL,EAAKzE,GAEhByP,EAAUhL,EAAKzE,GAEC,WAAdyE,EAAKnE,KAAL,MACF,GAAME,KAAK8K,SAAS1F,aAAa,CAAE6J,QAAO,EAAEC,SAAQ,K,cAApD,S,aAEA,SAAMlP,KAAK8K,SAAStI,eAAe,CAAEyM,QAAO,EAAEC,SAAQ,K,OAAtD,S,mCAIE,YAAAC,aAAN,SACEsB,EACArD,EACArN,G,YAAA,IAAAA,IAAAA,GAAA,G,wGAEA,GAAIC,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAEZ,OAAM2D,aAAsB,EAAAjN,QACtB,uBAAwBxD,KAAKgL,QAE/BjL,GACFyQ,EAAYxQ,KAAKkL,cACjBmK,EAAYrV,KAAKkM,gBAEX+C,EAAU7B,EAAiBkI,cAAchS,OAAOmN,EAAWjR,IACjEgR,EAAYxQ,KAAKkL,cAAc7H,WAAW4L,GAC1CoG,EAAYrV,KAAKkM,cAAc7I,WAAW4L,KAG1C,EAAAuB,GACE,GAAMxQ,KAAKuV,iBAAiB/E,EAAW6E,EAAW5E,IADpD,OAZmC,I,OAanC,GAAE,S,iBAFJ,OAAI,EAIF,KAEF,UAAOhQ,IAAI,eAAgBgQ,GAEV,GAAMzQ,KAAKgL,OAAOwK,mBAAmB/E,EAAWjR,IAAKgR,K,OACtE,OADM7N,EAAW,WAIjB8N,EAAW9N,SAAWA,EACtB8N,EAAW7N,QAAS,EAGpB,GAAMmB,EAASC,KACbyM,EAAW9N,UACX,SAAAY,GAAS,SAAK4L,aAAa5L,EAAO6J,EAAzB,GACT,MATA,I,cAMF,S,YAOI,YAAAmI,iBAAN,SAAuB/E,EAA6C6E,EAA6C5E,G,yHACzGrD,EAAmBpN,KAAK8K,SAASuC,cACrBmD,EACd,GAAMA,EAAU1P,KAAKd,KAAKyE,gBADZ,M,cACd,W,aACA,O,wBAFEgR,EAAY,EAGAJ,EACd,GAAMA,EAAUvU,KAAKd,KAAKyE,gBADZ,M,cACd,W,aACA,O,wBAFEiR,EAAY,EAGCjF,EACf,GAAMA,EAAW3P,KAAKd,KAAKyE,gBADZ,M,cACf,W,aACA,O,iBAUJ,OAZMkR,EAAa,EAGbC,GAAcP,EACdQ,EACHJ,IAAcC,GACdL,GAAa7T,OAAOgP,EAAU/Q,YAAc+B,OAAO6T,EAAU5V,UAC1DqW,EACHJ,IAAcC,GACdN,GACC7T,OAAO6T,EAAU5V,YACjB+B,OAAO4L,EAAiBkI,cAAchS,OAAOmN,EAAWhR,WACrD,CAAP,EAAOoW,GAAkBC,GAAmBF,G,QAG9C,YAAAG,uBAAA,SAAuBzQ,EAA6B0Q,GAApD,WACE1Q,EAAK3C,SAAW2C,EAAK3C,SAASK,QAAO,SAAAO,GACnC,OAAIA,aAAiB,EAAA3C,SACZ2C,EAAM/D,MAAMwW,EAAQC,cAActS,SAErCJ,EAAM/D,MAAMwW,EAAQC,cAAc3S,SACpC,EAAKyS,uBAAuBxS,EAAOyS,IAC5B,EAKb,GACF,EAEO,EAAAvD,uBAAP,SACErF,EACA8I,EACA/F,GACA,IAAMgG,EAAgBD,EAAe7H,aAAazK,MAAK,SAAA2L,GAAU,iBAAS0D,MAAM7F,EAAkBmC,EAAO5H,QAASwI,EAAQtQ,YAAcsQ,EAAQ1Q,QAA/E,IAC5D0W,IAGLA,EAAcjC,MAAQiC,EAAcjC,MAAMlR,QAAO,SAAAiB,GAAQ,QAAEA,EAAKnE,OAASqQ,EAAQrQ,MAAQ,UAASmT,MAAM7F,EAAkB+C,EAASgG,EAAcxO,QAAQ9H,YAAcoE,EAAKzE,GAAnH,IAC3D,EAEA,YAAA4W,OAAA,WACOpW,KAAKwL,qBACRxL,KAAKwL,mBAAqB,CACxBN,cAAelL,KAAKkL,eAAiBlL,KAAKkL,cAAc/J,OAAM,GAC9D+K,cAAelM,KAAKkM,eAAiBlM,KAAKkM,cAAc/K,OAAM,GAC9DgK,eAAgBnL,KAAKmL,gBAAkBnL,KAAKmL,eAAehK,OAAM,KAGrE,IAAMkV,EAAmBrW,KAAK8L,sBAC9B,OAAO,EAAP,GACEwK,SAAU,WACPtW,KAAKwL,oBACJ1I,OAAOyT,YAAYzT,OAAO0T,QAAQxW,MACnCgD,QAAO,SAAC,G,IAACqE,EAAG,KAAM,OAAAgP,EAAiBI,SAASpP,EAA1B,KAGzB,EAEa,EAAAqP,SAAb,SAAsB5L,EACpBC,EACAC,EACAC,EACA0L,G,kHAEQA,EAAKL,U,IACN,sB,IAGA,oB,IAKA,6B,mBANH,OADAA,EAAW,IAAI9D,EAAY1H,EAAUC,EAAWC,EAAQC,GACxD,M,OAG0B,uDAAa,MAAS,K,OAEhD,OAFM2L,EAAoB,SAAyBC,QACnDP,EAAW,IAAIM,EAAiB9L,EAAUC,EAAWC,EAAQC,GAC7D,M,OAGmC,uDAAa,OAAkB,K,OAElE,OAFM6L,EAA6B,SAAkCD,QACrEP,EAAW,IAAIQ,EAA0BhM,EAAUC,EAAWC,EAAQC,GACtE,M,OAEA,MAAM,IAAIhL,MAAM,qBAAuB0W,EAAKL,U,OA8BhD,OA5BAA,EAAS9J,YAAYmK,GACjBA,EAAKxL,iBACPmL,EAASnL,eAAiB,EAAA3H,OAAOf,QAAQkU,EAAKxL,iBAE5CwL,EAAKzL,gBACPoL,EAASpL,cAAgB,EAAA1H,OAAOf,QAAQkU,EAAKzL,gBAE3CyL,EAAKzK,gBACPoK,EAASpK,cAAgB,EAAA1I,OAAOf,QAAQkU,EAAKzK,gBAE/CoK,EAASxK,sBAAsB/G,SAAQ,SAACgS,GAClCA,KAAUJ,IACRI,EAAOC,cAAcP,SAAS,eAAiBM,EAAOC,cAAcP,SAAS,QAC/E,EAAKM,GAAU,CACbzJ,OAAQ,UAAKoJ,SAASC,EAAKI,GAAQzJ,QACnCC,OAAQ,UAAKmJ,SAASC,EAAKI,GAAQxJ,QACnCC,KAAM,UAAKkJ,SAASC,EAAKI,GAAQvJ,MACjCC,OAAQ,UAAKiJ,SAASC,EAAKI,GAAQtJ,QACnCC,QAAS,UAAKgJ,SAASC,EAAKI,GAAQrJ,UAE7BqJ,EAAOC,cAAcP,SAAS,YACvC,EAAKM,GAAU,UAAKL,SAASC,EAAKI,IAElC,EAAKA,GAAUJ,EAAKI,GAG1B,IAEO,CAAP,EAAOT,G,QAEX,EAv3CA,G,wnEC/BA,eAOA,aAkBE,WAAYW,GACVjX,KAAKiX,OAASA,CAChB,CAkIF,OAjJe,EAAAC,aAAb,W,uGACOlX,KAAKmX,UAAN,MAC8B,QAA5B,EAAAC,UAAUC,cAAV,OAEFrX,KAAKmX,UAAY,IAAIG,E,cAGC,OAAtB,EAAAtX,KAAsB,iDAAa,OAA2B,K,OAA9D,EAAKmX,UAAY,IAAK,SAA2CN,S,iBAGrE,MAAO,CAAP,EAAO7W,KAAKmX,W,QAOR,YAAAI,UAAN,W,sGACE,OAAIvX,KAAKiX,OACA,CAAP,EAAO/S,QAAQC,QAAQnE,KAAKiX,UAEzBO,UAAUC,UAAUhB,SAAS,aAAqC,QAAvB,EAAAe,UAAUE,qBAAa,eAAEC,YAChE,CAAP,EAAOH,UAAUE,cAAcE,MAAMC,MAAK,SAACC,GAAiB,OAC1DC,YAAa,W,UAAC,kDAAY,SAAAD,EAAaE,QAAOD,YAAW,QAAIE,EAAnC,EAC1BC,iBAAkB,SAACxW,GACjB,IAAMyW,EAAW,SAACC,GAAU,OAAA1W,EAAG0W,EAAMC,KAAT,EAE5B,OADAb,UAAUE,cAAcQ,iBAAiB,UAAWC,GAC7C,WAAM,OAAAX,UAAUE,cAAcY,oBAAoB,UAAWH,EAAvD,CACf,EAN0D,KAS9B,QAA5B,EAAAf,UAAUC,cAAV,MACe,iDAAa,MAAoB,K,OAClD,OADM,EAAW,SAAoCR,QAC9C,CAAP,EAAO,CACLkB,YAAa,SAACM,GACZ,IACE,EAAQE,QAAQC,YAAYH,E,CAC5B,MAAO7X,GACPqJ,QAAQC,KAAKtJ,E,CAEjB,EACA0X,iBAAkB,SAACxW,GACjB,IACE,EAAQ6W,QAAQE,UAAUC,YAAYhX,E,CACtC,MAAOlB,GACPqJ,QAAQC,KAAKtJ,E,CAEf,OAAO,WACL,IACE,EAAQ+X,QAAQE,UAAUE,eAAejX,E,CACzC,MAAOlB,GACPqJ,QAAQC,KAAKtJ,E,CAEjB,CACF,I,yBAKA,YAAAoY,WAAN,SAAiBC,EAAWC,G,kGAEX,OADfjP,QAAQpJ,IAAI,wCACG,GAAMT,KAAKuX,a,cAApBN,EAAS,SACTtR,EAAU,CAAC7F,KAAM,aAAciZ,OAAQ,CAACF,EAAWC,IACzD7B,EAAOc,YAAYpS,GACnBkE,QAAQpJ,IAAI,sCAAuCkF,G,YAGrD,YAAAqT,eAAA,SAAeb,GACb,IAMYQ,EANNM,EAAgB,SAACZ,GAER,kBADEA,EAAI,MAEjBF,GAEJ,EAMA,OAJAnY,KAAKuX,YAAYM,MAAK,SAAAqB,GAEpBP,EADSO,EACehB,iBAAiBe,EAC3C,IACO,WACLN,GAAkBA,GACpB,CACF,EAEM,YAAAQ,aAAN,SAAmBN,EAAWO,G,kGAEb,OADfvP,QAAQpJ,IAAI,wCACG,GAAMT,KAAKuX,a,cAApBN,EAAS,SACTtR,EAAU,CAAC7F,KAAM,eAAgBiZ,OAAQ,CAACF,EAAWO,IAC3DnC,EAAOc,YAAYpS,GACnBkE,QAAQpJ,IAAI,sCAAuCkF,G,YAG/C,YAAA0T,YAAN,W,kGAEiB,OADfxP,QAAQpJ,IAAI,wCACG,GAAMT,KAAKuX,a,cAApBN,EAAS,SACTtR,EAAU,CAAC7F,KAAM,cAAeiZ,OAAQ,IAC9C9B,EAAOc,YAAYpS,GACnBkE,QAAQpJ,IAAI,sCAAuCkF,G,YAG/C,YAAA2T,WAAN,SAAiBC,G,kGACA,SAAMvZ,KAAKuX,a,cAApBN,EAAS,SACTtR,EAAU,CAAC7F,KAAM,aAAciZ,OAAQ,CAACQ,IAC9CtC,EAAOc,YAAYpS,GACnBkE,QAAQpJ,IAAI,sCAAuCkF,G,YAG/C,YAAA6T,YAAN,SAAkBX,EAAWvC,EAAUmD,G,YAAA,IAAAA,IAAAA,GAAA,G,2FAEtB,OADf5P,QAAQpJ,IAAI,wCACG,GAAMT,KAAKuX,a,cAApBN,EAAS,SACTtR,EAAU,CAAC7F,KAAM,cAAeiZ,OAAQ,CAACF,EAAWvC,EAAUmD,IACpExC,EAAOc,YAAYpS,GACnBkE,QAAQpJ,IAAI,sCAAuCkF,G,YAG/C,YAAA+T,OAAN,SAAarS,G,kGAEI,OADfwC,QAAQpJ,IAAI,wCACG,GAAMT,KAAKuX,a,cAApBN,EAAS,SACTtR,EAAU,CAAC7F,KAAM,SAAUiZ,OAAQ,CAAC1R,IAC1C4P,EAAOc,YAAYpS,GACnBkE,QAAQpJ,IAAI,sCAAuCkF,G,YAG/C,YAAAgU,YAAN,W,gGAEiB,OADf9P,QAAQpJ,IAAI,wCACG,GAAMT,KAAKuX,a,OAE1B,OAFMN,EAAS,SAER,CAAP,EAAO,IAAI/S,SAAQ,SAACC,GAClB,IAOMmU,EAAsBrB,EAAOiB,kBAPb,SAACG,GACH,wBAAdA,EAAKvY,OACPqE,EAAQkU,EAAKU,OAAO,IACpBlP,QAAQpJ,IAAI,4BAA6B4X,GACzCC,IAEJ,IAEM3S,EAAU,CAAE7F,KAAM,cAAeiZ,OAAQ,IAC/C9B,EAAOc,YAAYpS,GACnBkE,QAAQpJ,IAAI,sCAAuCkF,EACrD,K,QAGI,YAAAiU,OAAN,W,oFAGF,EAtJA,G,+ECNA,MAAMC,GAA0BC,EAwDX,oBAAXC,OAAyBA,OAASnO,KAtDtCnG,EAAO1D,MAAMiY,UAAUvU,KACzBgF,EAAiB3H,OAAOkX,UAAUvP,eAEpC,SAASoP,EAAcI,EAAQ/V,GAC7B+V,EAASA,GAAUH,EAAKG,OACxB/V,EAAUA,GAAW4V,EAAK5V,QAE1B,IAAIqU,EAAU0B,EAAO1B,QAMrB,SAAS2B,EAAmBxY,EAAIyY,GAC9B,OAAO,WACL,IAAIlC,EAAOmC,UAEX,OAAO,IAAIlW,GAAQ,SAASC,EAASkW,GAUnC5U,EAAKiF,KAAKuN,GATV,WACE,IAAIqC,EAAM/B,EAAQgC,UACdD,EACFD,EAAOC,GAEPnW,EAAQqW,MAAM,KAAMJ,UAExB,IAIA1Y,EAAG8Y,MAAML,EAASlC,EACpB,GACF,CACF,EAEA,SAASwC,EAAeC,EAAQC,GAC9B,IAAK,IAAItT,KAAOqT,EACd,GAAIjQ,EAAeC,KAAKgQ,EAAQrT,GAAM,CACpC,IAAIuT,EAAMF,EAAOrT,GACbvH,SAAc8a,EAEL,WAAT9a,GAAuB8a,aAAef,GAAwC,IAAtBxS,EAAIjH,QAAQ,MAItEua,EAAOtT,GADW,aAATvH,EACKoa,EAAmBU,EAAKF,GAExBE,GALdD,EAAOtT,GAAO,CAAC,EACfoT,EAAeG,EAAKD,EAAOtT,IAM/B,CAEJ,CAzCAoT,CAAeR,EAAQja,KA0CzB,GArDqB,IAAS8Z,EAE1BrU,EACFgF,EAuDJ,IAAItH,EACmB,oBAAZ0X,SAA6C,oBAAXZ,QAC3C9W,EAAI,IAAI0W,EAAcI,OAAQ/V,SAC9Bf,EAAE2X,OAASb,OAAOa,OAClB3X,EAAE4X,cAAgBd,OAAOc,cACzB5X,EAAEoM,OAAS0K,OAAO1K,OAClBpM,EAAEwH,KAAOsP,OAAOtP,MAEhBxH,EAAI0X,QAGN,S,26FCvEA,cACA,cACA,cACA,cACA,aACA,cACA,cAIA,2B,8CAyLA,QAzL8C,OACtC,YAAA9N,SAAN,W,+GA+B0B,OA7BlBiD,EAAwC,GACxCE,EAAe,IAAI,UACvBlQ,KAAKmL,eACLnL,KAAKkL,eACL,SAACuF,EAAYD,GACX,QAAIA,EAAU1Q,OAAS2Q,EAAW3Q,OAAQ2Q,EAAW/P,aAAa8P,KAChER,EAAYvK,KAAK,CAAC+K,EAAWC,IACtB,GAGX,GACAzQ,KAAKyE,eACL,GACA,GAEI6L,EAAgB,IAAI,UACxBtQ,KAAKkL,cACLlL,KAAKmL,gBACL,SAACqF,EAAWC,GACV,QAAIA,EAAW3Q,OAAS0Q,EAAU1Q,OAAQ2Q,EAAW/P,aAAa8P,KAChER,EAAYvK,KAAK,CAAC+K,EAAWC,IACtB,GAGX,GACAzQ,KAAKyE,eACL,GACA,GAEsB,GAAMyL,EAAaK,O,OAClB,OADnBnF,EAAkB,SACC,GAAMkF,EAAcC,O,OAC7C,OADMlF,EAAmB,SACzB,GAAMtH,EAASN,IAAIuM,GAAa,SAAC,G,IAACQ,EAAS,KAAEC,EAAU,KACrD,OAAO,EAAKC,WAAW,EAAK1F,OAAQwF,EAAWC,EAAWjR,GAC5D,GAAG,K,OAEH,OAJA,SAIO,CAAP,EAAO,CAAC4L,gBAAe,EAAEC,iBAAgB,I,QAGrC,YAAA4B,eAAN,SACE0D,EACAC,EACAxE,G,uHA2BA,OAzBMgB,EAAmBpN,KAAK8K,SAASuC,cAEjCwD,EAAkBD,EAAiBtD,OAAOe,aAC1C0C,EAAcH,EAAiBpD,KAAKa,aAEpC+C,EAAcT,EAAiBnD,KAAKa,aACpC2M,EAAgBrK,EAAiBpD,OAAOc,aAExCgD,EAAarR,KAAKmM,cAAcC,GAChCkF,EAAatR,KAAKmM,cAAcC,IAAmB,EAAAlN,aAAaC,MAAQ,EAAAD,aAAaE,OAAS,EAAAF,aAAaC,OAE3GoS,EAA2BZ,EAAiBrD,OAAOe,aACtDmD,OAAOb,EAAiBnD,KAAKa,cAC7BmD,OAAOZ,EAAiBtD,OAAOe,cAC/BmD,OAAOZ,EAAiBpD,KAAKa,cAG1BqD,EAAiC,CACrCpE,OAAQ,IAAI,UACZC,OAAQ,IAAI,UACZC,KAAM,IAAI,UACVC,OAAQ,IAAI,UACZC,QAAS,IAAI,WAGf,GAAM3J,EAASC,KAAK2M,EAAiBrD,OAAOe,cAAc,SAAMkB,GAAM,qC,wEAC9DwC,EAAqBlB,EAAgBjN,MAAK,SAAAV,GAC9C,OAAAA,EAAEyE,QAAQlI,WAAa,UAASuS,YAAY5E,EAAkBmC,EAAO5H,QAASzE,EAAEyE,QAAQ9H,WACxF0P,EAAO5H,QAAQjH,aAAawC,EAAEyE,QAD9B,MAIM,EAAc,GAgBpB,GAfmB,IAAI,UACrBoK,EAAmBpK,QACnB4H,EAAO5H,SACP,SAACwI,EAASC,GACR,QAAID,EAAQrQ,OAASsQ,EAAQtQ,OAAQqQ,EAAQzP,aAAa0P,KAExD,EAAY3K,KAAK,CAAC0K,EAASC,EAAQ5Q,KAC5B,GAGX,GACAQ,KAAKyE,eACL,GACA,GAEe8L,QAlBf,M,OAoBF,OAFA,SACA,EAAY9K,KAAK,CAACsM,EAAmBpK,QAAS4H,EAAO5H,QAAQnI,KAC7D,GAAMuE,EAASC,KAAK,GAAa,SAAM,G,IAACmM,EAAO,KAAE8B,EAAK,K,uFACpD,SAAMjS,KAAK0Q,WAAWnB,EAAO5H,QAAQ9H,WAAa,EAAAX,aAAaC,MAAQa,KAAK+K,UAAY/K,KAAKgL,OAAQmF,EAAS8B,I,cAA9G,S,aACA,I,OAEF,OAJA,SAIA,I,cAGFP,EAAWpE,OAAOwE,OAAOvC,G,aAxGJ,K,OA2GvB,OAlCA,SAkCA,GAAMxL,EAASC,KAAK2M,EAAiBnD,KAAKa,cAAc,SAAMkB,GAAM,qC,iCAClE,OAAInD,IAAmB,EAAAlN,aAAaC,OACXiS,EAAYxN,MAAK,SAAAV,GACtC,OAACqM,EAAO5H,QAAQ7H,OAASoD,EAAEyE,QAAQ7H,MAAQ,UAASuQ,SAASjD,EAAkBmC,EAAO5H,QAASzE,EAAEyE,UACxE,aAAxB4H,EAAO5H,QAAQ7H,MAAuByP,EAAO5H,QAAQjH,aAAawC,EAAEyE,QADrE,IAKA,KAIEqL,EAA+BjC,EAAY/N,QAAO,SAAA6O,GACtD,OAAO,UAAKD,UAAUxE,EAAkBmE,EAAyBD,EAAY/B,EAAO5H,QAASkK,IAC3F,UAAKD,UAAUxE,EAAkBmE,EAAyBF,EAAYQ,EAAWlK,QAAS4H,EAC9F,KACiC/K,QAC3B4H,IAAmB,EAAAlN,aAAaE,SAClC4T,EAA6BjO,SAAQ,SAAA7B,GAEnC,IAAMyE,EAAUzE,EAAEiN,QAAQ9O,mBAAkB,EAAOkO,EAAO5H,QAAQ9H,UAC5DsQ,EAAUjN,EAAEyE,QAAQtG,mBAAkB,EAAOkO,EAAOY,QAAQtQ,UAClEsQ,EAAQ3Q,GAAK,UAASyT,MAAM7F,EAAkB+C,EAASZ,EAAO5H,QAAQ9H,UACtEsQ,EAAQ1Q,SAAW,UAASuS,YAAY5E,EAAkB+C,EAASZ,EAAO5H,QAAQ9H,UAGhF6R,EAAWlE,KAAKa,aAAazK,MAAK,SAAAsP,GAAQ,OAAA1R,OAAO0R,EAAKvL,QAAQnI,MAAQgC,OAAOmG,EAAQnI,GAA3C,KAC1C4R,EAAYxN,MAAK,SAAAsP,GAAQ,OAAA1R,OAAO0R,EAAKvL,QAAQnI,MAAQgC,OAAOmG,EAAQnI,GAA3C,KAO3BkS,EAAWlE,KAAKsE,OAAO,EAAD,KAAM5O,GAAC,CAAEyE,QAAO,EAAEwI,QAAO,IACjD,IACAuB,EAAWlE,KAAKsE,OAAOvC,IAIzB,MAGFmC,EAAWlE,KAAKsE,OAAOvC,G,aAtJF,K,OAyJvB,OA9CA,SA8CA,GAAMxL,EAASC,KAAK2M,EAAiBpD,OAAOc,cAAc,SAAMkB,GAAM,qC,2BAGpE,OAFyByL,EAAcpX,MAAK,SAAAV,GAC1C,OAAAqM,EAAO5H,QAAQ7H,OAASoD,EAAEyE,QAAQ7H,MAAQ,UAASuQ,SAASjD,EAAkBmC,EAAO5H,QAASzE,EAAEyE,QAAhG,KACsByE,IAAmB,EAAAlN,aAAaC,OAKxDuS,EAAWnE,OAAOuE,OAAOvC,GAHvB,G,SA9JmB,K,OAoKvB,OAXA,SAWO,CAAP,EAAOmC,G,QAGT,YAAAlD,qBAAA,SACEyC,EACAuD,EACApI,EACAqI,GAEA,OAAO,YAAMjG,qBAAoB,UAACyC,EAAgBuD,EAAgBpI,EAAgBqI,EACpF,EAEM,YAAAtF,aAAN,SAAmBhE,G,gGAEU,OAD3B,UAAO1K,IAAI,kDACX,EAAA0K,EAA2B,GAAMnL,KAAKgL,OAAO4D,kBAAiB,I,cAA9D,EAAejM,SAAY,SAA0CA,S,YAGvE,YAAAyT,OAAA,WACE,OAAO,EAAP,KACK,UAAmB4D,UAAU5D,OAAOoE,MAAMxa,OAAK,CAClDsW,SAAU,SAEd,EACF,EAzLA,CAA8C,W,wtDCP9C,UAAe,CACb2E,SAAU,CAAC,EACXC,SAAQ,SAACpb,EAAaqb,GACpBnb,KAAKib,SAASnb,GAAQqb,CACxB,EACMC,QAAO,SAAC/C,G,gGACR,SAAUA,EACI,GAAMrY,KAAKib,SAAS5C,EAAKvY,SADvC,M,OAEF,MAAO,CAAP,EAAO,IADS,SACT,CAAYuY,I,yBAGjBgD,iBAAgB,SAACvb,G,gGACL,SAAME,KAAKib,SAASnb,M,OACpC,OADMqb,EAAU,SACT,CAAP,SACKA,EAAQE,oBAAkB,CAC7B9B,SAAS,K,q7GClBf,kBACA,cACA,UACA,cACA,aACA,aAIA,WAGA,WACA,cACA,cACA,cAKA,UAAe2B,SAAS,cAAc,gF,uBAAY,uDAAa,OAAuB,K,OAArC,SAAC,SAAuCrE,S,UACzF,UAAeqE,SAAS,qBAAqB,gF,uBAAY,uDAAa,OAA+B,K,OAA7C,SAAC,SAA+CrE,S,UACxG,UAAeqE,SAAS,uBAAuB,gF,uBAAY,uDAAa,OAA+B,K,OAA7C,SAAC,SAA+CrE,S,UAC1G,UAAeqE,SAAS,UAAU,gF,uBAAY,uDAAa,OAAmB,K,OAAjC,SAAC,SAAmCrE,S,UACjF,UAAeqE,SAAS,OAAO,gF,uBAAY,uDAAa,OAAgB,K,OAA9B,SAAC,SAAgCrE,S,UAC3E,UAAeqE,SAAS,gBAAgB,gF,uBAAY,uDAAa,OAAwB,K,OAAtC,SAAC,SAAwCrE,S,UAC5F,UAAeqE,SAAS,QAAQ,gF,uBAAY,uDAAa,OAAiB,K,OAA/B,SAAC,SAAiCrE,S,UAG7E,IAEMyE,EAAW,IAAI,UAErB,aAmDE,WAAY9b,EAAW+b,EAAgCC,EAAyBC,GAC9Ezb,KAAKgL,OAASwQ,EACdxb,KAAKR,GAAKA,EACVQ,KAAK0b,QAAUH,EACfvb,KAAK+K,UAAY0Q,EACjBzb,KAAK2b,YA5DY,IA6DnB,CAwSF,OA7Ve,EAAAC,gBAAb,W,kGACE,OAAI5b,KAAKmX,UACA,CAAP,EAAOnX,KAAKmX,WAEkB,QAA5B,EAAAC,UAAUC,cAAV,OACF,EAAArX,KAAkB,iDAAa,OAA0B,M,cAAzD,EAAKmX,UAAa,SAA0CN,Q,aAE1C,OAAlB,EAAA7W,KAAkB,iDAAa,OAAwB,K,OAAvD,EAAKmX,UAAa,SAAwCN,Q,iBAE5D,MAAO,CAAP,EAAO7W,KAAKmX,W,QAGD,EAAA0E,IAAb,SAAiBrc,G,uGACXQ,KAAK8b,MAAMtc,GACb,GAAMQ,KAAK8b,MAAMtc,GAAIuc,qBADnB,M,OAEF,OADA,SACO,CAAP,EAAO/b,KAAK8b,MAAMtc,I,OAEG,SAAMQ,KAAK4b,mB,OAAlB,SAAO,SAA8BC,IAAIrc,I,OAEzD,OAFMwc,EAAU,SAChBhc,KAAK8b,MAAMtc,GAAMwc,EACV,CAAP,EAAOA,G,QAGI,EAAAC,OAAb,SAAoB5D,G,0FACV,SAAMrY,KAAK4b,mB,OAAnB,MAAO,CAAP,EAAQ,SAA8BK,OAAO5D,I,QAGlC,EAAA6D,OAAb,SAAoBC,G,wGACQ,EAAAA,E,wBAAA,YAAfC,EAAW,KACpB,GAAMpc,KAAKic,OAAO,EAAD,KAAKG,GAAW,CAAE7C,SAAS,OADZ,M,OAChC,S,wBADwB,I,+BAKf,EAAA8C,OAAb,SAAoBC,G,0FACV,SAAMpY,QAAQwK,IACpB4N,EAAW7Y,KAAI,SAAAjE,GAAM,OAAA+c,EAAQV,IAAIrc,EAAZ,M,OADvB,MAAO,CAAP,EAAQ,SAELiE,KAAI,SAAAP,GAAK,OAAAA,EAAEuM,SAAF,K,QAoBR,YAAA+M,OAAN,W,0FACE,SAAMxc,KAAK0b,QAAQe,qB,cAAnB,S,YAGF,YAAAC,SAAA,WACE,OAAO1c,KAAKgL,OAAO0R,UACrB,EAEA,YAAAjN,QAAA,WACE,IAAM4I,EAAO,EAAH,CACRsE,UAAW,KACXrG,SAAU,UACVsG,aAAc,GACdC,YAAY,EACZrN,UAAU,EACVsN,cAAc,EACdC,MAAO,GACPC,WAAY,EACZC,mBAAmB,GAChBjd,KAAKgL,OAAOyE,WAKjB,MAHI,SAAU4I,GAAsB,sBAAdA,EAAKvY,OACzBuY,EAAKvY,KAAO,uBAEPuY,CACT,EAEM,YAAA6E,YAAN,W,mEACE,MAAO,CAAP,EAAOld,KAAK+K,U,QAGR,YAAAoS,UAAN,W,mEACE,MAAO,CAAP,EAAOnd,KAAKgL,O,QAGR,YAAAoS,QAAN,SAAc/E,G,qGACZ,SAAMiD,EAAS+B,QAAQrd,KAAKR,IAAI,gD,wDAE9B,OADM8d,EAAI,EAAH,KAAOtd,KAAKgL,OAAOyE,WAAc4I,GACxC,GAAMrY,KAAK0b,QAAQ6B,eAAeD,EAAG,O,cAArC,SACAtd,KAAKgL,OAAOoS,QAAQE,G,6BAHtB,S,YAOI,YAAAvB,kBAAN,W,mEACE,MAAM,IAAI9b,MAAM,kB,QAGZ,YAAAud,eAAN,SAAqBvO,G,sGACb,SAAMjP,KAAKyd,iB,OAAjB,OAAM,SACW,GAAMzd,KAAK0b,QAAQgC,eADM,CAAP,GAAO,G,OAS1C,OARM5S,EAAW,SACX6S,EAAW7S,EAASuC,cACpBuQ,EAAgB9a,OAAO+B,KAAK8Y,EAAS1H,cAActS,UAAUzD,MACjE,SAACV,GAAO,OAAAgC,OAAOyN,KAAazN,OAAOhC,EAA3B,IAEJqe,EAAc/a,OAAO+B,KAAK8Y,EAAS1H,cAAc3S,QAAQpD,MAC7D,SAACV,GAAO,OAAAgC,OAAOyN,KAAazN,OAAOhC,EAA3B,IAEH,CAAP,EAAOoe,GAAiBC,G,QAGpB,YAAAC,KAAN,W,mEACE,MAAM,IAAI7d,MAAM,kB,QAGZ,YAAAwd,cAAN,W,mEACE,MAAM,IAAIxd,MAAM,kB,QAGZ,YAAA0M,KAAN,SAAW2J,EAA4BmD,G,YAAA,IAAAA,IAAAA,GAAA,G,gIAGnC,O,wBAAIzZ,KAAKyP,UAAUsO,SAAW/d,KAAK+d,QAAS,IAEtB,GAAM/d,KAAKkd,e,OAC3B,OADAc,EAAgB,SAChB,GAAMhe,KAAKgL,OAAOiT,e,cAApB,GAAE,UAAF,MAAwC,GAAMD,EAAcC,e,OAAtB,GAAE,S,iBAA5C,OAAI,EAA4E,KAEhF,UAAOxd,IAAI,qCAAuCT,KAAK0c,YACvDwB,EAAOC,QAAQ,CAAE3e,GAAIQ,KAAKR,KAC1BQ,KAAK+d,SAAU,EACf,GAAM/d,KAAKod,QAAQ,CAAEW,QAAS,IAAMK,WAAW,EAAOC,MAAO,S,OAEvD,OAFN,SAEM,GAAMre,KAAKyd,iB,cAAX,SAAF,MACF,GAAMzd,KAAK8d,Q,OAAX,S,qBAGE9d,KAAKgL,OAAOsT,YAAZ,aACIC,EAAqD,WAAzCjI,GAAYtW,KAAKyP,UAAU6G,U,iBAGlC,O,wBAAA,GAAMtW,KAAKgL,OAAOsT,YAAYC,EAAU9E,I,eAAjD,EAAS,S,sBAGM,M,YAAT+E,KAAF,OAEExe,KAAKyP,UAAUgP,SAAWC,KAAKC,MAAQ3e,KAAK2b,aAAelC,EAGpD,GAAMzZ,KAAKgL,OAAOsT,aAAY,GAAO,IAH5C,O,eAGF,EAAS,S,eAET,SAAMte,KAAKod,QAAQ,CACjBiB,MAAO,KACPN,SAAS,EACTK,UAAW9H,GAAYtW,KAAKyP,UAAU6G,Y,QAMxC,OATA,SAKAtW,KAAK+d,SAAU,EACf,UAAOtd,IACL,yCAEF,GAAM,UAAOme,W,QACb,OADA,SACA,I,6BAGF,MAAM,E,oCAGK,IAAX,SACF,GAAM5e,KAAK8d,Q,QAAX,S,mBAKO,SAAM9d,KAAK0b,QAAQgC,e,QACZ,OADlB5S,EAAW,SACO,GAAM9K,KAAK0b,QAAQmD,Y,QAElB,OAFb5S,EAAY,SAEC,GAAMjM,KAAK0b,QAAQoD,0B,WAElC,OAFAC,EAAe,UAEf,a,mBAEmB,O,yBAAnB,EAAA/e,KAAmB,GAAM,UAAmB0W,SAC1C5L,EACAkT,EACAhe,KAAKgL,QACL,SAAMgU,EAAUC,GAAU,qC,kDACxB,SAAMjf,KAAKkf,iBAAiBF,EAAUC,I,cAAtC,S,aAEFF,I,eAPF,EAAKI,YAAc,S,+BAUnBJ,EAAe,KACf,UAAOte,IAAI,oE,oBAIX,MAAOse,QAA8E,IAAbzI,GAA4ByI,EAAazI,WAAaA,GAAaoI,KAAKC,MAAQI,EAAaK,UAAY,MAAjL,aAMF,OADIC,OAAa,EAAsF3S,OAAS,EACxG4J,GAAYtW,KAAKyP,UAAU6G,UACjC,IAAK,QACH,UAAO7V,IAAI,qDACX4e,EAAgB,UAChB3S,EAAY,EAAAxN,aAAaC,MACzB,MACF,IAAK,YACH,UAAOsB,IAAI,yDACX4e,EAAgB,UAChB3S,EAAY,EAAAxN,aAAaE,OACzB,MACF,QACO6M,EAAUtJ,SAAS6B,QAItB,UAAO/D,IAAI,4BACX4e,EAAgB,YAJhB,UAAO5e,IAAI,uDACX4e,EAAgB,WAoBtB,OAZArf,KAAKmf,YAAc,IAAIE,EACrBvU,EACAkT,EACAhe,KAAKgL,QACL,SAAMgU,EAAU1T,GAAY,qC,kDAC1B,SAAMtL,KAAKkf,iBAAiBF,EAAU1T,I,cAAtC,S,cAGJtL,KAAKmf,YAAYnT,aAAaC,GAC1BS,GACF1M,KAAKmf,YAAY1S,aAAaC,GAEhC,GAAM1M,KAAKmf,YAAYxS,Q,eAAvB,S,eAKA,OADA,UAAOlM,IAAI,qEACX,GAAMT,KAAKmf,YAAYxS,Q,QAAvB,S,mBAGF,SAAM3M,KAAKod,QAAQ,CAAEgB,WAAW,EAAOL,QAAS,K,QAGjC,OAHf,SAGe,GAAMC,EAAcpP,oB,QAEY,OAFzCkN,EAAS,SAAwC3a,OAAM,GAC7DnB,KAAKmf,YAAYtQ,6BAA6BiN,GAC9C,KAAA9b,KAAKmf,aAAYpJ,uB,GAAuB+F,GAAO,GAAMhR,EAASuC,e,QAC9D,OADA,oBAA+C,YAC/C,GAAMrN,KAAK0b,QAAQ4D,SAASxD,I,eAA5B,SAEI9b,KAAKgL,OAAOuU,eACd,GAAMvf,KAAKgL,OAAOuU,kBADhB,O,QACF,S,0BAGEzU,EACF,GAAMA,EAAS8T,WADb,O,QACF,S,mBAKF,OAFA5e,KAAK+d,SAAU,EAEf,GAAM/d,KAAK0b,QAAQ8D,uBAAuB,O,QAC1C,OADA,SACA,GAAMxf,KAAKod,QAAQ,CACjBiB,MAAO,KACPrB,WAAY,EACZe,SAAS,EACTK,WAAW,EACXK,SAAUC,KAAKC,S,eALjB,SAQA,UAAOle,IACL,+CAAiDT,KAAK0c,Y,eAIxC,O,WADhB7S,QAAQpJ,IAAI,GACI,GAAM8b,EAAQkD,eAAe,I,QAe7C,OAfM9Z,EAAU,SAChBkE,QAAQwU,MAAM,sBAAuB1Y,GACrC,UAAOlF,IAAI,sBAAuBkF,GAClCuY,EAAOwB,WAAW,cAAe,EAAF,KAC1B1f,KAAKyP,WAAS,CACjBkQ,SAAU,uBACVC,SAAU,2BACV7Y,WAAY,8BAEV,EAAE8Y,KACJ3B,EAAO4B,iBAAiBna,GAExBuY,EAAO4B,iBAAiB,GAG1B,GAAM9f,KAAKod,QAAQ,CACjBiB,MAAO1Y,EACPqX,WAAYhd,KAAKyP,UAAUuN,WAAa,EACxCe,SAAS,EACTK,WAAW,K,eAJb,SAMI2B,EAAe,GAAG,SAAAvf,GAAK,OAAW,KAAXA,EAAEge,QAAiB,EAAAwB,QAAqB,KAAXxf,EAAEge,KAA/B,IACzB,GAAMxe,KAAK0b,QAAQ8D,uBAAuB,OADxC,O,QACF,S,0BAEFxf,KAAK+d,SAAU,EACX/d,KAAKgL,OAAOiV,WACd,GAAMjgB,KAAKgL,OAAOiV,cADhB,O,QACF,S,0BAKEF,EAAe,GAAG,SAAAvf,GAAK,OAAW,KAAXA,EAAEge,MAA0B,KAAXhe,EAAEge,QAAiB,EAAAwB,QAAqB,KAAXxf,EAAEge,KAAhD,IACzB,GAAMxe,KAAK8d,QADT,O,QACF,S,wCAGJ,SAAM,UAAOc,W,eAAb,S,YAGW,EAAAa,eAAb,SAA4BS,G,0FAClB,SAAMlgB,KAAK4b,mB,OAAnB,MAAO,CAAP,EAAQ,SAA8B6D,eAAeS,I,QAGjD,YAAAtH,WAAN,W,0FACE,OAAK5Y,KAAK+d,SACV/d,KAAKgL,OAAOqB,SACRrM,KAAKmf,YACP,GAAMnf,KAAKmf,YAAY9S,UADrB,OAFe,I,OAGjB,S,mCAIU,YAAA6S,iBAAd,SAA+BF,EAAkB1T,G,0FAC/C,OAAKtL,KAAK+d,QAGV,GAAM/d,KAAKod,QAAQ,CAAEW,QAASiB,KAF5B,I,OAGF,OADA,SACKhf,KAAKmf,aAGN7T,GAAkBtL,KAAKgL,kBAAkB,WAAqB,mBAAoBhL,KAAKgL,OAAvF,MACF,GAAMhL,KAAK0b,QAAQ8D,uBAAuBxf,KAAKmf,YAAY/I,WAH3D,I,OAIA,OADA,SACA,GAAMpW,KAAKmf,YAAYpT,sBAAsB6S,W,OAA7C,S,mCAIS,EAAAuB,eAAb,W,0FACU,SAAMngB,KAAK4b,mB,OAAnB,MAAO,CAAP,EAAQ,SAA8BuE,kB,QAG3B,EAAAC,6BAAb,SAA0CnR,EAAgB1J,EAAoB8a,G,0FACpE,SAAMrgB,KAAK4b,mB,OAAnB,MAAO,CAAP,EAAQ,SAA8BwE,6BAA6BnR,EAAS1J,EAAW8a,I,QA9VlF,EAAAvE,MAAQ,CAAC,EAgWlB,C,CAjWA,GAmWA,SAASiE,EAAevf,EAAGkB,GACzB,OAAOA,EAAGlB,IAAMA,EAAEqf,MAAQrf,EAAEqf,KAAKS,OAAM,SAAA9f,GAAK,OAAAuf,EAAevf,EAAGkB,EAAlB,GAC9C,C,UArWqB6a,C,ozwBCjCN,MAAM9U,EACnB,mBAAazG,CAAO2E,GAClB,MAAMC,EAAY,IAAIC,YAAY,SAASC,OAAOH,GAC5CO,QAAmBH,OAAOC,OAAOC,OAAO,UAAWL,GAEzD,OADgB5F,KAAKmG,eAAeD,EAEtC,CAEA,qBAAOC,CAAeE,GACpB,OAAOtE,MAAMuE,KAAK,IAAIF,WAAWC,IAC9B5C,KAAIN,IAAM,KAAOA,EAAEoD,SAAS,KAAK7B,OAAO,KACxCzC,KAAK,GACV,CAEA,qBAAOuE,CAAeC,GACpB,IACE,IAAIC,EAAQ,IAAIN,WAAWK,EAAIjC,OAAS,GAAImC,EAAI,EAChDA,EAAIF,EAAIjC,OACRmC,GAAK,EAELD,EAAMC,EAAI,GAAKC,SAASH,EAAII,OAAOF,EAAG,GAAI,IAE5C,OAAOD,CACT,CAEA,uBAAaI,CAAWO,GACtB,MAAMkZ,QAAkBxa,OAAOC,OAAOC,OACpC,UACA,IAAIJ,YAAY,SAASC,OAAOuB,IASlC,aAPsBtB,OAAOC,OAAOoB,UAClC,MACAmZ,EACA,CAAEhZ,KAAM,YACR,EACA,CAAC,UAAW,WAGhB,CAEA,uBAAaG,CAAWL,EAAKS,EAAIE,GAC/B,OAAO,IAAIG,aAAcC,aACjBrC,OAAOC,OAAOiC,QAClB,CAAEV,KAAM,UAAWO,GAAI1B,WAAWE,KAAKmB,EAAOK,WACxC9H,KAAK8G,WAAWO,GACtBrH,KAAKwG,eAAewB,IAG1B,CAEA,uBAAaK,CAAWhB,EAAKS,EAAInC,GAC/B,OAAO3F,KAAKmG,qBACJJ,OAAOC,OAAOwC,QAClB,CAAEjB,KAAM,UAAWO,GAAI1B,WAAWE,KAAKmB,EAAOK,WACxC9H,KAAK8G,WAAWO,IACtB,IAAIxB,aAAcC,OAAOH,IAG/B,CAEA,qBAAO2C,CAAeU,GACpB,IAAIC,EAAO,IAAIuX,UAAUxX,GAEzB,OADAjD,OAAOmD,gBAAgBD,GAChBA,CACT,EAIFxB,EAAOK,GAAK,CACV,GACA,GACA,EACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,GACA,IACA,G,kBCpFF,IAAIrE,EAAM,CACT,qBAAsB,CACrB,MACA,KAED,qBAAsB,CACrB,MACA,KAED,qBAAsB,CACrB,OAED,qBAAsB,CACrB,MACA,KAED,qBAAsB,CACrB,MACA,KAED,qBAAsB,CACrB,MACA,KAED,qBAAsB,CACrB,MACA,KAED,qBAAsB,CACrB,MACA,KAED,wBAAyB,CACxB,MACA,IAED,wBAAyB,CACxB,MACA,KAED,qBAAsB,CACrB,MACA,IAED,qBAAsB,CACrB,MACA,KAED,wBAAyB,CACxB,MACA,KAED,qBAAsB,CACrB,MACA,KAED,qBAAsB,CACrB,MACA,KAED,qBAAsB,CACrB,KACA,KAED,wBAAyB,CACxB,MACA,KAED,qBAAsB,CACrB,MACA,KAED,wBAAyB,CACxB,MACA,IAED,wBAAyB,CACxB,MACA,MAGF,SAASgd,EAAoBC,GAC5B,IAAIC,EAAoBC,EAAEnd,EAAKid,GAC9B,OAAOxc,QAAQC,UAAU0T,MAAK,KAC7B,IAAIrX,EAAI,IAAIP,MAAM,uBAAyBygB,EAAM,KAEjD,MADAlgB,EAAEge,KAAO,mBACHhe,CAAC,IAIT,IAAIqgB,EAAMpd,EAAIid,GAAMlhB,EAAKqhB,EAAI,GAC7B,OAAO3c,QAAQwK,IAAImS,EAAInc,MAAM,GAAGjB,IAAIkd,EAAoBngB,IAAIqX,MAAK,IACzD8I,EAAoBnhB,IAE7B,CACAihB,EAAoB5b,KAAO,IAAO/B,OAAO+B,KAAKpB,GAC9Cgd,EAAoBjhB,GAAK,MACzBshB,EAAOC,QAAUN,C,qhECjGjB,kBACA,cACA,cACA,cAEA,WASA,cACA,SAEA,2B,8CAmGA,QAnG2C,OAC5B,EAAA5E,IAAb,SAAiBrc,G,wGAEF,UADPkc,EAAU,IAAI,UAAqBlc,IACdwhB,eAAe,O,OAI1C,OAJM3I,EAAO,SAIb,IADM/S,EAAO,IAAI,UAAWoW,IACjBjS,Q,OAG2B,OAHtC,S,EAGWwX,EAAa,K,UAACzhB,EAAIkc,GAAS,GAAM,UAAeN,QAAQ/C,I,OAAnE,MAAO,CAAP,EAAO,YAAI4I,EAAa,UAAc,SAAoC3b,O,QAG/D,EAAA2W,OAAb,SAAoB5D,G,sGAEF,OADV7Y,EAAK,GAAKkf,KAAKC,MAAQra,KAAK4c,SAClB,GAAM,UAAe9F,QAAQ/C,I,OAG7C,OAHM8C,EAAU,SAGhB,IAFMO,EAAU,IAAI,UAAqBlc,IAE3B+d,eAAelF,EAAM,O,OAInC,OAJA,SAIA,IADM/S,EAAO,IAAI,UAAWoW,IACjBjS,Q,OAGX,OAHA,SAGO,CAAP,EAAO,IAAIwX,EAAczhB,EAAIkc,EAASP,EAAS7V,I,QAG3C,YAAAwY,KAAN,W,gGAEE,OADAjU,QAAQpJ,IAAI,wBAA0BT,KAAKR,IAC3C,GAAMQ,KAAK0b,QAAQyF,gB,OACnB,OADA,SACA,GAAMnhB,KAAK0b,QAAQ0F,a,OAEnB,OAFA,SAEA,IADMC,EAAa,IAAI,UAAWrhB,KAAK0b,UACtBjS,Q,cAAjB,SACAzJ,KAAK+K,UAAYsW,E,YAGb,YAAA5D,cAAN,W,mEACE,IACE,MAAO,CAAP,EAAO6D,QAAQ,UAAqBC,SAAS,oBAAavhB,KAAK0b,QAAQ7C,UAAS,gB,CAChF,MAAOrY,GAEP,OADAqJ,QAAQpJ,IAAI,uCAAwCD,GAC7C,CAAP,GAAO,E,kBAIL,YAAAub,kBAAN,W,oFAIa,EAAA0D,eAAb,SAA4BS,G,qGAC1B,OAAIA,aAAc,EAAAsB,6BAGdtB,aAAc,EAAAuB,sBAFT,CAAP,EAAO,EAAA9W,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAGjc,QAKrEic,aAAc,EAAAyB,UACT,CAAP,EAAO,EAAAhX,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAG0B,OAAQ1B,EAAG2B,UAEhF3B,aAAc,EAAA4B,mBACT,CAAP,EAAO,EAAAnX,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,MAAQ,KAAOxB,EAAG6B,UAE7E7B,aAAc,EAAA8B,oCACT,CAAP,EAAO,EAAArX,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAG5c,OAAQ4c,EAAGvc,YAEhFuc,aAAc,EAAA+B,cACT,CAAP,EAAO,EAAAtX,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAG0B,OAAQ1B,EAAGgC,YAEhFhC,aAAc,EAAAxQ,cACT,CAAP,EAAO,EAAA/E,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAGiC,WAErEjC,aAAc,EAAAkC,qBAGdlC,aAAc,EAAAmC,oBAFT,CAAP,EAAO,EAAA1X,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAGvc,SAAS9B,aAK9Eqe,aAAc,EAAAoC,aACT,CAAP,EAAO,EAAA3X,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,OAE3DxB,EAAGL,KACG,GAAM3b,QAAQwK,IAAIwR,EAAGL,KAC1Bpc,KAAI,SAACjD,GAEJ,OADA,UAAOC,IAAID,GACJ,EAAKif,eAAejf,EAC7B,MALA,M,OACF,MAAO,CAAP,EAAQ,SAKLyB,KAAK,O,OAEV,MAAO,CAAP,EAAOie,EAAGva,S,QAGC,EAAAwa,eAAb,W,kGAEK,OADI,KAAAjc,SAAQwK,IACZ,GAAM,UAAqByR,kB,OAD9B,MAAO,CAAP,EAAO,WACJ,SAA6C1c,KAAI,SAACoV,GACjD,iBAAQgD,IAAIhD,EAAZ,O,QAIR,EAnGA,CAA2C,W,y4FCjB3C,kBACA,cACA,cACA,UAEA,aACA,WAQA,WACA,WACA,cAIA,cASE,WAAY7N,GAAZ,MACE,YAAMA,IAAO,K,OACb,EAAKA,OAASA,EACd,EAAKuX,QAAS,EACd,EAAKC,OAAQ,EACb,EAAKC,gBAAkB,K,CACzB,CA+cF,OA9d2C,OAiBlC,EAAApH,iBAAP,WACE,MAAO,CACLvb,KAAM,SACNJ,IAAK,uBACLigB,SAAU,MACVC,SAAU,SACV8C,cAAe,iBACfC,mBAAoB,OACpBC,oBAAoB,EACpBC,gBAAgB,EAChB9b,WAAY,GACZ+V,cAAc,EAElB,EAEA,YAAArN,QAAA,WACE,OAAO,EAAP,KAAYqT,EAAczH,oBAAuBrb,KAAKgL,OACxD,EAEA,YAAA+X,mBAAA,SAAmBC,GACjB,IAAMC,EAAY,IAAI3iB,IAAI0iB,GACrBC,EAAUC,WAAUD,EAAUC,SAAW,IAC9CD,EAAUE,OAAS,GACnBF,EAAUniB,KAAO,GACjB,IAAMsiB,EAASH,EAAU1c,WACzB,OAAO6c,GAAwC,MAA9BA,EAAOA,EAAO5e,OAAS,GAAa,IAAM,GAC7D,EAEA,YAAA6H,OAAA,WACErM,KAAKqjB,gBAAgBC,QACrBtjB,KAAKujB,gBAAkBvjB,KAAKujB,gBAC9B,EAEA,YAAAC,eAAA,WACE,OAAOxjB,KAAK+iB,mBAAmB/iB,KAAKgL,OAAOtL,KAAOM,KAAKgL,OAAO0X,aAChE,EAEA,YAAAe,mBAAA,WACE,OAAOzjB,KAAKwjB,iBAAmB,OACjC,EAEM,YAAAE,UAAN,W,gGAImB,OAHXC,EAAU3jB,KAAKyjB,qBACrB,UAAOhjB,IAAIkjB,GAEM,GAAM3jB,KAAK4jB,aAAaD,I,OACzC,MAAO,CAAP,EADiB,U,QAInB,YAAAE,QAAA,SAAQC,GAAR,WACE,OAAO,IAAI5f,SAAQ,SAACC,EAASkW,GAC3B0J,WAAW5f,EAAS2f,GACpB,EAAKP,eAAiB,WAAM,OAAAlJ,EAAO,IAAI,EAAAvN,mBAAX,CAC9B,GACF,EAEM,YAAAkX,WAAN,W,gGACc,SAAMhkB,KAAK0jB,a,OACvB,GAAmB,OADbO,EAAM,UACJrC,OAAgB,CACtB,IAAIqC,EAAIC,QAAQ,iBAOd,MAAM,IAAI,EAAAC,oBAJV,GAFa,IAAIzF,KAAKuF,EAAIC,QAAQ,kBACVE,UA/EX,IAgFmB1F,KAAKC,MACnC,MAAM,IAAI,EAAAwF,mB,QAOG,MAAfF,EAAIrC,OAAJ,OAEF5hB,KAAKuiB,QAAS,E,qBACU,MAAf0B,EAAIrC,OAAJ,MACT,GAAM5hB,KAAKqkB,W,cAAX,S,aAEA,MAAM,IAAI,EAAApC,cACRgC,EAAIrC,OACJ5hB,KAAKgL,OAAO0X,cAAgB,S,yBAK5B,YAAA2B,QAAN,W,kGACQV,EAAU3jB,KAAKyjB,qBACrB,UAAOhjB,IAAI,iBAAmBkjB,GAC9B3jB,KAAKskB,eAAiBtkB,KAAKukB,WACzBZ,EACA,YACA,8C,iBAGA,O,sBAAA,GAAM3jB,KAAKskB,gB,cAAX,S,aAEA,I,sBAAiB,EAAA3C,YAA2B,MAAb,EAAEC,QAA+B,MAAb,EAAEA,QAEnD,MADA5hB,KAAKuiB,QAAS,EACR,IAAI,EAAA4B,oBAEZ,MAAM,E,cAERnkB,KAAKuiB,QAAS,E,YAGV,YAAAiC,SAAN,W,gHACMxkB,KAAKskB,eAAL,Y,iBAEA,O,sBAAA,GAAMtkB,KAAKskB,gB,cAAX,S,+BAEAza,QAAQC,KAAK,G,aAGjB,IAAK9J,KAAKuiB,OACR,UAGIkC,EAAUzkB,KAAKyjB,qBAEfiB,EAAa,EAAAC,OAAO7e,OACxB9F,KAAKgL,OAAO2U,SAAW,IAAM3f,KAAKgL,OAAO4U,UAGvBvb,EAAI,E,iEAGpB,UAAO5D,IAAI,iBAAmBgkB,GACE,QAA5B,EAAArN,UAAUC,cAAV,MACI,GAAMuN,MAAMH,EAAS,EAAF,CACvB5C,OAAQ,SACRgD,YAAa,OACbX,QAAS,CACPY,cAAe,SAAWJ,GAE5BK,OAAQ/kB,KAAKglB,cACRhlB,KAAKgL,OAAO6X,gBAAkB,CAACoC,SAAU,a,cAPhDhB,EAAM,S,cAUA,SAAM,gBAAKiB,QAAQ,CACvBxlB,IAAK+kB,EACL5C,OAAQ,SACRqC,QAAS,CACPY,cAAe,SAAWJ,GAE5BS,cAAe,CACbN,YAAa,W,OAPjBZ,EAAM,S,0BAWRmB,EAA2B,MAAfnB,EAAIrC,QAAiC,MAAfqC,EAAIrC,QAAiC,MAAfqC,EAAIrC,QACxD,OACF,GAAM5hB,KAAK6jB,QAAQ,M,QAAnB,S,mBAEFxf,I,uBACQ+gB,GAAa/gB,EAAI,GAAE,Y,mBAC7B,MAAO,CAAP,EAAO+gB,G,0BAEP,UAAO3kB,IAAI,gBACX,UAAOA,IAAI,G,iCAIT,YAAA4kB,eAAN,W,kHAGmB,OAFXZ,EAAUzkB,KAAKwjB,iBAEJ,GAAMxjB,KAAK4jB,aAAaa,I,OAEzC,GAAwB,OAFlB1C,EAAW,UAEJH,OACX,MAAM,IAAI,EAAA0D,oBAGZ,GAAwB,MAApBvD,EAASH,OAEX,OADA5hB,KAAKulB,aACE,CAAP,EAAOxD,G,GAGe,MAApBA,EAASH,OAAT,a,GACE4D,EAAazD,EAAS1J,MAEtBrY,KAAKgL,OAAOjE,WAAZ,Y,wDAIe,O,sBADP4P,EAAO1V,KAAKwkB,MAAMD,GACX,GAAM,UAAO9d,WAAW1H,KAAKgL,OAAOjE,WAAY4P,EAAK3O,WAAY2O,EAAK3P,O,cAAnFwe,EAAa,S,aAEA,O,SAAA,GAAM,UAAO9d,WAAW1H,KAAKgL,OAAOjE,WAAYye,EAAYxlB,KAAKgL,OAAO0X,gB,cAArF8C,EAAa,S,gCAGf,G,UAAIA,IAAeA,EAAW/O,SAAS,4CAA6C+O,EAAW/O,SAAS,uCAGtG,MAAM,IAAI,EAAAiP,gB,mBAIhB,IAAKF,IAAgBA,EAAW/O,SAAS,4CAA8C+O,EAAW/O,SAAS,uCACzG,MAAM,IAAI,EAAAkP,oBAKZ,IADMC,EAAOJ,EAAWzb,MAAM,MACzB,EAAL,EAAmB,EAAA6b,EAAA,eACjB,IADSC,EAAI,MACJzlB,QAAQ,yBAAwB,EAAG,CACpC0lB,EAAWD,EAAKzlB,QAAQ,KAAO,EAC/B2lB,EAASF,EAAKG,YAAY,KAEhChmB,KAAKimB,UAAYrf,SAASif,EAAKK,UAAUJ,EAAUC,IACnD,K,CAIJ,OAAQ/lB,KAAKgL,OAAO2X,oBAClB,IAAK,OACH,IAAK6C,EAAW/O,SAAS,0CACvB,MAAM,IAAI,EAAAkP,oBAEZ3lB,KAAKmmB,eAAiB,UAAeC,YAAYZ,GACjD,MACF,IAAK,OACH,IAAKA,EAAW/O,SAAS,uCACvB,MAAM,IAAI,EAAAkP,oBAEZ3lB,KAAKmmB,eAAiB,UAAKC,YAAYZ,GACvC,MACF,QACE,MAAM,IAAIvlB,MAAM,8B,mBAItB,MAAO,CAAP,EAAO8hB,G,QAGH,YAAAzD,YAAN,SAAkBC,EAAiB8H,G,YAAjB,IAAA9H,IAAAA,GAAA,QAAiB,IAAA8H,IAAAA,GAAA,G,iHACjC,UAAO5lB,IAAI,sBACXT,KAAKwiB,OAAQ,EAEmB,QAA5B,EAAApL,UAAUC,cAAV,MACe,iDAAa,MAAgB,K,OAAxCwD,EAAW,SAAgChE,QAC7CyP,OAAc,EAAEjI,GAAQ,E,iBAET,O,sBAAA,GAAMxD,EAAQ0L,YAAYC,SAAS,CAAEC,QAAS,CAACzmB,KAAKgL,OAAOtL,IAAM,Q,cAAlF4mB,EAAiB,S,+BAEjBjI,GAAQ,EACRxU,QAAQC,KAAK,G,aAEf,IAAKuU,IAAUiI,EACb,MAAM,IAAI,EAAAI,wB,iBAId,GAAqC,MAAjC1mB,KAAKgL,OAAO0X,cAAc,GAC5B,MAAM,IAAI,EAAAiE,W,OAGZ3mB,KAAKqjB,gBAAkB,IAAIuD,gBAC3B5mB,KAAKglB,YAAchlB,KAAKqjB,gBAAgB0B,OAEpCsB,EACF,GAAMrmB,KAAKqkB,WADT,M,cACF,S,qBACS9F,EACT,GAAMve,KAAKgkB,cADF,O,OACT,S,mBAGW,SAAMhkB,KAAKqlB,kB,QAExB,GAAoB,OAFdwB,EAAO,UAEJjF,QACa,MAAhBiF,EAAKjF,OACP,MAAM,IAAI,EAAAD,UAAUkF,EAAKjF,OAAQ,OAId,OAAvB,EAAA5hB,KAAuB,GAAMA,KAAKmmB,eAAerlB,MAAK,I,QAWtD,OAXA,EAAKgmB,gBAAkB,SAEvB,UAAOrmB,IAAI,0BAEPT,KAAKyiB,iBACPsE,cAAc/mB,KAAKyiB,kBAEjBlE,GAAY8H,KACdrmB,KAAKyiB,gBAAkBuE,aAAY,WAAM,OAAC,EAAKxE,OAAS,EAAK6B,SAApB,GAxSzB,OA2SE,MAAhBwC,EAAKjF,OAEA,CAAP,GAAO,G,YAIL,YAAA3B,WAAN,W,0FAIE,OAHA,UAAOxf,IAAI,cACXT,KAAKwiB,OAAQ,EACbuE,cAAc/mB,KAAKyiB,iBACnB,GAAMziB,KAAKwkB,Y,cAAX,S,YAGI,YAAAjF,eAAN,W,sGAMsB,OALpB,UAAO9e,IAAI,kBACXT,KAAKwiB,OAAQ,EACbuE,cAAc/mB,KAAKyiB,iBAEnBziB,KAAKmmB,eAAiBnmB,KAAKmmB,eAAehlB,QACtB,GAAMnB,KAAKmmB,eAAerlB,MAAK,I,cAA/B,WACAd,KAAK8mB,gBAArB,OACIrC,EAAUzkB,KAAKwjB,iBACjByD,EAA0C,SAAnCjnB,KAAKgL,OAAO2X,oBAiKTuE,EAjKoDlnB,KAAKmmB,eAkKvE/C,EAAS,kNAKbA,GACE,uBAxKyFpjB,KAAKimB,UA0K9F,yDAGF7C,GAAU,UAAe+D,UAAUD,GAEnC9D,GAAU,aAMZ,SAAoB8D,EAAYjB,GAC9B,IAAI7C,EAAS,qIAcb,OAVAA,GACE,uBACA6C,EACA,yDAGF7C,GAAU,UAAK+D,UAAUD,GAEzB9D,GAAU,SAGZ,CArM+GgE,CAAWpnB,KAAKmmB,eAAgBnmB,KAAKimB,WAC1IjmB,KAAKgL,OAAOjE,YACRC,EAAO,UAAOb,eAAe,UAAOmC,eAAe,KACtC,GAAM,UAAOD,WAAWrI,KAAKgL,OAAOjE,WAAYkgB,EAAMjgB,KAFvE,O,OAEIgB,EAAa,SACnBif,EAAOhmB,KAAKC,UAAU,CAAC8G,WAAU,EAAEhB,KAAI,I,iBAEzC,SAAMhH,KAAKukB,WAAWE,EAA4C,SAAnCzkB,KAAKgL,OAAO2X,mBAAgC,kBAAoB,YAAasE,I,cAA5G,S,aAEA,UAAOxmB,IAAI,8C,iBAGb,SAAMT,KAAKwkB,Y,cAAX,S,IAsJJ,IAAoB0C,EACd9D,C,QApJE,YAAAmB,WAAN,SAAiB7kB,EAAK2nB,EAAchP,G,mEAClC,MAAgC,QAA5B,EAAAjB,UAAUC,cACL,CAAP,EAAOrX,KAAKsnB,cAAc5nB,EAAK2nB,EAAchP,IAEtC,CAAP,EAAOrY,KAAKunB,iBAAiB7nB,EAAK2nB,EAAchP,G,QAI9C,YAAAiP,cAAN,SAAoB5nB,EAAK2nB,EAAchP,G,oGAC/BqM,EAAa,EAAAC,OAAO7e,OACxB9F,KAAKgL,OAAO2U,SAAW,IAAM3f,KAAKgL,OAAO4U,U,iBAInC,O,sBAAA,GAAMgF,MAAMllB,EAAG,KACnBmiB,OAAQ,MACRqC,QAAS,CACP,eAAgBmD,EAChBvC,cAAe,SAAWJ,GAE5BG,YAAa,OACbE,OAAQ/kB,KAAKglB,cACRhlB,KAAKgL,OAAO6X,gBAAkB,CAACoC,SAAU,WAAU,CACxDuC,KAAMnP,M,cATR4L,EAAM,S,aAcN,G,WAFA,UAAOxjB,IAAI,gBACX,UAAOA,IAAI,GACPT,KAAKglB,YAAYyC,QAAS,MAAM,IAAI,EAAA3a,mBACxC,MAAM,IAAI,EAAA4a,a,OAEZ,GAAmB,IAAfzD,EAAIrC,SAAiB5hB,KAAKgL,OAAO6X,eACnC,MAAM,IAAI,EAAA8E,cAEZ,GAAmB,MAAf1D,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAC5B,MAAM,IAAI,EAAA0D,oBAEZ,GAAIrB,EAAIrC,QAAU,IAChB,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQ,O,kBAI9B,YAAA2F,iBAAN,SAAuB7nB,EAAK2nB,EAAchP,G,oGAClCqM,EAAa,EAAAC,OAAO7e,OACxB9F,KAAKgL,OAAO2U,SAAW,IAAM3f,KAAKgL,OAAO4U,U,iBAInC,O,sBAAA,GAAM,gBAAKsF,QAAQ,CACvBxlB,IAAG,EACHmiB,OAAQ,MACRqC,QAAS,CACP,eAAgBmD,EAChBvC,cAAe,SAAWJ,GAE5BrM,KAAI,K,cAPN4L,EAAM,S,aAYN,M,WAFA,UAAOxjB,IAAI,gBACX,UAAOA,IAAI,GACL,IAAI,EAAAinB,a,OAEZ,GAAmB,MAAfzD,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAC5B,MAAM,IAAI,EAAA0D,oBAEZ,GAAIrB,EAAIrC,QAAU,IAChB,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQ,O,kBAI9B,YAAAgC,aAAN,SAAmBlkB,G,mEACjB,MAAgC,QAA5B,EAAA0X,UAAUC,cACL,CAAP,EAAOrX,KAAK4nB,gBAAgBloB,IAErB,CAAP,EAAOM,KAAK6nB,mBAAmBnoB,G,QAI7B,YAAAkoB,gBAAN,SAAsBloB,G,sGACdglB,EAAa,EAAAC,OAAO7e,OACxB9F,KAAKgL,OAAO2U,SAAW,IAAM3f,KAAKgL,OAAO4U,U,iBAInC,O,sBAAA,GAAMgF,MAAMllB,EAAG,GACnBmiB,OAAQ,MACRqC,QAAS,CACPY,cAAe,SAAWJ,GAE5B5I,MAAO,WACP+I,YAAa,OACbE,OAAQ/kB,KAAKglB,cACRhlB,KAAKgL,OAAO6X,gBAAkB,CAACoC,SAAU,a,cARhDhB,EAAM,S,aAaN,G,WAFA,UAAOxjB,IAAI,gBACX,UAAOA,IAAI,GACPT,KAAKglB,YAAYyC,QAAS,MAAM,IAAI,EAAA3a,mBACxC,MAAM,IAAI,EAAA4a,a,OAEZ,GAAmB,IAAfzD,EAAIrC,SAAiB5hB,KAAKgL,OAAO6X,eACnC,MAAM,IAAI,EAAA8E,cAEZ,GAAmB,MAAf1D,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAC5B,MAAM,IAAI,EAAA0D,oBAEZ,GAAIrB,EAAIrC,QAAU,KAAsB,MAAfqC,EAAIrC,OAC3B,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQ,OAGC,O,GAA1BA,OAAQqC,EAAIrC,QAAc,GAAMqC,EAAI6D,Q,OAA7C,MAAO,CAAP,GAA6B,EAAAzP,KAAM,SAAkB,EAAA6L,QAASD,EAAIC,QAAO,I,QAGrE,YAAA2D,mBAAN,SAAyBlE,G,oGAEjBe,EAAa,EAAAC,OAAO7e,OACxB9F,KAAKgL,OAAO2U,SAAW,IAAM3f,KAAKgL,OAAO4U,U,iBAInC,O,sBAAA,GAAM,gBAAKsF,QAAQ,CACvBxlB,IAAKikB,EACL9B,OAAQ,MACRqC,QAAS,CACPY,cAAe,SAAWJ,EAC1BqD,OAAQ,WACR,gBAAiB,YAEnBC,aAAc,U,cARhB/D,EAAM,S,aAaN,M,WAFA,UAAOxjB,IAAI,gBACX,UAAOA,IAAI,GACL,IAAI,EAAAinB,a,OAGZ,GAAmB,MAAfzD,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAC5B,MAAM,IAAI,EAAA0D,oBAEZ,GAAIrB,EAAIrC,QAAU,KAAsB,MAAfqC,EAAIrC,OAC3B,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQ,OAGlC,MAAO,CAAP,EAAOqC,G,QAEX,EA9dA,CAA2C,W,oqFCpB3C,iBACA,cACA,aACA,cACA,cACA,WASA,SAIA,2B,8CA8IA,QA9I4C,OAC7B,EAAApI,IAAb,SAAiBrc,G,wGAEF,UADPkc,EAAU,IAAI,UAAsBlc,IACfwhB,eAAe,O,OAIH,OAJjC3I,EAAO,SACP/S,EAAO,IAAI,UAAYoW,EAASrD,EAAKsE,W,EAGhCsL,EAAc,K,UAACzoB,EAAIkc,GAAS,GAAM,UAAeN,QAAQ/C,I,OAApE,MAAO,CAAP,EAAO,YAAI4P,EAAc,UAAc,SAAoC3iB,O,QAGhE,EAAA2W,OAAb,SAAoB5D,G,sGAEF,OADV7Y,EAAK,GAAKkf,KAAKC,MAAQra,KAAK4c,SAClB,GAAM,UAAe9F,QAAQ/C,I,OAG7C,OAHM8C,EAAU,SAGhB,IAFMO,EAAU,IAAI,UAAsBlc,IAE5B+d,eAAelF,EAAM,O,OAInC,OAJA,SACM/S,EAAO,IAAI,UAAYoW,EAASrD,EAAKsE,WAGpC,CAAP,EAAO,IAAIsL,EAAezoB,EAAIkc,EAASP,EAAS7V,I,QAG5C,YAAAwY,KAAN,W,wGAGQ,OAFNjU,QAAQpJ,IAAI,wBAA0BT,KAAKR,IACrC0oB,EAAUloB,KAAKyP,UACf,GAAMzP,KAAKyd,iB,cAAX,UAAqD,SAAtByK,EAAQvL,UAAzC,MACiB,GAAM,UAAQtI,UAAU8T,W,OAE9B,OAFPC,EAAa,SACbC,EAAeD,EAAW,GAAGzlB,SAAS,GAC/B,GAAM,UAAQ0R,UAAU4H,OAAO,CAC1Ctc,MAAO,YAAcK,KAAK0c,WAAa,IACvCjd,SAAU4oB,EAAa7oB,M,OAGN,OALb8oB,EAAO,SAIbJ,EAAQvL,UAAY2L,EAAK9oB,GACzB,EAAA0oB,EAAmB,GAAM,UAAYK,mBAAmBD,EAAK9oB,K,OAC7D,OADA,EAAQgpB,SAAW,SACnB,GAAMxoB,KAAKod,QAAQ8K,I,OAAnB,S,iBAEF,SAAMloB,KAAK0b,QAAQyF,gB,OACnB,OADA,SACA,GAAMnhB,KAAK0b,QAAQ0F,a,cAAnB,SACAphB,KAAK+K,UAAY,IAAI,UAAY/K,KAAK0b,QAASwM,EAAQvL,W,YAGnD,YAAAc,cAAN,W,kGAGI,O,sBAAkB,UADZd,EAAY3c,KAAKyP,UAAUkN,WAExB,CAAP,GAAO,GAET,GAAM,UAAQtI,UAAUoU,WAAW9L,I,OACnC,OADA,SACO,CAAP,GAAO,G,OAGP,O,WADA9S,QAAQpJ,IAAI,uCAAwC,GAC7C,CAAP,GAAO,G,yBAIL,YAAAyc,YAAN,W,sGACmC,SAA7Bld,KAAKyP,UAAUkN,UAAf,MACK,CAAP,EAAO3c,KAAK+K,W,OAEO,uDAAa,OAAc,K,OAE9C,OAFM2d,EAAa,SAA8B7R,QACjD7W,KAAK2oB,UAAY,IAAID,EAAU1oB,KAAK0b,SAC7B,CAAP,EAAO1b,KAAK2oB,W,QAIV,YAAA5M,kBAAN,W,gGACe,SAAM/b,KAAK0b,QAAQsF,eAAe,O,cAAzC3I,EAAO,SACbrY,KAAKgL,OAAOoS,QAAQ/E,GACpBrY,KAAK+K,UAAY,IAAI,UAAY/K,KAAK0b,QAASrD,EAAKsE,W,YAGzC,EAAA8C,eAAb,SAA4BS,G,qGAC1B,OAAIA,aAAc,EAAAsB,6BAGdtB,aAAc,EAAAuB,sBAFT,CAAP,EAAO,EAAA9W,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAGjc,QAKrEic,aAAc,EAAAyB,UACT,CAAP,EAAO,EAAAhX,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAG0B,OAAQ1B,EAAG2B,UAEhF3B,aAAc,EAAA4B,mBACT,CAAP,EAAO,EAAAnX,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,MAAQ,KAAOxB,EAAG6B,UAE7E7B,aAAc,EAAA8B,oCACT,CAAP,EAAO,EAAArX,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAG5c,OAAQ4c,EAAGvc,YAEhFuc,aAAc,EAAA+B,cACT,CAAP,EAAO,EAAAtX,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAG0B,OAAQ1B,EAAGgC,YAEhFhC,aAAc,EAAAxQ,cACT,CAAP,EAAO,EAAA/E,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAGiC,WAErEjC,aAAc,EAAAkC,qBAGdlC,aAAc,EAAAmC,oBAFT,CAAP,EAAO,EAAA1X,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,KAAM,CAACxB,EAAGvc,SAAS9B,aAK9Eqe,aAAc,EAAAoC,aACT,CAAP,EAAO,EAAA3X,KAAKX,WAAW,QAAUxI,OAAO0e,EAAG1B,MAAMkD,SAAS,EAAG,OAE3DxB,EAAGL,KACmB,KAApBK,EAAGL,KAAK,GAAGrB,KAEN,CAAP,EAAOxe,KAAKyf,eAAeS,EAAGL,KAAK,KAE7B,GAAM3b,QAAQwK,IAAIwR,EAAGL,KAC1Bpc,KAAI,SAACjD,GACJ,OAAO,EAAKif,eAAejf,EAC7B,MARA,M,OAKF,MAAO,CAAP,EAAQ,SAILyB,KAAK,O,OAEV,MAAO,CAAP,EAAOie,EAAGva,S,QAGC,EAAAwa,eAAb,W,kGAEK,OADI,KAAAjc,SAAQwK,IACZ,GAAM,UAAsByR,kB,OAD/B,MAAO,CAAP,EAAO,WACJ,SAA8C1c,KAAI,SAACoV,GAClD,iBAAQgD,IAAIhD,EAAZ,O,QAKO,EAAAuH,6BAAb,SAA0CnR,EAAgB1J,EAAoB8a,EAAuBuI,G,YAAA,IAAAA,IAAAA,GAAA,G,sGACvF,EAAArjB,GAAA,MAAc,GAAM,UAAYsjB,qBAAqB5Z,I,OAAxC,EAAC,S,wBAA1B1J,EAAY,GACE,EAAA8a,GAAA,MAAgB,GAAMrgB,KAAKmgB,kB,OAAZ,EAAC,S,iBAS9B,OAPM2I,GAFNzI,EAAc,GAGXrd,QAAO,SAAAmL,GAAO,OAAA5I,EAAUkR,SAAStI,EAAIsB,UAAUkN,UAAjC,IACd1Z,MAAK,SAACC,EAAGC,GACR,OAAAoC,EAAUnF,QAAQ8C,EAAEuM,UAAUkN,WAAapX,EAAUnF,QAAQ+C,EAAEsM,UAAUkN,UAAzE,IAEDjX,UAEEkjB,EAII,CAAP,EAAOE,IAHDC,EAAgBD,EAAiBE,WAAU,SAAA7a,GAAO,OAACA,EAAIsB,UAAUoN,UAAf,IACjD,CAAP,EAAOiM,EAAiBpkB,MAAM,EAAGJ,KAAKC,IAAI,EAAGwkB,M,QAKnD,EA9IA,CAA4C,W,iQCT7B,MAAME,EACnB,UAAOxoB,GACL,MAAMyoB,EAAS,EAAC,IAAIxK,MAAOyK,iBAAkB/O,WAI7Cpa,KAAKuJ,SAAS9D,KAAK2jB,IAAAA,OAAY5O,MAAM4O,IAAMF,GAC7C,CAEA,oBAAatK,GACX,MAAMyK,EAAuC,QAA5BjS,EAAAA,UAAUC,oBAAiC,6CAAkD,8CACxGgS,EAAQxS,QAAQyS,YACpB,QACA7oB,IACE,MAAM8I,EAAWvJ,KAAKuJ,SAEtB,OADAvJ,KAAKuJ,SAAW,GACTA,CAAQ,GAEjB,GAEJ,CAEA,oBAAaggB,GAEX,OAD6C,QAA5BnS,EAAAA,UAAUC,oBAAiC,6CAAkD,yCAC/FR,QAAQ0K,SAAS,OAAQ,GAC1C,CAEA,0BAAaiI,CAAcC,GACzB,MAAMC,EAAQ,gCACRC,QAAgB5lB,EAAAA,IAAa0lB,GAAMG,SAChCX,EAAOY,aAAaC,EAAOJ,GAAOE,MAAMG,EAAOC,EAAIC,EAAIC,IACxDF,GAAMC,EAGD,UAFaxiB,IAAAA,OAAcuiB,GAE3B,WADaviB,IAAAA,OAAcwiB,GACO,IAChCC,EAEF,UADYziB,IAAAA,OAAcyiB,GACb,SAFf,KAKR,GACGC,EAAS,kDACTC,EAAS,sBACf,OAAOT,EACJlmB,KAAIoiB,GAAQA,EAAKlc,QAAQwgB,EAAQ,aAAaxgB,QAAQygB,EAAQ,iBACnE,CAEA,yBAAaP,CAAaQ,EAAKX,EAAOY,GAEpC,MAAMC,EAAW,GAKjB,IAAIlS,EAJJgS,EAAI1gB,QAAQ+f,GAAO,SAACK,GAAmB,QAAAS,EAAApQ,UAAA5V,OAATyT,EAAI,IAAAlW,MAAAyoB,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJxS,EAAIwS,EAAA,GAAArQ,UAAAqQ,GAChC,MAAMC,EAAUJ,EAAQP,KAAU9R,GAClCsS,EAAS9kB,KAAKilB,EAChB,IAEA,IACErS,QAAanU,QAAQwK,IAAI6b,EAC3B,CAAE,MAAO/pB,GACPqJ,QAAQwU,MAAM7d,EAChB,CACA,OAAO6pB,EAAI1gB,QAAQ+f,GAAO,IAAMrR,EAAKsS,SACvC,CAEA,yBAAaC,GAAgC,IAAnBC,EAASzQ,UAAA5V,OAAA,QAAAsmB,IAAA1Q,UAAA,IAAAA,UAAA,GAC7BqP,QAAazpB,KAAKupB,UAClBsB,IACFpB,QAAaR,EAAOO,cAAcC,IAEpC,IAAIsB,EAAO,IAAIC,KAAK,CAACvB,EAAKxnB,KAAK,OAAQ,CACrCnC,KAAM,aACNmrB,QAAS,WAEXjrB,KAAKkrB,SACH,WACEC,EAAAA,GACA,KACA,IAAIzM,MAAOyK,cAAczkB,MAAM,EAAG,IAClC,KACCmmB,EAAY,WAAa,QAC1B,OACFE,EAEJ,CAEA,qBAAaG,CAASE,EAAUL,GAC9B,GAAgC,QAA5B3T,EAAAA,UAAUC,cAAyB,CACrC,MAAMgU,EAAUC,SAASC,cAAc,KAEvC,IAAIC,EAAYlrB,IAAImrB,gBAAgBV,GACpCM,EAAQK,aAAa,OAAQF,GAC7BH,EAAQK,aAAa,WAAYN,GAEjCC,EAAQM,MAAMC,QAAU,OACxBN,SAAS9D,KAAKqE,YAAYR,GAE1BA,EAAQS,QAERxrB,IAAIyrB,gBAAgBP,GACpBF,SAAS9D,KAAKwE,YAAYX,EAC5B,KAAO,CACL,MAAOY,IAAKC,SAAiBC,EAAAA,GAAWC,UAAU,CAChDC,KAAM,aAAejB,EACrB/S,WAAY0S,EAAKjD,OACjBwE,SAAUC,EAAAA,GAASC,KACnBC,UAAWC,EAAAA,GAAUC,SACrBC,WAAW,UAEPC,EAAAA,EAAMC,MAAM,CAChBntB,MAAOyrB,EACP2B,MAAO,CAACb,IAEZ,CACF,EAEFjD,EAAO1f,SAAW,E,ioEC3HL,EAAAyjB,UAAY,qD,0DACI,uDAAa,MAAmB,K,OAC9C,SADc,SAAiC,QACjCC,KAAKC,MAAM,CAAElV,QAAQ,EAAMmV,eAAe,K,OACrE,OADMF,EAAO,SACN,CAAP,EAAO3L,QAAiB,QAAT,EAAA2L,aAAI,EAAJA,EAAO,UAAE,eAAe,a,4hECHzC,eACA,UAMA,cAOE,WAAYvR,GAAZ,MACE,YAAM,CAAC,IAAE,K,OAPD,EAAA7b,SAA0B,EAAAX,aAAaC,MAQ/C,EAAKuc,QAAUA,EACf,EAAK7C,UAAY,EAAK6C,QAAQ7C,U,CAChC,CAuFF,OAlGwC,OAahC,YAAApP,KAAN,W,wGACwB,SAAM,cAAQoS,IAAI,CAACxU,IAAK,oBAAarH,KAAK6Y,UAAS,a,OAC9C,OADbvT,EAAQ,SAA6D,MACxD,GAAM,cAAQuW,IAAI,CAACxU,IAAK,oBAAarH,KAAK6Y,UAAS,kB,cAAhEoN,EAAa,SAAkE,MACzF3gB,GACc,EAAAtF,KAAKmmB,gBAAkB,GAAMnmB,KAAKmmB,eAAe9kB,mBAAkB,EAAOrB,KAAKH,UAAUiB,MAAK,IAA9F,MADd,M,SACqC,S,iBAEvB,OAFVssB,EAAU,EAChBptB,KAAKmmB,eAAiB,EAAA3iB,OAAOf,QAAQxB,KAAKwkB,MAAMngB,IAAOnE,OAAM,GAC7C,GAAMnB,KAAKmmB,eAAerlB,MAAK,I,OAE/C,OAFMusB,EAAU,SAChBrtB,KAAKimB,UAAYrf,SAASqf,GACnB,CAAP,EAAOmH,GAAWA,IAAYC,G,OAE9B,SAAMrtB,KAAKstB,Q,OACX,OADA,SACO,CAAP,GAAO,G,QAIL,YAAAA,KAAN,W,0FACE,SAAM,cAAQvkB,IAAI,CAAC1B,IAAK,oBAAarH,KAAK6Y,UAAS,UAAU0U,MAAOtsB,KAAKC,UAAUlB,KAAKmmB,eAAe9kB,mBAAkB,EAAM,EAAAnC,aAAaC,W,OAC5I,OADA,SACA,GAAM,cAAQ4J,IAAI,CAAC1B,IAAK,oBAAarH,KAAK6Y,UAAS,eAAe0U,MAAOvtB,KAAKimB,UAAY,M,cAA1F,S,YAGF,YAAAuH,YAAA,sBACEC,aAAaztB,KAAK0tB,aAClB1tB,KAAK0tB,YAAc3J,YAAW,WAC5B,EAAKuJ,MACP,GAAG,IACL,EAEM,YAAA1e,iBAAN,W,gGACe,SAAM,YAAMA,iBAAgB,Y,OAEzC,OAFMtJ,EAAO,UACRhE,cACE,CAAP,EAAOgE,G,QAGH,YAAAlD,eAAN,SAAqBuB,G,mEAEnB,OADA3D,KAAKwtB,cACE,CAAP,EAAO,YAAMprB,eAAc,UAACuB,G,QAGxB,YAAArB,eAAN,SAAqBqB,G,mEAEnB,OADA3D,KAAKwtB,cACE,CAAP,EAAO,YAAMlrB,eAAc,UAACqB,G,QAGxB,YAAAnB,eAAN,SAAqBmB,G,mEAEnB,OADA3D,KAAKwtB,cACE,CAAP,EAAO,YAAMhrB,eAAc,UAACmB,G,QAGxB,YAAAuB,aAAN,SAAmB5B,G,mEAEjB,OADAtD,KAAKwtB,cACE,CAAP,EAAO,YAAMtoB,aAAY,UAAC5B,G,QAGtB,YAAA6R,YAAN,SAAkB3V,EAAkB0U,G,mEAElC,OADAlU,KAAKwtB,cACE,CAAP,EAAO,YAAMrY,YAAW,UAAC3V,EAAI0U,G,QAGzB,YAAA/O,aAAN,SAAmB7B,G,mEAEjB,OADAtD,KAAKwtB,cACE,CAAP,EAAO,YAAMroB,aAAY,UAAC7B,G,QAGtB,YAAA8B,aAAN,SAAmB9B,G,mEAEjB,OADAtD,KAAKwtB,cACE,CAAP,EAAO,YAAMpoB,aAAY,UAAC9B,G,QAGtB,YAAA2Q,iBAAN,SAAuBzU,EAAmB8D,G,qGACxC,SAAMY,QAAQwK,IAAIpL,EAAOX,SAASc,KAAI,SAAMF,GAAK,qC,+DAC/CA,EAAM9D,SAAWD,EACb+D,aAAiB,EAAA3C,SACnB,GAAM,YAAMwB,eAAc,UAACmB,IADzB,M,OACF,S,wBAEEA,aAAiB,EAAAC,OACF,GAAM,YAAM0B,aAAY,UAAC3B,IADxC,M,OAEF,OADMoqB,EAAW,SACjB,GAAM3tB,KAAKiU,iBAAiB0Z,EAAUpqB,I,OAAtC,S,8CAGJ,OAVA,SAUO,CAAP,EAAOvD,KAAKmmB,eAAe9iB,WAAW7D,I,QAGxC,YAAAye,YAAA,WACE,OAAO/Z,QAAQC,SAAQ,EACzB,EACF,EAlGA,CAJA,YAIwC,S,s5FCPxC,kBACA,cACA,cACA,aACA,cACA,WAOA,WACA,WAEMypB,EAAc,CAClBC,qBAAsB,4CACtBC,oBAAqB,sCACrBC,MAAO,6CACPC,YAAa,oEACbC,aAAa,EACbC,QAAS,CACPC,MAAO,UAAYD,QAAQE,UAC3BpG,aAAc,OACdqG,YAAa,+BAEfC,IAAK,CACHH,MAAO,UAAYG,IAAIF,UACvBpG,aAAc,OACdqG,YAAa,gCAcjB,cAYE,WAAYrjB,GAAZ,MACE,YAAMA,IAAO,K,OAPP,EAAAuY,eAA6B,KAC7B,EAAAgL,cAAe,EAEf,EAAAhM,QAAS,EAKf,EAAKvX,OAASA,E,CAChB,CAybF,OAxcgD,OAiBjC,EAAAwjB,UAAb,SAAuBC,G,YAAA,IAAAA,IAAAA,GAAA,G,iJAGJ,SAFXC,EAAW,EAAAtX,UAAUC,eAEvB,MACa,GAAM,EAAAsX,aAAaC,aAAahB,I,OAG/C,OAHM9kB,EAAS,SACT+lB,EAAgB/lB,EAAOgmB,sBAAsBD,cAC7ClP,EAAW7W,EAAOimB,KAAKC,YACtB,CAAP,EAAO,CAAEH,cAAa,EAAElP,SAAQ,I,aAGjB,QAAb+O,EAAA,MACe,iDAAa,MAAgB,K,OAExC,OAFA,EAAW,SAAgC7X,QAC3C4P,EAAU,CAAC,iCAAkC,+BAC7C,GAAM,EAAQF,YAAYC,SAAS,CAAEC,QAAO,K,OAAlD,IAAM,SACJ,MAAM,IAAI,EAAAC,wB,iBAK0B,OAAtB,gBAAOvgB,eAAe,GAAM,UAAOmC,eAAe,M,OAChC,OAD9B2mB,EAAY,WAAsB,WAAkCpoB,OAAO,EAAG,KACtE,gBAAOV,eAAe,GAAM,UAAOmC,eAAe,M,OAY/C,OAZX4mB,EAAQ,WAAsB,WAAkCroB,OAAO,EAAG,IAC1EsoB,EAAclV,OAAOmV,SAASC,iBAC9BC,EAAS,CAAC,8CACZC,EAAU,4CACdA,GAAW,qBAAc,UAAYC,IAAIpB,WACzCmB,GAAW,sBACXA,GAAW,wBAAiBE,mBAAmBN,IAC/CI,GAAW,iBAAUE,mBAAmBH,EAAOrtB,KAAK,OACpDstB,GAAW,6CACXA,GAAW,0BAAmBN,GAC9BM,GAAW,iBAAUL,GAEJ,iDAAa,MAAgB,K,OAEvB,SAFN,SAAgCrY,QAEZuY,SAASM,kBAAkB,CAC9DjB,YAAW,EACX/uB,IAAK6vB,K,OAIP,GANMI,EAAiB,WAKjBC,EAAID,EAAe5F,MAAM,cACrB6F,EAAEprB,OAAS,EACnB,MAAO,CAAP,EAAO,MAKT,GAJMuU,EAAS,IAAI8W,gBAAgBD,EAAE,GAAG7lB,MAAM,KAAK,IAC7CyU,EAAOzF,EAAO8C,IAAI,QAClBiU,EAAW/W,EAAO8C,IAAI,UAEvB2C,EACH,MAAM,IAAIve,MAAM,yBAElB,GAAI6vB,IAAaZ,EACf,MAAM,IAAIjvB,MAAM,qDAED,SAAM2kB,MAAM,sCAAuC,CAClE/C,OAAQ,OACRqC,QAAS,CACP,eAAgB,qCAElBsD,KAAM,eAAQhJ,GACZ,qBAAc,UAAYgR,IAAIpB,WAC9B,yBAAkB,UAAYoB,IAAIO,eAClC,wBAAiBN,mBAAmBxV,OAAOmV,SAASC,mBACpD,yBAAkBJ,GAClB,oC,eAGoB,OAblBlN,EAAW,UAaJH,OAAT,QACF,gBAAOnhB,IAAI,uDAAuD,GAAMshB,EAAS+F,S,QACjF,MADA,WAAW,EAAuD,WAC5D,IAAI,EAAAkI,gB,QAEC,SAAMjO,EAASpL,Q,QAC5B,KADMA,EAAO,UACHsZ,eAAiBtZ,EAAKkY,cAE9B,MADA,UAAOpuB,IAAI,qDAAuDQ,KAAKC,UAAUyV,IAC3E,IAAI,EAAAqZ,gBAGA,SAAMpL,MAAM,oEAAqE,CAC3FV,QAAS,CACPY,cAAe,UAAYnO,EAAKsZ,iB,QAGtB,SALF,SAKYtZ,Q,QAExB,OAFMuZ,EAAQ,SAEP,CAAP,EAAO,CAAErB,cAAelY,EAAKkY,cAAelP,SAAUuQ,EAAMnB,KAAKC,c,QAG7D,YAAAmB,eAAN,SAAqBC,G,0GAGF,OAFX1B,EAAW,EAAAtX,UAAUC,cAEV,GAAMrX,KAAKklB,QAAQ,OAAQ,sCAAqC,KAE7E2J,cAAeuB,EACfhC,UAAW,UAAYM,GAAUN,WAChB,QAAbM,GAAsB,CAACqB,cAAe,UAAYP,IAAIO,gBAAe,CACzEM,WAAY,kBAEd,sC,cAGsB,OAVlBtO,EAAW,UAUJH,OAAT,OACF,gBAAOnhB,IAAI,sDAAsD,GAAMshB,EAAS+F,S,OAChF,MADA,WAAW,EAAsD,WAC3D,IAAI,EAAAwI,+B,OAGC,SAAMvO,EAASpL,Q,OAC5B,IADMA,EAAO,UACJsZ,aACP,MAAO,CAAP,EAAOtZ,EAAKsZ,cAEZ,MAAM,IAAI,EAAAD,gB,QAId,YAAAtT,SAAA,WACE,OAAO1c,KAAKgL,OAAO+R,OAAS,iBAAmB/c,KAAKgL,OAAO0X,aAC7D,EAEO,EAAArH,iBAAP,WACE,MAAO,CACLvb,KAAM,eACN6f,SAAU,GACVC,SAAU,GACVwQ,aAAc,KACd1N,cAAe,iBACf5F,cAAc,EAElB,EAEA,YAAAyT,OAAA,WACE,MAAO,qCACT,EAEA,YAAA1M,QAAA,SAAQC,GAAR,WACE,OAAO,IAAI5f,SAAQ,SAACC,EAASkW,GAC3B0J,WAAW5f,EAAS2f,GACpB,EAAKP,eAAiB,WAAM,OAAAlJ,EAAO,IAAI,EAAAvN,mBAAX,CAC9B,GACF,EAEM,YAAAwR,YAAN,SAAkBC,EAAiB8H,G,YAAjB,IAAA9H,IAAAA,GAAA,QAAiB,IAAA8H,IAAAA,GAAA,G,yJACjC,UAAO5lB,IAAI,sBAEqB,QAA5B,EAAA2W,UAAUC,cAAV,MACe,iDAAa,MAAgB,K,OAAxCwD,EAAW,SAAgChE,QAC3C4P,EAAU,CAAC,iCAAkC,+BAC/CH,OAAc,EAAEjI,GAAQ,E,iBAET,O,sBAAA,GAAMxD,EAAQ0L,YAAYC,SAAS,CAAEC,QAAO,K,cAA7DH,EAAiB,S,+BAEjBjI,GAAQ,EACRxU,QAAQC,KAAK,G,aAEf,IAAKuU,IAAUiI,EACb,MAAM,IAAI,EAAAI,wB,iBAIK,OAAnB,EAAA1mB,KAAmB,GAAMA,KAAKmwB,eAAenwB,KAAKgL,OAAOolB,e,OAExC,OAFjB,EAAKI,YAAc,SAEF,GAAMxwB,KAAKywB,UAAU,kBAAWzwB,KAAKgL,OAAO0X,cAAa,KAAK,M,OAC/E,KADMgO,EAAW,UACH3D,MACZ,MAAM,IAAI,EAAA4D,uBAGNC,EAAOF,EAAS3D,MAAM/pB,QAAO,SAAA4tB,GAAQ,OAACA,EAAKC,OAAN,IAAe,GAEpDC,EAAgBJ,EAAS3D,MAAM/pB,QAAO,SAAA4tB,GAAQ,OAACA,EAAKC,OAAN,IAAensB,MAAM,G,IAC9C,EAAAosB,E,sBAAA,YAAa,aAA7BC,EAAY,K,mBAEnB,O,yBAAA,GAAM/wB,KAAKgxB,WAAWD,EAAavxB,K,eAAnC,S,iCAEA,UAAOiB,IAAI,sCAAwC,EAAEkF,S,sBAJ9B,I,qBAQvBirB,GACF5wB,KAAKixB,OAASL,EAAKpxB,GACf6mB,GACF,EAAArmB,KAAc,GAAMA,KAAKqkB,QAAQrkB,KAAKixB,UADpC,QAFF,O,eAGA,EAAK1O,OAAS,S,sBACLhE,EACI,GAAMve,KAAKkxB,gBAAgBN,EAAKpxB,GAAI,kBADxC,O,QAET,IADM6Y,EAAO,UACJ8Y,eAAiB9Y,EAAK8Y,cAAc5O,UAAyC,IAA9BlK,EAAK8Y,cAAc5O,QAAmBthB,KAAKwkB,MAAMpN,EAAK8Y,cAAc5O,SAAU,CAEpI,GADM6O,EAAanwB,KAAKwkB,MAAMpN,EAAK8Y,cAAc5O,SAC5C8O,OAAOC,UAAUF,GACpB,MAAM,IAAI,EAAAjN,oBAEZ,GAAIzF,KAAKC,MAAQyS,EA1MN,IA2MT,MAAM,IAAI,EAAAjN,mB,CAGA,OAAd,EAAAnkB,KAAc,GAAMA,KAAKqkB,QAAQrkB,KAAKixB,S,QAAtC,EAAK1O,OAAS,S,mBAGC,SAAMviB,KAAK4jB,aAAa5jB,KAAKixB,S,WAA1CzL,EAAa,UAEbxlB,KAAKgL,OAAO4U,SAAZ,a,+DAIe,O,yBADPjJ,EAAO1V,KAAKwkB,MAAMD,GACX,GAAM,UAAO9d,WAAW1H,KAAKgL,OAAO4U,SAAUjJ,EAAK3O,WAAY2O,EAAK3P,O,eAAjFwe,EAAa,S,eAEA,O,SAAA,GAAM,UAAO9d,WAAW1H,KAAKgL,OAAO4U,SAAU4F,EAAYxlB,KAAKgL,OAAO0X,gB,eAAnF8C,EAAa,S,oCAGf,G,UAAIA,IAAcA,EAAW/O,SAAS,0CAIpC,MAAM,IAAI,EAAAiP,gB,OAFV1lB,KAAKuuB,cAAe,E,eAM1B,IAAK/I,IAAeA,EAAW/O,SAAS,0CACtC,MAAM,IAAI,EAAAkP,oBAKZ,IADMC,EAAOJ,EAAWzb,MAAM,MACzB,EAAL,EAAmB,EAAA6b,EAAA,eACjB,IADSC,EAAI,MACJzlB,QAAQ,yBAAwB,EAAG,CACpC0lB,EAAWD,EAAKzlB,QAAQ,KAAO,EAC/B2lB,EAASF,EAAKG,YAAY,KAEhChmB,KAAKimB,UAAYrf,SAASif,EAAKK,UAAUJ,EAAUC,IACnD,K,QAIJ/lB,KAAKmmB,eAAiB,UAAeC,YAAYZ,GAC7CxlB,KAAKyiB,iBACPsE,cAAc/mB,KAAKyiB,kBAEjBlE,GAAY8H,KACdrmB,KAAKyiB,gBAAkBuE,aAAY,WAAM,SAAK3C,QAAQ,EAAK4M,OAAlB,GA1P3B,O,eA6PhBjxB,KAAKulB,aACLvlB,KAAKuuB,cAAe,E,mBAGC,OAAvB,EAAAvuB,KAAuB,GAAMA,KAAKmmB,eAAerlB,MAAK,I,QAItD,OAJA,EAAKgmB,gBAAkB,SAEvB,UAAOrmB,IAAI,0BAENT,KAAKixB,O,IAED,CAAP,GAAO,G,QAIL,YAAAhR,WAAN,W,iGACE,UAAOxf,IAAI,cACPT,KAAKixB,QACPlK,cAAc/mB,KAAKyiB,iBACfziB,KAAKuiB,OACP,GAAMviB,KAAKwkB,SAASxkB,KAAKixB,SADvB,OAFF,M,OAGA,S,wBAGJjxB,KAAKixB,OAAS,K,YAGV,YAAA1R,eAAN,W,sGAKsB,OAJpB,UAAO9e,IAAI,kBACXsmB,cAAc/mB,KAAKyiB,iBAEnBziB,KAAKmmB,eAAiBnmB,KAAKmmB,eAAehlB,QACtB,GAAMnB,KAAKmmB,eAAerlB,MAAK,I,cAA7CywB,EAAc,SAiLJrK,EAhLMlnB,KAAKmmB,eAiLzB/C,EAAS,kNAKbA,GACE,uBAvL2CpjB,KAAKimB,UAyLhD,yDAGF7C,GAAU,UAAe+D,UAAUD,GA5L7BD,EA8LN7D,GAAU,YA5LJpjB,KAAKgL,OAAO4U,UACR5Y,EAAO,UAAOb,eAAe,UAAOmC,eAAe,KACtC,GAAM,UAAOD,WAAWrI,KAAKgL,OAAO4U,SAAUqH,EAAMjgB,KAFrE,M,OAEIgB,EAAa,SACnBif,EAAOhmB,KAAKC,UAAU,CAAC8G,WAAU,EAAEhB,KAAI,I,wBAGpChH,KAAKixB,OAAN,MACF,GAAMjxB,KAAKwxB,WAAWvK,I,OAEtB,OAFA,SACAjnB,KAAKixB,OAAS,KACd,I,cAGEM,IAAgBvxB,KAAK8mB,iBAAmB9mB,KAAKuuB,aAC/C,GAAMvuB,KAAKukB,WAAWvkB,KAAKixB,OAAQhK,IADjC,M,cACF,SACAjnB,KAAKuuB,cAAe,E,aAEpB,UAAO9tB,IAAI,8C,iBAEb,SAAMT,KAAKwkB,SAASxkB,KAAKixB,S,cAAzB,SACAjxB,KAAKixB,OAAS,K,IA2JlB,IAAoB/J,EACd9D,C,QAzJJ,YAAA/W,OAAA,WACErM,KAAKujB,gBAAkBvjB,KAAKujB,gBAC9B,EAEM,YAAA2B,QAAN,SAAcrD,EAAgBniB,EAAa8nB,EAAkBiK,G,YAAlB,IAAAjK,IAAAA,EAAA,WAAkB,IAAAiK,IAAAA,EAAA,M,4DAC3D,MAAO,CAAP,EAAOzxB,KAAK0xB,cAAc7P,EAAQniB,EAAK8nB,EAAMiK,G,QAGzC,YAAAE,WAAN,SAAiB9P,EAAgBniB,EAAa8nB,EAAkBiK,G,YAAlB,IAAAjK,IAAAA,EAAA,WAAkB,IAAAiK,IAAAA,EAAA,M,iGAGrD,O,sBAAA,GAAM7M,MAAMllB,EAAK,EAAF,CACpBmiB,OAAM,EACNgD,YAAa,OACbX,QAAS,EAAF,KACDlkB,KAAKwwB,aAAe,CAAC1L,cAAe,UAAY9kB,KAAKwwB,cACrDiB,GAAe,CAAC,eAAgBA,KAElCjK,GAAQ,CAACA,KAAI,M,cAPnBX,EAAO,S,aAYP,M,WAFA,UAAOpmB,IAAI,gBACX,UAAOA,IAAI,GACL,IAAI,EAAAinB,a,cAEQ,MAAhBb,EAAKjF,QAAkC,MAAhBiF,EAAKjF,OAA5B,OACF,gBAAOnhB,IAAI,2CAA2C,GAAMomB,EAAKiB,S,OACjE,MADA,WAAW,EAA2C,WAChD,IAAI,EAAAxC,oB,OAEZ,MAAO,CAAP,EAAOuB,G,QAGH,YAAA6K,cAAN,SAAoB7P,EAAgBniB,EAAa8nB,EAAkBiK,G,YAAlB,IAAAjK,IAAAA,EAAA,WAAkB,IAAAiK,IAAAA,EAAA,M,uGAGjE,GAAoB,sCAAhBA,EAAqD,CAEvD,IADM1Y,EAAS,IAAI8W,gBACd,EAAL,EAA2B,EAAA/sB,OAAO0T,QAAQgR,GAAQ,CAAC,GAAxB,eAAhB,OAACngB,EAAG,KAAEkmB,EAAK,KACpBxU,EAAOhQ,IAAI1B,EAAKkmB,GAElB/F,EAAOzO,EAAOxS,U,kBAIR,O,sBAAA,GAAM,gBAAK2e,QAAQ,EAAD,CACtBxlB,IAAG,EACHmiB,OAAM,EACNqC,QAAS,EAAF,KACDlkB,KAAKwwB,aAAe,CAAC1L,cAAe,UAAY9kB,KAAKwwB,cACrDiB,GAAe,CAAC,eAAgBA,IAEtCzJ,aAAc,QACVR,GAAQ,CAACnP,KAAMmP,M,cARrBvD,EAAM,S,aAaN,M,WAFA,UAAOxjB,IAAI,gBACX,UAAOA,IAAI,GACL,IAAI,EAAAinB,a,OAGZ,GAAmB,MAAfzD,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAE5B,MADA,UAAOnhB,IAAI,yCAA2CwjB,EAAI5L,MACpD,IAAI,EAAAiN,oBAGZ,GAAIrB,EAAIrC,QAAU,IAChB,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQC,GAGlC,MAAO,CAAP,EAAO,CACLD,OAAQqC,EAAIrC,OACZjL,KAAM,WAAM,OAAAzS,QAAQC,QAAQ8f,EAAI5L,KAApB,EACZyP,KAAM,WAAM,OAAA5jB,QAAQC,QAAQ8f,EAAI5L,KAApB,I,QAIV,YAAAoY,UAAN,SAAgBvD,EAAe0E,G,YAAA,IAAAA,IAAAA,EAAA,G,mFACjB,SAAM5xB,KAAKklB,QAAQ,MAAOllB,KAAKuwB,SAAW,gCAAyBd,mBAAmBvC,GAAM,mFAA2E0E,K,OACnL,MAAO,CAAP,EADY,SACDjb,Q,QAGP,YAAAua,gBAAN,SAAsB1xB,EAAYqyB,G,0FACpB,SAAM7xB,KAAKklB,QAAQ,MAAOllB,KAAKuwB,SAAW,UAAY/wB,GAAMqyB,EAAS,kBAAWpC,mBAAmBoC,IAAY,M,OAC3H,MAAO,CAAP,EADY,SACDlb,Q,QAGP,YAAAiN,aAAN,SAAmBpkB,G,0FACL,SAAMQ,KAAKklB,QAAQ,MAAOllB,KAAKuwB,SAAW,UAAY/wB,EAAK,e,OACvE,MAAO,CAAP,EADY,SACDsoB,Q,QAGP,YAAAkJ,WAAN,SAAiBxxB,G,0FACf,SAAMQ,KAAKklB,QAAQ,SAAUllB,KAAKuwB,SAAW,UAAY/wB,I,cAAzD,S,YAGI,YAAAglB,SAAN,SAAehlB,G,2GACTQ,KAAKskB,eACP,GAAMtkB,KAAKskB,gBADT,M,OACF,S,iBAEajgB,EAAI,E,iBAEL,SAAMrE,KAAKklB,QAAQ,QAASllB,KAAKuwB,SAAW,UAAY/wB,EAClEyB,KAAKC,UAAU,CACbiwB,cAAe,CACb5O,OAAQthB,KAAKC,WAAU,MAG3B,qB,cANI+iB,EAAM,UAQZmB,EAA2B,MAAfnB,EAAIrC,QAAiC,MAAfqC,EAAIrC,QAClC,MACF,GAAM5hB,KAAK6jB,QAAQ,M,OAAnB,S,iBAEFxf,I,qBACQ+gB,GAAa/gB,EAAI,GAAE,Y,iBAC7B,MAAO,CAAP,EAAO+gB,G,QAGH,YAAAf,QAAN,SAAc7kB,G,0FASA,OARZQ,KAAKskB,eAAiBtkB,KAAKklB,QAAQ,QAASllB,KAAKuwB,SAAW,UAAY/wB,EACtEyB,KAAKC,UAAU,CACbiwB,cAAe,CACb5O,OAAQthB,KAAKC,UAAUwd,KAAKC,UAGhC,oBAEU,GAAM3e,KAAKskB,gB,OACvB,MAAO,CAAP,EAAsB,MADV,SACD1C,Q,QAGP,YAAA4P,WAAN,SAAiBvK,G,kGACL,SAAMjnB,KAAKklB,QAAQ,OAAQ,oEAAqE+B,EAAM,oB,OAChH,OAAmB,OADfhD,EAAM,UACFrC,QAAiC,MAAfqC,EAAIrC,OACrB,CAAP,GAAO,GAEI,GAAMqC,EAAItN,Q,OAGjB,OAHAia,EAAO,SACb5wB,KAAKixB,OAASL,EAAKpxB,GAEb,GAAMQ,KAAKklB,QAAQ,QAASllB,KAAKuwB,SAAW,UAAYvwB,KAAKixB,OACjEhwB,KAAKC,UAAU,CAACqG,KAAMvH,KAAKgL,OAAO0X,gBAClC,qB,OAEF,MAAO,CAAP,EAAsB,OAJtBuB,EAAM,UAIKrC,Q,QAGP,YAAA2C,WAAN,SAAiB/kB,EAAWynB,G,0FACb,SAAMjnB,KAAKklB,QAAQ,QAAS,oDAAsD1lB,EAAIynB,EAAM,oB,OACzG,MAAO,CAAP,EAAuB,MADV,SACDrF,Q,QArcP,EAAAkQ,OAAS,CAAC,2DAucnB,C,CAxcA,CAAgD,W,UAA3BC,C,m6EC3CrB,iBACA,UACA,cAEA,cAGA,WASA,aAME,WAAY/mB,GAFF,KAAAnL,SAA0B,EAAAX,aAAaE,OAG/CY,KAAKulB,YACP,CA8NF,OA5NE,YAAAA,WAAA,WACEvlB,KAAKimB,UAAY,EACjBjmB,KAAKmmB,eAAiB,IAAI,EAAA3iB,OAAO,CAAEhE,GAAI,EAAGG,MAAO,OAAQE,SAAUG,KAAKH,UAC1E,EAEA,YAAA6c,SAAA,WACE,IAAMrE,EAAOrY,KAAKyP,UAClB,OAAO4I,EAAK0E,OAAS1E,EAAKsH,SAAW,IAAM,IAAIrf,IAAI+X,EAAK3Y,KAAKsyB,QAC/D,EAEM,YAAApjB,iBAAN,W,mEACE,MAAO,CAAP,EAAO5O,KAAKmmB,eAAehlB,Q,QAG7B,YAAAyO,gBAAA,SAAgB/L,GACd,GAAe,UAAXA,EAAGnE,IACL,OAAO,EAET,IACE,OAAO4hB,QAAQ,CAAC,SAAU,QAAS,OAAQ,QAAS,cAAe,QAAS,UAAW,SAAS7K,SAC9F,IAAInW,IAAIuD,EAAGnE,KAAKmM,U,CAElB,MAAOrL,GACP,OAAO,C,CAEX,EAEM,YAAA4B,eAAN,SAAqByB,G,yEAInB,GAHA,UAAOpD,IAAI,SAAUoD,GACrBA,EAAGrE,KAAOQ,KAAKimB,YACTpI,EAAc7d,KAAKmmB,eAAe9iB,WAAWQ,EAAGpE,WAEpD,MAAM,IAAI,EAAAwyB,yBAIZ,OAFApU,EAAYlb,SAAS8C,KAAK5B,GAC1B7D,KAAKmmB,eAAe7kB,cACb,CAAP,EAAOuC,EAAGrE,G,QAGN,YAAA8C,eAAN,SAAqB4vB,G,6EAGnB,GAFA,UAAOzxB,IAAI,SAAUyxB,KACftU,EAAgB5d,KAAKmmB,eAAeziB,aAAawuB,EAAM1yB,KAE3D,MAAM,IAAI,EAAA2yB,2BAIZ,GAFAvU,EAAcle,IAAMwyB,EAAMxyB,IAC1Bke,EAAcje,MAAQuyB,EAAMvyB,MACxB6B,OAAOoc,EAAcne,YAAc+B,OAAO0wB,EAAMzyB,UAClD,UAKF,KAHM2yB,EAAiBpyB,KAAKmmB,eAAe9iB,WACzCua,EAAcne,WAGd,MAAM,IAAI,EAAA4yB,uBAGZ,KADMC,EAAiBtyB,KAAKmmB,eAAe9iB,WAAW6uB,EAAMzyB,WAE1D,MAAM,IAAI,EAAA8yB,uB,OAEZH,EAAezvB,SAASoQ,OACtBqf,EAAezvB,SAASvC,QAAQwd,GAChC,GAEF0U,EAAe3vB,SAAS8C,KAAKmY,GAC7BA,EAAcne,SAAWyyB,EAAMzyB,SAC/BO,KAAKmmB,eAAe7kB,c,WAGhB,YAAAkB,eAAN,SAAqBmB,G,6EAInB,OAHA,UAAOlD,IAAI,SAAU,CAAEkD,SAAQ,IACzBnE,EAAKmE,EAASnE,IACdoe,EAAgB5d,KAAKmmB,eAAeziB,aAAalE,MAIjD4yB,EAAiBpyB,KAAKmmB,eAAe9iB,WACzCua,EAAcne,YAKhB2yB,EAAezvB,SAASoQ,OACtBqf,EAAezvB,SAASvC,QAAQwd,GAChC,GAEF5d,KAAKmmB,eAAe7kB,c,KAZlB,G,QAeE,YAAA4D,aAAN,SAAmB5B,G,2EAIjB,GAHA,UAAO7C,IAAI,eAAgB,CAAE6C,OAAM,IAC7BkvB,EAAY,IAAIC,EAAKjvB,OAAO,CAAEhE,KAAMQ,KAAKimB,UAAWxmB,SAAU6D,EAAO7D,SAAUE,MAAO2D,EAAO3D,MAAOE,SAAUG,KAAKH,aACnH6yB,EAAoB1yB,KAAKmmB,eAAe9iB,WAAWmvB,EAAU/yB,WAEjE,MAAM,IAAI,EAAAwyB,yBAIZ,OAFAS,EAAkB/vB,SAAS8C,KAAK+sB,GAChCxyB,KAAKmmB,eAAe7kB,cACb,CAAP,EAAOkxB,EAAUhzB,G,QAGb,YAAA2F,aAAN,SAAmB7B,G,+EAIjB,GAHA,UAAO7C,IAAI,eAAgB,CAAE6C,OAAM,IAC7B9D,EAAK8D,EAAO9D,KACZmzB,EAAY3yB,KAAKmmB,eAAe9iB,WAAW7D,IAE/C,MAAM,IAAI,EAAAozB,yBAIZ,KADMC,EAAuB7yB,KAAKmmB,eAAe9iB,WAAWsvB,EAAUlzB,WAEpE,MAAM,IAAI,EAAA4yB,uBAGZ,KADMS,EAAuB9yB,KAAKmmB,eAAe9iB,WAAWC,EAAO7D,WAEjE,MAAM,IAAI,EAAA8yB,uBAEZ,GAAII,EAAUtvB,WAAWyvB,EAAqBtzB,IAC5C,MAAM,IAAIS,MAAM,4CAA8CT,EAAK,OAAS8D,EAAO7D,SAAW,iD,OAEhGozB,EAAqBlwB,SAASoQ,OAAO8f,EAAqBlwB,SAASvC,QAAQuyB,GAAY,GACvFG,EAAqBnwB,SAAS8C,KAAKktB,GACnCA,EAAUhzB,MAAQ2D,EAAO3D,MACzBgzB,EAAUlzB,SAAW6D,EAAO7D,SAC5BO,KAAKmmB,eAAe7kB,c,WAGhB,YAAA6T,YAAN,SAAkB3V,EAAkB0U,G,6EAIlC,GAHA,UAAOzT,IAAI,cAAe,CAAEjB,GAAE,EAAE0U,MAAK,MAE/B5Q,EAAStD,KAAKmmB,eAAe9iB,WAAW7D,IAE5C,MAAM,IAAI,EAAAuzB,wBAgBZ,GAdA7e,EAAMnP,SAAQ,SAAAd,GACZ,IAAMV,EAAQD,EAAO/B,SAAS0C,EAAKnE,KAAMmE,EAAKzE,IAC9C,IAAK+D,GAAS/B,OAAO+B,EAAM9D,YAAc+B,OAAO8B,EAAO9D,IACrD,MAAM,IAAI,EAAAgiB,4BAA4BhiB,EAAK,IAAMyB,KAAKC,UAAU+C,GAEpE,IACAX,EAAOX,SAASoC,SAAQ,SAAAxB,GAEtB,IADa2Q,EAAMtQ,MAAK,SAACK,GAAS,OAAAA,EAAKnE,OAASyD,EAAMzD,MAAQ0B,OAAOyC,EAAKzE,MAAQgC,OAAO+B,EAAM/D,GAA7D,IAEhC,MAAM,IAAI,EAAAiiB,sBACRjiB,EAAK,IAAM+D,EAAM1B,UAGvB,IACIqS,EAAM1P,SAAWlB,EAAOX,SAAS6B,OAEnC,MADM4J,GAAO,aAAW9K,EAAOX,SAASc,KAAI,SAAAY,GAAK,OAAAA,EAAE7E,EAAF,IAAO0U,EAAMzQ,KAAI,SAAAY,GAAK,OAAAA,EAAE7E,EAAF,KACjE,IAAI,EAAAiiB,sBAAsBjiB,EAAK,IAAMyB,KAAKC,UAAUkN,I,OAEtD4kB,EAAc,GACpB9e,EAAMnP,SAAQ,SAAAd,GACZ,IAAMV,EAAQD,EAAO/B,SAAS0C,EAAKnE,KAAMmE,EAAKzE,IAC9CwzB,EAAYvtB,KAAKlC,EACnB,IACAD,EAAOX,SAAWqwB,E,WAGd,YAAA5tB,aAAN,SAAmB9B,G,6EAIjB,OAHA,UAAO7C,IAAI,eAAgB,CAAE6C,OAAM,IAC7B9D,EAAK8D,EAAO9D,IACZmzB,EAAY3yB,KAAKmmB,eAAe9iB,WAAW7D,MAK3C4yB,EAAiBpyB,KAAKmmB,eAAe9iB,WAAWsvB,EAAUlzB,YAIhE2yB,EAAezvB,SAASoQ,OAAOqf,EAAezvB,SAASvC,QAAQuyB,GAAY,GAC3E3yB,KAAKmmB,eAAe7kB,c,KARlB,G,QAWE,YAAA2S,iBAAN,SAAuBzU,EAAkB8D,G,yGAGvC,GAFA,UAAO7C,IAAI,aAAc,CAAEjB,GAAE,EAAE8D,OAAM,MAC/Bua,EAAc7d,KAAKmmB,eAAe9iB,WAAW7D,IAEjD,MAAM,IAAI,EAAAyyB,yBAKZ,OAFMroB,EAAWtG,EAAOnC,SACf3B,GAAKA,EACd,GAAMoK,EAAS9F,UAAS,SAAMG,EAAMgvB,GAAY,qC,kCAC9ChvB,EAAKzE,KAAOQ,KAAKimB,UACjBhiB,EAAKxE,SAAWwzB,EAAazzB,G,qBAM/B,OARA,SAKAqe,EAAYlb,SAAWiH,EAASjH,SAEhC3C,KAAKmmB,eAAe7kB,cACb,CAAP,EAAOsI,G,QAGT,YAAAwT,QAAA,SAAQ/E,GACNrY,KAAKgL,OAAS,EAAH,GAAQqN,EACrB,EAEA,YAAA5I,QAAA,WACE,OAAO,EAAP,GAAYzP,KAAKgL,OACnB,EAGM,YAAAsT,YAAN,SAAkBC,G,YAAA,IAAAA,IAAAA,GAAA,G,6EAGZ,YAAA0B,WAAN,W,oFAGM,YAAAV,eAAN,W,oFAEA,YAAAlT,OAAA,WAEA,EAEA,YAAA4R,YAAA,WACE,OAAO/Z,QAAQC,SAAQ,EACzB,EACF,EAtOA,G,siBCfA,cACA,WAEA,0BA2FA,QA1FE,YAAAgjB,UAAA,SAAU7jB,GACR,IAAM4vB,EAAUlzB,KAAKmzB,iBAAiB7vB,GAEtC,OADmB,IAAI,EAAA8vB,WAAW,CAAC9oB,QAAQ,EAAM7F,eAAe,EAAM4uB,kBAAkB,IACtEC,MAAMJ,EAC1B,EAEA,YAAA9M,YAAA,SAAYa,GACV,IAMMsM,EANS,IAAI,EAAAC,UAAU,CAC3B/uB,eAAe,EACfgvB,cAAc,EACdJ,kBAAkB,EAClBK,eAAe,IAEKjO,MAAMwB,GAE5B,IAAKllB,MAAMwI,QAAQgpB,EAAO,GAAGtM,MAC3B,MAAM,IAAIhnB,MACR,gBAAkBgnB,GAItB,IAAMC,EAAa,IAAI,EAAA1jB,OAAO,CAAEhE,GAAI,EAAGG,MAAO,OAAQE,SAAU,EAAAX,aAAaE,SAC7E,IACEY,KAAK2zB,aAAaJ,EAAO,GAAGtM,KAAMC,E,CAClC,MAAO1mB,GACP,MAAM,IAAIP,MACR,gBAAkBO,EAAEmF,Q,CAGxB,OAAOuhB,CACT,EAEA,YAAAyM,aAAA,SAAaT,EAAS5vB,GAAtB,WAGE4vB,EACGnuB,SAAQ,SAAAujB,G,sCACHrkB,EACJ,QAA6B,IAAlBqkB,EAAK3kB,SACdM,EAAO,IAAI,EAAArD,SAAS,CAClBpB,GAAIoH,SAAS0hB,EAAK,MAAM,SACxB7oB,SAAU6D,EAAO9D,GACjBE,IAAK4oB,EAAK,MAAM,UAChB3oB,MAAO,SAA2D,KAAhB,QAA9B,EAAyB,QAAzB,EAAkB,QAAlB,EAAa,QAAb,EAAA2oB,EAAK3kB,gBAAQ,eAAG,UAAE,eAAEhE,aAAK,eAAG,UAAE,eAAG,UAAyD,QAA9B,EAAyB,QAAzB,EAAkB,QAAlB,EAAa,QAAb,EAAA2oB,EAAK3kB,gBAAQ,eAAG,UAAE,eAAEhE,aAAK,eAAG,UAAE,eAAG,SAAW,IAC5HE,SAAU,EAAAX,aAAaE,aAEpB,SAA2B,IAAhBkpB,EAAKhlB,OASrB,OARAW,EAAO,IAAI,EAAAT,OAAO,CAChBhE,GAAIoH,SAAmB,QAAV,EAAA0hB,EAAK,aAAK,eAAG,SAC1B3oB,MAAO,SAAyD,KAAhB,QAA5B,EAAuB,QAAvB,EAAgB,QAAhB,EAAW,QAAX,EAAA2oB,EAAKhlB,cAAM,eAAG,UAAE,eAAE3D,aAAK,eAAG,UAAE,eAAG,UAAuD,QAA5B,EAAuB,QAAvB,EAAgB,QAAhB,EAAW,QAAX,EAAA2oB,EAAKhlB,cAAM,eAAG,UAAE,eAAE3D,aAAK,eAAG,UAAE,eAAG,SAAW,IACxHF,SAAU6D,EAAO9D,GACjBK,SAAU,EAAAX,aAAaE,SAEzB,EAAKu0B,aAAarL,EAAKhlB,OAAQW,E,CAKjCX,EAAOX,SAAS8C,KAAKxB,EACvB,GACJ,EAEA,YAAAkvB,iBAAA,SAAiB7vB,GAAjB,WACE,OAAOA,EAAOX,SACXc,KAAI,SAAAF,GACH,OAAIA,aAAiB,EAAA3C,SACZ,CACL+C,SAAU,CACR,CAAChE,MAAO,CAAC,CAAC,QAAS4D,EAAM5D,UAE3B,KAAM,CACJ,SAAU4D,EAAM7D,IAChB,OAAQ8B,OAAO+B,EAAM/D,MAKvB+D,aAAiB,EAAAC,OACZ,CACLF,OAAQ,EAAF,CACJ,CAAC3D,MAAO,CAAC,CAAC,QAAS4D,EAAM5D,UACtB,EAAKwzB,iBAAiB5vB,IAAM,GAEjC,KAAM,EAAF,GACE,OAAQA,GAAS,CAAC,OAAQ/B,OAAO+B,EAAM/D,YAPjD,CAWF,GACJ,EACF,EA3FA,GA6FA,UAAe,IAAIo0B,C,8FCjGN,EAAA5T,OAA2B,oBAAXjG,QAA0B,IAAKzZ,IAAIyZ,OAAOla,SAASU,MAAO2iB,SAASzM,SAAS,O,6sDCWzG,iBAKE,WAAY8E,EAAoBsY,GAC9B7zB,KAAK0b,QAAUH,EACfvb,KAAK8zB,QAAUD,EAAaC,QAC5B9zB,KAAKqU,UAAYwf,EAAaxf,SAChC,CAoFF,OAlFE,YAAAhH,YAAA,WACE,MAAO,CACLiI,cAAe,CACb3R,SAAU,EAAF,GAAM3D,KAAKqU,UAAUiB,eAC7BhS,OAAQ,EAAF,GAAMtD,KAAK8zB,QAAQxe,gBAE3BW,cAAe,CACbtS,SAAU,EAAF,GAAM3D,KAAKqU,UAAU4B,eAC7B3S,OAAQ,EAAF,GAAMtD,KAAK8zB,QAAQ7d,gBAG/B,EAEM,YAAAjH,UAAN,SAAgB,G,IAAEC,EAAO,UAAEC,EAAQ,W,0EACjC6kB,EAASC,IAAIh0B,KAAK8zB,QAAS,CAAE7kB,QAAO,EAAEC,SAAQ,I,WAG1C,YAAA9J,aAAN,SAAmB,G,IAAE6J,EAAO,UAAEC,EAAQ,W,0EACpC6kB,EAAS5gB,OAAOnT,KAAK8zB,QAAS,CAAE7kB,QAAO,EAAEC,SAAQ,I,WAG7C,YAAAkG,YAAN,SAAkB,G,IAAEnG,EAAO,UAAEC,EAAQ,W,0EACnC6kB,EAASC,IAAIh0B,KAAKqU,UAAW,CAAEpF,QAAO,EAAEC,SAAQ,I,WAG5C,YAAA1M,eAAN,SAAqB,G,IAAEyM,EAAO,UAAEC,EAAQ,W,0EACtC6kB,EAAS5gB,OAAOnT,KAAKqU,UAAW,CAAEpF,QAAO,EAAEC,SAAQ,I,WAG/C,YAAA0P,QAAN,W,0FACE,SAAM5e,KAAK0b,QAAQuY,YAAY,CAC7BH,QAAS9zB,KAAK8zB,QACdzf,UAAWrU,KAAKqU,a,cAFlB,S,YAMa,EAAA2f,IAAf,SAAmBlpB,EAAU,G,IAAEmE,EAAO,UAAEC,EAAQ,WAC9C,QAAuB,IAAZD,QAA+C,IAAbC,EAC3C,MAAM,IAAIjP,MAAM,4BAElB6K,EAASmL,cAAchH,GAAWC,EAClCpE,EAASwK,cAAcpG,GAAYD,CACrC,EAEe,EAAAkE,OAAf,SAAsBrI,EAAU,G,IAAEmE,EAAO,UAAEC,EAAQ,WACjD,GAAID,GAAWC,GAAYpE,EAASmL,cAAchH,KAAaC,EAE7D,OADApE,EAAW9K,KAAKmT,OAAOrI,EAAU,CAAEmE,QAAO,IACnCjP,KAAKmT,OAAOrI,EAAU,CAAEoE,SAAQ,SAGlB,IAAZD,UACFnE,EAASwK,cAAcxK,EAASmL,cAAchH,WAC9CnE,EAASmL,cAAchH,YAEvBnE,EAASmL,cAAcnL,EAASwK,cAAcpG,WAC9CpE,EAASwK,cAAcpG,GAElC,EAEO,EAAA+D,MAAP,SAAa7F,EAAkCnJ,EAA4B0W,GACzE,OAAI1W,EAAKpE,WAAa8a,EACb1W,EAAKzE,GAEP4N,EAAiBnJ,EAAKpE,SAAW,KAAO8a,GAAQ1W,EAAKnE,MAAMmE,EAAKzE,GACzE,EAEO,EAAAwS,YAAP,SAAmB5E,EAAkCnJ,EAA4B0W,GAC/E,OAAI1W,EAAKpE,WAAa8a,EACb1W,EAAKxE,SAEP2N,EAAiBnJ,EAAKpE,SAAW,KAAO8a,GAAQrX,OAAOW,EAAKxE,SACrE,EAEO,EAAA4Q,SAAP,SAAgBjD,EAAmC8mB,EAA6BC,GAC9E,OAAIJ,EAAS9gB,MAAM7F,EAAkB8mB,EAAOC,EAAMt0B,YAAcs0B,EAAM30B,IAGlEu0B,EAAS9gB,MAAM7F,EAAkB+mB,EAAOD,EAAMr0B,YAAcq0B,EAAM10B,EAIxE,EACF,EA7FA,G,y4FCXA,kBACA,cACA,cACA,WACA,cACA,aAGA,cACA,cACA,WAMA,aAIA,cAUE,WAAYwL,GAAZ,MACE,YAAMA,IAAO,K,OACb,EAAKA,OAASA,EACd,EAAKuX,OAAS,GACd,EAAKE,gBAAkB,K,CACzB,CA4VF,OA3WwC,OAiB/B,EAAApH,iBAAP,WACE,MAAO,CACLvb,KAAM,MACNJ,IAAK,+BACLigB,SAAU,MACVC,SAAU,SACVwU,OAAQ,OACR1R,cAAe,iBACfC,mBAAoB,OACpBC,oBAAoB,EACpBC,gBAAgB,EAChB/F,cAAc,EAElB,EAEA,YAAAJ,SAAA,WACE,IAAMrE,EAAOrY,KAAKyP,UACZ/P,EAAM,IAAIY,IAAI+X,EAAK3Y,KAEzB,OADAA,EAAImM,SAAW,GACRwM,EAAK0E,OAAS1E,EAAKsH,SAAW,IAAMjgB,EAAIsyB,SAAW,IAAM3Z,EAAKqK,aACvE,EAEA,YAAAjT,QAAA,WACE,OAAO,EAAP,KAAY4kB,EAAWhZ,oBAAuBrb,KAAKgL,OACrD,EAEA,YAAAqB,OAAA,WACErM,KAAKujB,gBAAkBvjB,KAAKujB,gBAC9B,EAEM,YAAAjF,YAAN,SAAkBC,EAAiB8H,G,YAAjB,IAAA9H,IAAAA,GAAA,QAAiB,IAAA8H,IAAAA,GAAA,G,gHAGrB,OAFZ,UAAO5lB,IAAI,sBAEX,EAAAT,KAAY,GAAM,UAAOgB,OAAOC,KAAKC,UAAUlB,KAAKgL,U,cAApD,EAAKlK,KAAO,SAAmD4d,KAAKC,MACpE3e,KAAKs0B,IAAM,IAAMt0B,KAAKc,KAAO,IAEG,QAA5B,EAAAsW,UAAUC,cAAV,MACe,iDAAa,MAAgB,K,OAAxCwD,EAAW,SAAgChE,QAC7CyP,OAAc,EAAEjI,GAAQ,E,iBAET,O,sBAAA,GAAMxD,EAAQ0L,YAAYC,SAAS,CAAEC,QAAS,CAACzmB,KAAKgL,OAAOtL,IAAM,Q,cAAlF4mB,EAAiB,S,+BAEjBjI,GAAQ,EACRxU,QAAQC,KAAK,G,aAEf,IAAKuU,IAAUiI,EACb,MAAM,IAAI,EAAAI,wB,iBASd,OAHA1mB,KAAKu0B,GAAK,IAAI,UAAGv0B,KAAKc,KAAM,CAAC0zB,MAAM,IAEnC,UAAO/zB,IAAI,cACX,GAAMg0B,EAAI3W,KAAK,CAAEyW,GAAIv0B,KAAKu0B,GAAID,IAAKt0B,KAAKs0B,O,OACxC,OADA,SACA,GAAMG,EAAIC,UAAU,CAClBH,GAAIv0B,KAAKu0B,GACTD,IAAKt0B,KAAKs0B,IACV50B,IAAKM,KAAKgL,OAAOtL,IACjBi1B,OAAQ,SACRC,OAAO,K,OALT,S,mBAUE,O,yBADA,UAAOn0B,IAAI,2BACX,GAAMg0B,EAAI7P,MAAM,CACdiQ,KAAI,UACJN,GAAIv0B,KAAKu0B,GACTD,IAAKt0B,KAAKs0B,IACV10B,MAAM,EACNk1B,WAAW,EACXH,OAAQ,SACR7yB,MAAO,GACPizB,OAAQ,WAAM,SAAKA,QAAL,K,QAGhB,OAXA,SAUA,UAAOt0B,IAAI,yBAA4BT,KAAKgL,OAAa,QACzD,GAAMypB,EAAIO,SAAS,CAAET,GAAIv0B,KAAKu0B,GAAID,IAAKt0B,KAAKs0B,IAAKW,IAAKj1B,KAAKgL,OAAOopB,U,eAAlE,S,oCAES,EAAE5V,OAASiW,EAAIS,OAAOC,cAAc3W,MAAyB,SAAhB,EAAEnG,KAAK+c,MAAmB,EAAE/c,KAAK+c,OAASp1B,KAAKgL,OAAOopB,QAAU,EAAE/b,KAAK+c,OAAS,UAAYp1B,KAAKgL,OAAOopB,OAA1J,QACF,UAAO3zB,IAAI,mBAAqBT,KAAKs0B,IAAM,cAC3C,GAAMt0B,KAAKu0B,GAAGhK,SAAS6B,UAAUpsB,KAAKs0B,IAAM,aAAc,uFAAwF,CAACe,KAAM,IAAO/I,SAAU,W,QAE1K,OAFA,SACA,UAAO7rB,IAAI,eACX,GAAMg0B,EAAIT,IAAI,CAACO,GAAIv0B,KAAKu0B,GAAID,IAAKt0B,KAAKs0B,IAAKgB,SAAU,O,QAErD,OAFA,SACA,UAAO70B,IAAI,gBACX,GAAMg0B,EAAI3iB,OAAO,CACfyiB,GAAIv0B,KAAKu0B,GACTD,IAAKt0B,KAAKs0B,IACV3uB,QAAS,2BACT4vB,OAAQ,CACNhuB,KAAM,6B,QAGY,OARtB,SAQsB,GAAMktB,EAAIe,cAAc,CAACjB,GAAIv0B,KAAKu0B,GAAID,IAAKt0B,KAAKs0B,O,eAAhEkB,EAAgB,WACDA,IAAkBx1B,KAAKgL,OAAOopB,OACjD,GAAMK,EAAIgB,aAAa,CAAElB,GAAIv0B,KAAKu0B,GAAID,IAAKt0B,KAAKs0B,IAAKW,IAAKj1B,KAAKgL,OAAOopB,OAAQsB,OAAQF,KADpF,O,QACF,S,mBAGF,OADA,UAAO/0B,IAAI,cACX,GAAMg0B,EAAIhvB,KAAK,CACb8uB,GAAIv0B,KAAKu0B,GACTM,KAAI,UACJP,IAAKt0B,KAAKs0B,IACVW,IAAKj1B,KAAKgL,OAAOopB,OACjBuB,UAAW31B,KAAKgL,OAAOopB,OACvBO,OAAQ,SACRI,OAAQ,WAAM,SAAKA,QAAL,K,eAPhB,S,eAUA,MAAM,E,6BAIV,GAAqC,MAAjC/0B,KAAKgL,OAAO0X,cAAc,GAC5B,MAAM,IAAI,EAAAiE,W,OAGR3mB,KAAKyiB,iBACPsE,cAAc/mB,KAAKyiB,iBAEjB4D,EACF,GAAMrmB,KAAK41B,iBADT,O,QAEF,OADA,SACA,GAAM51B,KAAKqkB,W,eAAX,S,sBACS9F,EACT,GAAMve,KAAKgkB,cADF,O,QACT,S,mBAMa,OAJXzF,GAAY8H,KACdrmB,KAAKyiB,gBAAkBuE,aAAY,WAAM,SAAK3C,SAAL,GAjJzB,OAoJH,GAAMrkB,KAAKqlB,kB,QAEH,OAFjBzD,EAAS,SAEf,EAAA5hB,KAAuB,GAAMA,KAAKmmB,eAAerlB,MAAK,I,QAItD,OAJA,EAAKgmB,gBAAkB,SAEvB,UAAOrmB,IAAI,0BAEJ,CAAP,EAAOmhB,G,QAGH,YAAA3B,WAAN,W,0FAGE,OAFA,UAAOxf,IAAI,cACXsmB,cAAc/mB,KAAKyiB,iBACnB,GAAMziB,KAAKwkB,Y,cAAX,SACAqR,UAAUC,eAAe91B,KAAKc,M,YAG1B,YAAAye,eAAN,W,yGAKsB,OAJpB,UAAO9e,IAAI,kBACXsmB,cAAc/mB,KAAKyiB,iBAEnBziB,KAAKmmB,eAAiBnmB,KAAKmmB,eAAehlB,QACtB,GAAMnB,KAAKmmB,eAAerlB,MAAK,I,cAA/B,WACAd,KAAK8mB,gBAArB,QACIiP,EAAkD,SAAnC/1B,KAAKgL,OAAO2X,oBAoMnBuE,EApM8DlnB,KAAKmmB,eAqMjF/C,EAAS,kNAKbA,GACE,uBA3MmGpjB,KAAKimB,UA6MxG,yDAGF7C,GAAU,UAAe+D,UAAUD,GAEnC9D,GAAU,aAMZ,SAAoB8D,EAAYjB,GAC9B,IAAI7C,EAAS,qIAcb,OAVAA,GACE,uBACA6C,EACA,yDAGF7C,GAAU,UAAK+D,UAAUD,GAEzB9D,GAAU,SAGZ,CAxOyHgE,CAAWpnB,KAAKmmB,eAAgBnmB,KAAKimB,WACxJ,UAAOxlB,IAAI,mBAAqBT,KAAKs0B,IAAM,IAAMt0B,KAAKgL,OAAO0X,eAC7D,GAAM1iB,KAAKu0B,GAAGhK,SAAS6B,UAAUpsB,KAAKs0B,IAAM,IAAMt0B,KAAKgL,OAAO0X,cAAeqT,EAAc,CAACV,KAAM,IAAO/I,SAAU,W,OAEnH,OAFA,SACA,UAAO7rB,IAAI,eACX,GAAMg0B,EAAIT,IAAI,CAACO,GAAIv0B,KAAKu0B,GAAID,IAAKt0B,KAAKs0B,IAAKgB,SAAU,O,OAErD,OAFA,SACA,UAAO70B,IAAI,gBACX,GAAMg0B,EAAI3iB,OAAO,CACfyiB,GAAIv0B,KAAKu0B,GACTD,IAAKt0B,KAAKs0B,IACV3uB,QAAS,0BAAmB3F,KAAK0c,YACjC6Y,OAAQ,CACNhuB,KAAM,6B,OALV,S,iBAUE,O,uBADA,UAAO9G,IAAI,cACX,GAAMg0B,EAAIhvB,KAAK,CACb8uB,GAAIv0B,KAAKu0B,GACTM,KAAI,UACJP,IAAKt0B,KAAKs0B,IACVK,OAAQ,SACRC,OAAO,EACPG,OAAQ,WAAM,SAAKA,QAAL,K,cANhB,S,iCASMvW,MAAQ,EAAEA,OAASiW,EAAIS,OAAOc,kBAAkBxX,KACpD,GAAMxe,KAAKwkB,YADT,M,OAEF,MADA,SACM,IAAI,EAAAL,oB,iDAId,UAAO1jB,IAAI,8C,mBAGb,SAAMT,KAAKwkB,Y,eAAX,SACAqR,UAAUC,eAAe91B,KAAKc,M,IAiKlC,IAAoBomB,EACd9D,C,QA/JE,YAAAY,WAAN,W,oGACe,SAAMyQ,EAAIwB,SAAS,CAAE1B,GAAIv0B,KAAKu0B,GAAID,IAAKt0B,KAAKs0B,O,OAEzD,GAFM10B,EAAO,UACPs2B,EAAUt2B,EAAKqD,OAAOyC,UAAU9B,MAAK,SAACuyB,GAAQ,OAAAA,EAAItmB,WAAW,gBAAf,OAE5CumB,EAAa/E,OAAO6E,EAAQxxB,MAAM,KACpCga,KAAKC,MAAQyX,EArNF,KAsNb,MAAM,IAAI,EAAAjS,oBAId,SAAMnkB,KAAKqkB,W,cAAX,S,YAGI,YAAAA,QAAN,W,qGASE,OARArkB,KAAKskB,eAAkB,8B,+DAGrB,OAFM6R,EAAM,gBAAkBzX,KAAKC,MACnC,UAAOle,IAAI,aAAe01B,GAC1B,GAAM1B,EAAI0B,IAAI,CAAE5B,GAAIv0B,KAAKu0B,GAAID,IAAKt0B,KAAKs0B,IAAKW,IAAKkB,K,OAEjD,OAFA,SACA,UAAO11B,IAAI,kBAAoB01B,GAC/B,GAAM1B,EAAIhvB,KAAK,CAAE8uB,GAAIv0B,KAAKu0B,GAAIM,KAAI,UAAEP,IAAKt0B,KAAKs0B,IAAKW,IAAKkB,EAAKpB,OAAQ,WAAM,SAAKA,QAAL,K,cAA3E,SACA/0B,KAAKuiB,OAAO9c,KAAK0wB,G,WAEnB,GAAMn2B,KAAKskB,gB,cAAX,S,YAGI,YAAAyQ,OAAN,W,mEACE,MAAO,CAAP,EAAO,CAAEpV,SAAU3f,KAAKgL,OAAO2U,SAAUC,SAAU5f,KAAKgL,OAAO4U,U,QAG3D,YAAA4E,SAAN,W,oHACMxkB,KAAKskB,eACP,GAAMtkB,KAAKskB,gBADT,M,OACF,S,iBAEF,IAAKtkB,KAAKuiB,OAAO/d,OACf,U,2CAIkB,EAAAxE,KAAKuiB,O,wBAAL,YAAP4T,EAAG,KACZ,UAAO11B,IAAI,0BAA4B01B,GACvC,GAAM1B,EAAIhvB,KAAK,CAAE8uB,GAAIv0B,KAAKu0B,GAAIM,KAAI,UAAEP,IAAKt0B,KAAKs0B,IAAKW,IAAKkB,EAAK3Z,QAAQ,EAAMuY,OAAQ,WAAM,SAAKA,QAAL,MAF9D,M,OAE3B,S,wBAFgB,I,aAKlB,OADA/0B,KAAKuiB,OAAS,GACP,CAAP,GAAO,G,OAIP,O,WAFA,UAAO9hB,IAAI,gBACX,UAAOA,IAAI,GACJ,CAAP,GAAO,G,yBAIL,YAAAm1B,cAAN,SAAoBrB,G,YAAA,IAAAA,IAAAA,EAAA,M,wGAEL,OADbA,EAAKA,GAAMv0B,KAAKu0B,GACH,GAAME,EAAIwB,SAAS,CAAE1B,GAAE,EAAED,IAAKt0B,KAAKs0B,O,OAA1C10B,EAAO,SACPy2B,EAAWz2B,EAAKoD,QAAO,SAAAmzB,GAAO,OAAAA,EAAItmB,WAAW,gBAAf,I,IAClB,EAAAwmB,E,wBAAA,YAAPF,EAAG,KACZ,GAAM1B,EAAIhvB,KAAK,CAAE8uB,GAAE,EAAEM,KAAI,UAAEP,IAAKt0B,KAAKs0B,IAAKW,IAAKkB,EAAK3Z,QAAQ,EAAMuY,OAAQ,WAAM,SAAKA,QAAL,MADxD,M,OACxB,S,wBADgB,I,+BAKd,YAAA1P,eAAN,W,0GAImB,O,sBADf,UAAO5kB,IAAI,kBACI,GAAMT,KAAKu0B,GAAGhK,SAAS+L,SAASt2B,KAAKs0B,IAAM,IAAMt0B,KAAKgL,OAAO0X,cAAe,CAAE4J,SAAU,U,cAAvGyJ,EAAe,S,aAIf,O,SAFA/1B,KAAKulB,aAEE,CAAP,GAAO,G,OAGT,IAAKwQ,IAAkBA,EAAatf,SAAS,4CAA8Csf,EAAatf,SAAS,uCAC/G,MAAM,IAAI,EAAAkP,oBAIZ,IAAK,EAAL,EAAmB,EAAAoQ,EAAahsB,MAAM,MAAnB,eACjB,IADS8b,EAAI,MACJzlB,QAAQ,yBAAwB,EAAG,CACpC0lB,EAAWD,EAAKzlB,QAAQ,KAAO,EAC/B2lB,EAASF,EAAKG,YAAY,KAEhChmB,KAAKimB,UAAYrf,SAASif,EAAKK,UAAUJ,EAAUC,IACnD,K,CAIJ,OAAQ/lB,KAAKgL,OAAO2X,oBAClB,IAAK,OACH,UAAOliB,IAAI,oBACXT,KAAKmmB,eAAiB,UAAeC,YAAY2P,GACjD,MACF,IAAK,OACH,UAAOt1B,IAAI,oBACXT,KAAKmmB,eAAiB,UAAKC,YAAY2P,GACvC,MACF,QACE,MAAM,IAAI91B,MAAM,8BAIpB,MAAO,CAAP,GAAO,G,QAGH,YAAAs2B,YAAN,W,2GACe,SAAM,UAAOv1B,OAAOC,KAAKC,UAAUlB,KAAKgL,U,OAQrD,OARMlK,EAAO,SAAmD4d,KAAKC,MACrE3e,KAAKs0B,IAAM,IAAMxzB,EAAO,IAIlByzB,EAAK,IAAI,UAAGzzB,EAAM,CAAC0zB,MAAM,IAE/B,UAAO/zB,IAAI,cACX,GAAMg0B,EAAI3W,KAAK,CAAEyW,GAAE,EAAED,IAAKt0B,KAAKs0B,IAAKkC,cAAex2B,KAAKgL,OAAOopB,U,OAC/D,OADA,SACA,GAAMK,EAAIC,UAAU,CAClBH,GAAE,EACFD,IAAKt0B,KAAKs0B,IACV50B,IAAKM,KAAKgL,OAAOtL,IACjBi1B,OAAQ,SACRC,OAAO,K,OAET,OAPA,SAOA,GAAML,EAAGhK,SAAS6B,UAAUpsB,KAAKs0B,IAAM,aAAc,uFAAwF,CAACe,KAAM,IAAO/I,SAAU,U,OACrK,OADA,SACA,GAAMmI,EAAIT,IAAI,CAACO,GAAE,EAAED,IAAKt0B,KAAKs0B,IAAKgB,SAAU,O,OAC5C,OADA,SACA,GAAMb,EAAI3iB,OAAO,CACfyiB,GAAE,EACFD,IAAKt0B,KAAKs0B,IACV3uB,QAAS,2BACT4vB,OAAQ,CACNhuB,KAAM,6B,OAGY,OARtB,SAQsB,GAAMktB,EAAIe,cAAc,CAACjB,GAAE,EAAED,IAAKt0B,KAAKs0B,O,cAAvDkB,EAAgB,WACDA,IAAkBx1B,KAAKgL,OAAOopB,OACjD,GAAMK,EAAIgB,aAAa,CAAElB,GAAE,EAAED,IAAKt0B,KAAKs0B,IAAKW,IAAKj1B,KAAKgL,OAAOopB,OAAQsB,OAAQF,KAD3E,M,OACF,S,iBAEF,SAAMf,EAAIhvB,KAAK,CACb8uB,GAAE,EACFM,KAAI,UACJP,IAAKt0B,KAAKs0B,IACVW,IAAKj1B,KAAKgL,OAAOopB,OACjBuB,UAAW31B,KAAKgL,OAAOopB,OACvBO,OAAQ,SACRC,OAAO,EACPG,OAAQ,WAAM,SAAKA,QAAL,K,QAEhB,OAVA,SAUA,GAAMN,EAAI7P,MAAM,CACdiQ,KAAI,UACJN,GAAE,EACFD,IAAKt0B,KAAKs0B,IACV10B,MAAM,EACNk1B,WAAW,EACXH,OAAQ,SACR7yB,MAAO,GACPizB,OAAQ,WAAM,SAAKA,QAAL,K,QAEhB,OAVA,SAUA,GAAM/0B,KAAK41B,cAAcrB,I,eAAzB,S,YAEJ,EA3WA,CAAwC,W,0yDCnBxC,cACA,cAEA,cACA,WAOA,WAcMkC,EAAU,IAEhB,aAOE,WAAYzrB,GACVhL,KAAKgL,OAASA,EACdhL,KAAK02B,WAAa,IAAI,UAAO,CAAEC,YAAa,KAC5C32B,KAAKqjB,gBAAkB,IAAIuD,gBAC3B5mB,KAAKglB,YAAchlB,KAAKqjB,gBAAgB0B,MAC1C,CA4TF,OA1TS,EAAA1J,iBAAP,WACE,MAAO,CACLvb,KAAM,aACNJ,IAAK,sBACLigB,SAAU,MACVC,SAAU,SACVgX,aAAc,UACdhU,oBAAoB,EACpBC,gBAAgB,EAChB/F,cAAc,EAElB,EAEA,YAAAlN,gBAAA,SAAgB/L,GACd,IACE,MAAO,CAAC,SAAU,QAAS,OAAQ,eAAe4S,SAAS,IAAInW,IAAIuD,EAAGnE,KAAKmM,S,CAC3E,MAAOrL,GACP,OAAO,C,CAEX,EAEA,YAAA6L,OAAA,WACErM,KAAK0L,UAAW,EAChB1L,KAAKqjB,gBAAgBC,OACvB,EAEA,YAAAlG,QAAA,SAAQ/E,GACNrY,KAAKgL,OAAS,EAAH,GAAQqN,EACrB,EAEA,YAAA5I,QAAA,WACE,OAAO,EAAP,KAAYonB,EAAkBxb,oBAAuBrb,KAAKgL,OAC5D,EAEA,YAAA0R,SAAA,WACE,IAAMrE,EAAOrY,KAAKyP,UAClB,OAAO4I,EAAK0E,QAAU1E,EAAKsH,SAASlJ,SAAS,KAAO4B,EAAKsH,SAAW,OAAS,IAAIrf,IAAI+X,EAAK3Y,KAAKsyB,SAAW3Z,EAAKsH,SAAW,IAAM,IAAIrf,IAAI+X,EAAK3Y,KAAKsyB,SACpJ,EAEA,YAAAzS,eAAA,WACE,OAAOrb,QAAQC,aAAQ2mB,EACzB,EAEA,YAAA7K,WAAA,WACE,OAAO/b,QAAQC,aAAQ2mB,EACzB,EAEA,YAAAxM,YAAA,SAAYC,EAAoB8H,GAE9B,OADArmB,KAAK0L,UAAW,EACTxH,QAAQC,aAAQ2mB,EACzB,EAEM,YAAA1oB,eAAN,SAAqBuB,G,0FAEA,OADnB,UAAOlD,IAAI,qBAAsB,CAACkD,SAAQ,IACvB,GAAM3D,KAAK82B,YAC5B,OAAQ,gBACR,mBACA,CACEp3B,IAAKiE,EAASjE,IACd6H,KAAM5D,EAAShE,MACfo3B,WAAY,CACVv3B,GAAImE,EAASlE,a,OAGnB,MAAO,CAAP,EAVmB,SASf,SACYD,I,QAGZ,YAAA8C,eAAN,SAAqBqB,G,gGAEY,OAD/B,UAAOlD,IAAI,qBAAsB,CAACkD,SAAQ,IACX,GAAM3D,KAAK82B,YAAY,MAAO,8BAAuBnzB,EAASlE,Y,OAC7F,OADiBs3B,EAAc,SAAyE,SACxG,GAAM/2B,KAAK82B,YACT,MAAO,wBAAiBnzB,EAASnE,IACjC,mBACA,CACEA,GAAImE,EAASnE,GACbE,IAAKiE,EAASjE,IACd6H,KAAM5D,EAAShE,MACfC,KAAM,GACNm3B,WAAY,CACVv3B,GAAImE,EAASlE,SACb8H,KAAMwvB,EAAWxvB,KACjByvB,QAASD,EAAWC,Y,cAX1B,S,YAgBI,YAAAx0B,eAAN,SAAqBmB,G,0FAEnB,OADA,UAAOlD,IAAI,qBAAsB,CAACkD,SAAQ,IAC1C,GAAM3D,KAAK82B,YAAY,SAAU,wBAAiBnzB,EAASnE,M,cAA3D,S,YAGI,YAAA0F,aAAN,SAAmB5B,G,0FAEE,OADnB,UAAO7C,IAAI,2BAA4B,CAAC6C,OAAM,IAC3B,GAAMtD,KAAK82B,YAC5B,OAAQ,sBACR,mBACA,CACEvvB,KAAMjE,EAAO3D,MACbF,SAAU6D,EAAO7D,Y,OAErB,MAAO,CAAP,EAPmB,SAMf,SACYD,I,QAGZ,YAAA2F,aAAN,SAAmB7B,G,gGAEc,OAD/B,UAAO7C,IAAI,2BAA4B,CAAC6C,OAAM,IACf,GAAMtD,KAAK82B,YAAY,MAAO,8BAAuBxzB,EAAO9D,M,OAC3F,OADiBu3B,EAAc,SAAiE,SAChG,GAAM/2B,KAAK82B,YACT,MAAO,8BAAuBxzB,EAAO9D,IACrC,mBAAkB,OAEbu3B,GAAU,CACbxvB,KAAMjE,EAAO3D,MACbF,SAAU6D,EAAO7D,a,cANrB,S,YAUI,YAAA2F,aAAN,SAAmB9B,G,oGACjB,UAAO7C,IAAI,2BAA4B,CAAC6C,OAAM,IAC1C2zB,GAAU,EACVr1B,EAAQ,E,iBAIR,O,sBADAA,IACA,GAAM5B,KAAK82B,YAAY,SAAU,8BAAuBxzB,EAAO9D,M,cAA/D,SACAy3B,GAAU,E,aAEV,I,sBAAiB,EAAAtV,WAA0B,MAAb,EAAEC,OAC9BqV,GAAU,OACL,GAAIr1B,EAAQ,EACjB,MAAM,E,uBAIFq1B,EAAO,Y,mCAGb,YAAAroB,iBAAN,SAAuBsoB,G,+GACfC,EAAQ,G,iBAGI,SAAMn3B,KAAK82B,YAAY,MAAO,+BAAwBK,EAAM3yB,OAAS2yB,EAAMA,EAAM3yB,OAAS,GAAGhF,GAAK,M,OAA/GuiB,EAAa,SAAuG,SACvHoV,EAAM1xB,KAAI,MAAV0xB,EAAcpV,G,oBACa,IAApBA,EAASvd,OAAY,Y,iBAEI,SAAMxE,KAAK82B,YAAY,MAAO,wB,cAA9CM,EAAgB,SAAoD,UAElFC,EAAiBD,EAAYxzB,MAAK,SAAAmzB,GAAc,OAAAA,EAAWxvB,OAAS,EAAKyD,OAAO4rB,cAAwC,OAAxBG,EAAWt3B,QAA3D,KAChD,MAC4B,GAAMO,KAAK82B,YACvC,OAAQ,sBACR,mBACA,CACEvvB,KAAMvH,KAAKgL,OAAO4rB,gB,OAJVS,EAAkB,SAK1B,S,iBA0BN,MAAO,CAAP,GAvBMC,EAAY,SAACP,EAAYh3B,GAC7B,YAD6B,IAAAA,IAAAA,GAAA,GACtB,IAAI,EAAAyD,OAAO,CAChBhE,GAAIu3B,EAAWv3B,GACfG,MAAOo3B,EAAWxvB,KAClB9H,SAAUs3B,EAAWt3B,SACrBI,SAAU,EAAAX,aAAaE,OACvBW,OAAM,EACN4C,SAAUy0B,EACPp0B,QAAO,SAAAu0B,GAAO,OAAAA,EAAI93B,WAAas3B,EAAWv3B,EAA5B,IACdiE,IAAI6zB,GAAW9lB,OACd2lB,EACGn0B,QAAO,SAAAw0B,GAAQ,OAAAA,EAAKC,eAAiBV,EAAWv3B,EAAjC,IACfiE,KAAI,SAAA+zB,GAAQ,WAAI,EAAA52B,SAAS,CACxBpB,GAAIg4B,EAAKh4B,GACTG,MAAO63B,EAAKjwB,KACZ9H,SAAU+3B,EAAKC,aACf/3B,IAAK83B,EAAK93B,IACVG,SAAU,EAAAX,aAAaE,QALZ,MASvB,GAEiBi4B,GAAgB,I,QAG7B,YAAApZ,YAAN,W,mEACE,MAAO,CAAP,GAAO,E,QAGH,YAAA6Y,YAAN,SAAkBY,EAAaC,EAAe73B,EAAoB0nB,EAAiBoQ,G,YAArC,IAAA93B,IAAAA,EAAA,WAAoB,IAAA0nB,IAAAA,EAAA,WAAiB,IAAAoQ,IAAAA,GAAA,G,sHAKjF,GAJMl4B,EAAMM,KAAKgL,OAAOtL,IAAMi4B,EAE1BE,GAAW,EAEX/3B,GAAQA,EAAK2W,SAAS,oBACxB+Q,EAAOvmB,KAAKC,UAAUsmB,QACjB,GAAI1nB,GAAQA,EAAK2W,SAAS,qCAAsC,CAErE,IADMsC,EAAS,IAAI8W,gBACd,EAAL,EAA2B,EAAA/sB,OAAO0T,QAAQgR,GAAQ,CAAC,GAAxB,eAAhB,OAACngB,EAAG,KAAEkmB,EAAK,KACpBxU,EAAOhQ,IAAI1B,EAAKkmB,GAElB/F,EAAOzO,EAAOxS,U,CAKhB,GAFA,UAAO9F,IAAI,kBAAWi3B,EAAI,YAAIh4B,IAEE,QAA5B,EAAA0X,UAAUC,cACZ,MAAO,CAAP,EAAOrX,KAAK83B,kBAAkBJ,EAAMh4B,EAAKI,EAAM0nB,EAAMoQ,I,iBAI/C,O,sBAAA,GAAM53B,KAAK02B,WAAW1C,KAAI,WAE9B,OADA,UAAOvzB,IAAI,mBAAYi3B,EAAI,YAAIh4B,IACxBwE,QAAQ6zB,KAAK,CAClBnT,MAAMllB,EAAK,EAAF,CACPmiB,OAAQ6V,EACR7S,YAAa,EAAK7Z,OAAO4X,mBAAqB,UAAY,OAC1DsB,QAAS,EAAF,KACDpkB,GAAiB,wBAATA,GAAkC,CAAE,eAAgBA,IAAO,CACvEglB,cAAe,UAAY,EAAK9Z,OAAO4U,WAEzCmF,OAAQ,EAAKC,aACTwC,IAAS,CAAC,MAAO,QAAQ/Q,SAASihB,EAAK1gB,gBAAkB,CAAEwQ,KAAI,KAErE,IAAItjB,SAAQ,SAACC,EAASkW,GACpB,OAAA0J,YAAW,WACT8T,GAAW,EACXxd,EAAO,IAAI,EAAA2d,oBACb,GAAGvB,EAHH,KAMN,K,cApBAxS,EAAM,S,aAsBN,G,WAAI4T,EAAU,MAAM,EACpB,GAAI73B,KAAK0L,SAAU,MAAM,IAAI,EAAAoB,mBAE7B,MADAjD,QAAQpJ,IAAI,GACN,IAAI,EAAAinB,a,OAKZ,GAFA,UAAOjnB,IAAI,iCAA0Bi3B,EAAI,YAAIh4B,IAEzCukB,EAAIgU,aAAej4B,KAAKgL,OAAO6X,eACjC,MAAM,IAAI,EAAA8E,cAGZ,GAAIiQ,EACF,MAAO,CAAP,EAAO3T,GAGT,GAAmB,MAAfA,EAAIrC,OACN,MAAM,IAAI,EAAA0D,oBAEZ,GAAmB,MAAfrB,EAAIrC,QAAkBqC,EAAIrC,QAAU,IACtC,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQ8V,G,iBAIzB,O,sBAAA,GAAMzT,EAAItN,Q,cAAjBA,EAAO,S,aAEP,M,WAAM,IAAI,EAAAmL,mBAAmB,EAAEnc,S,OAGjC,MAAO,CAAP,EAAOgR,G,QAGK,YAAAmhB,kBAAd,SAAgCJ,EAAch4B,EAAaI,EAAc0nB,EAAWoQ,G,2GAE9EC,GAAW,E,iBAEP,O,sBAAA,GAAM73B,KAAK02B,WAAW1C,KAAI,WAE9B,OADA,UAAOvzB,IAAI,mBAAYi3B,EAAI,YAAIh4B,IACxBwE,QAAQ6zB,KAAK,CAClB,gBAAK7S,QAAQ,EAAD,CACVxlB,IAAG,EACHmiB,OAAQ6V,EACRQ,kBAAmB,EAAKltB,OAAO6X,eAC/BqB,QAAS,EAAF,KACDpkB,GAAiB,wBAATA,GAAkC,CAAE,eAAgBA,IAAO,CACvEglB,cAAe,UAAY,EAAK9Z,OAAO4U,WAEzCoI,aAAc,QACVR,IAAS,CAAC,MAAO,QAAQ/Q,SAASihB,EAAK1gB,gBAAkB,CAAEqB,KAAMmP,KAEvE,IAAItjB,SAAQ,SAACC,EAASkW,GACpB,OAAA0J,YAAW,WACT8T,GAAW,EACXxd,EAAO,IAAI,EAAA2d,oBACb,GAAGvB,EAHH,KAMN,K,cArBAxS,EAAM,S,aAuBN,G,WAAI4T,EAAU,MAAM,EAEpB,MADAhuB,QAAQpJ,IAAI,GACN,IAAI,EAAAinB,a,OAKZ,GAFA,UAAOjnB,IAAI,iCAA0Bi3B,EAAI,YAAIh4B,IAEzCukB,EAAIrC,OAAS,KAAOqC,EAAIrC,QAAU,IACpC,MAAM,IAAI,EAAA+F,cAGZ,GAAIiQ,EACF,MAAO,CAAP,EAAO3T,GAGT,GAAmB,MAAfA,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAC5B,MAAM,IAAI,EAAA0D,oBAEZ,GAAmB,MAAfrB,EAAIrC,QAAkBqC,EAAIrC,QAAU,IACtC,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQ8V,GAIlC,MAAO,CAAP,EAFazT,EAAI5L,M,QAIrB,EAxUA,G,mMCpBA,MAAM8f,EAAc,IAAIC,KAET,MAAMC,EACnBpoB,WAAAA,CAAYzQ,GACVQ,KAAK6Y,UAAYrZ,CACnB,CAEA,wBAAa8pB,CAAYgP,EAAW52B,EAAI62B,SAChCJ,EAAY9a,QAAQib,GAAW1O,UACnC,IAAIE,QAAcuO,EAAqB9W,SAAS+W,EAAWC,GAC3DzO,EAAQpoB,EAAGooB,SAELT,EAAAA,YAAQtgB,IAAI,CAAE1B,IAAKixB,EAAW/K,MAAOtsB,KAAKC,UAAU4oB,IAAS,GAEvE,CAEA,qBAAavI,CAAS+W,EAAWC,GAC/B,IAAIzO,QAAcT,EAAAA,YAAQxN,IAAI,CAACxU,IAAKixB,IACpC,IACE,GAAIxO,EAAMyD,MAAO,CACf,KAA8B,iBAAhBzD,EAAMyD,OAClBzD,EAAMyD,MAAQtsB,KAAKwkB,MAAMqE,EAAMyD,OAEjC,OAAOzD,EAAMyD,KACf,CACE,OAAOgL,CAEX,CAAE,MAAO/3B,GAGP,OAFAyoB,EAAAA,QAAOxoB,IAAI,wDAA0DD,EAAEmF,SACvEkE,QAAQwU,MAAM7d,GACP+3B,CACT,CACF,CAEA,kBAAOC,CAAYF,GACjB,OAAOjP,EAAAA,YAAQlW,OAAO,CAAC9L,IAAKixB,GAC9B,CAEA,2BAAanY,GACX,IAAIhE,QAAiBkc,EAAqB9W,SAAS,WAAY,CAAC,GAChE,OAAOze,OAAO+B,KAAKsX,EACrB,CAEA,oBAAM6E,CAAe3Z,GACnB,IACIgR,SADiBggB,EAAqB9W,SAAS,WAAY,CAAC,IAC5CvhB,KAAK6Y,WAYzB,OAXIxR,IACEgR,EAAKvQ,IACPuQ,EAAKuH,eAAiB6Y,EAAAA,EAAoB/wB,WAAWL,EAAKgR,EAAKvQ,GAAIuQ,EAAKuH,iBACjEvH,EAAKvQ,KAEZuQ,EAAKuH,eAAiB8Y,IAAAA,WAAwBrxB,EAAKgR,EAAKuH,SAAUvH,EAAKsH,UACnEtH,EAAKtR,aACPsR,EAAKtR,iBAAmB2xB,IAAAA,WAAwBrxB,EAAKgR,EAAKtR,WAAYsR,EAAKsH,aAI1EtH,CACT,CAEA,oBAAMkF,CAAelF,EAAMhR,GACzB,IAAIsxB,EAAUtgB,EAWd,OAVIhR,IACEgR,EAAKvQ,WACAuQ,EAAKvQ,GAEd6wB,EAAU,IACLtgB,EACHuH,eAAgB8Y,IAAAA,WAAwBrxB,EAAKgR,EAAKuH,SAAUvH,EAAKsH,aAC7DtH,EAAKtR,YAAc,CAACA,iBAAkB2xB,IAAAA,WAAwBrxB,EAAKgR,EAAKtR,WAAYsR,EAAKsH,aAG1F0Y,EAAqB/O,YAC1B,YACAnN,IACEA,EAASnc,KAAK6Y,WAAa8f,EACpBxc,IAET,CAAC,EAEL,CAEA,uBAAMM,SACE4b,EAAqB/O,YAAY,YAAYnN,WAC1CA,EAASnc,KAAK6Y,WACdsD,WAEHnc,KAAK44B,oBACL54B,KAAK64B,gBACb,CAEA,eAAMzX,SACEiX,EAAqB/O,YACzB,aAAatpB,KAAK6Y,oBAClB,KAAM,CAAG,IAEb,CAEA,cAAMgG,GACJ,MAAMxG,QAAaggB,EAAqB9W,SACtC,aAAavhB,KAAK6Y,oBAEpB,OAAOrV,EAAAA,OAAOf,QAAQ4V,GAAQvV,OAAO+B,KAAKwT,GAAM7T,OAAS6T,EAAO,CAACxY,SAAUX,EAAAA,aAAaC,OAC1F,CAEA,cAAMmgB,CAASjH,SACPggB,EAAqB/O,YACzB,aAAatpB,KAAK6Y,oBAClB,IAAMR,GAEV,CAEA,iBAAMugB,SACEP,EAAqBG,YAAY,aAAax4B,KAAK6Y,mBAC3D,CAEA,kBAAMsI,SACEkX,EAAqB/O,YACzB,aAAatpB,KAAK6Y,uBAClB,KAAM,CAAG,IAEb,CAEA,iBAAM6E,GACJ,MAAMrF,QAAaggB,EAAqB9W,SACtC,aAAavhB,KAAK6Y,uBAEpB,OAAO,IAAIkb,IAAJ,CACL/zB,KACAqY,GAAQvV,OAAO+B,KAAKwT,GAAM7T,OACtB6T,EACA,CACAhE,UAAW,CACTiB,cAAe,CAAC,EAChBW,cAAe,CAAC,GAElB6d,QAAS,CACPxe,cAAe,CAAC,EAChBW,cAAe,CAAC,IAI1B,CAEA,iBAAMge,CAAY5b,SACVggB,EAAqB/O,YACzB,aAAatpB,KAAK6Y,uBAClB,IAAMR,GAEV,CAEA,oBAAMwgB,SACER,EAAqBG,YAAY,aAAax4B,KAAK6Y,sBAC3D,CAEA,4BAAMiG,GACJ,OAAOuZ,EAAqB9W,SAAS,aAAavhB,KAAK6Y,0BACzD,CAEA,4BAAM2G,CAAuBT,SACrBsZ,EAAqB/O,YAAY,aAAatpB,KAAK6Y,2BAA4BigB,GAAM/Z,GAAc,KAC3G,E,+nBCzKF,cACA,cAEA,cACA,cAEa,EAAAxM,WAAa,CACxBjF,OAAQ,SACRC,OAAQ,SACRC,KAAM,OACNC,OAAQ,SACRC,QAAS,WAkEX,iBAGE,aACE1N,KAAK+4B,QAAU,EACjB,CAkMF,OAhME,YAAA53B,MAAA,SAAM6B,QAAA,IAAAA,IAAAA,EAAA,WAAoC,WACxC,IAAMg2B,EAA4B,IAAIC,EAOtC,OANAj5B,KAAKqO,aAAatJ,SAAQ,SAACwK,GACrBvM,EAAOuM,IACTypB,EAAQlnB,OAAOvC,EAEnB,IAEOypB,CACT,EAEA,YAAAlnB,OAAA,SAAOvC,GACLvP,KAAK+4B,QAAQtzB,KAAK,EAAD,GAAM8J,GACzB,EAEA,YAAAyE,QAAA,SAAQzE,GACNvP,KAAK+4B,QAAQhmB,OAAO/S,KAAK+4B,QAAQ34B,QAAQmP,GAAS,EACpD,EAEA,YAAAlB,WAAA,WACE,MAAO,GAAGmD,OACRxR,KAAK+4B,QAET,EAEO,EAAAnnB,UAAP,SACExE,EACA2rB,EAAiDG,EACjDC,EACAC,EACAC,QAAA,IAAAA,IAAAA,EAAA,IAEA,IAAMC,EAAmBJ,EAAS71B,WAAW,UAAS4P,MAAM7F,EAAkBgsB,EAAazxB,QAASuxB,EAASr5B,WAC7G,GACEu5B,EAAazxB,QAAQpG,SAAS,EAAAlC,SAASC,OACrC,UAAS0S,YAAY5E,EAAkB+rB,EAAaC,EAAazxB,QAAQ9H,YAC1Ey5B,GAAoBA,EAAiBj2B,WAAW,UAAS2O,YAAY5E,EAAkB+rB,EAAaD,EAASr5B,WAE9G,OAAO,EAET,IAAM05B,EAAoBR,EAAQ/1B,QAAO,SAAAo2B,GACvC,OAACC,EAAM5iB,SAAS2iB,KACdA,EAAazxB,QAAQpG,SAAS,EAAAlC,SAASC,OAAQ,UAAS0S,YAAY5E,EAAkB+rB,EAAaC,EAAazxB,QAAQ9H,YAEtHq5B,EAAS71B,WAAW,UAAS4P,MAAM7F,EAAkBgsB,EAAazxB,QAASuxB,EAASr5B,YACpFq5B,EAAS71B,WAAW,UAAS4P,MAAM7F,EAAkBgsB,EAAazxB,QAASuxB,EAASr5B,WAAWwD,WAAW,UAAS2O,YAAY5E,EAAkB+rB,EAAaD,EAASr5B,WAJ3K,IAOF,GAAI05B,EAAkB/0B,OACpB,IAA+B,UAAA+0B,EAAA,eAAmB,CAA7C,IAAMC,EAAgB,KACzB,GAAIP,EAAKrnB,UAAUxE,EAAkB2rB,EAASG,EAAUM,EAAiB7xB,QAASyxB,EAAc,EAAF,KAAMC,GAAO,GAAF,CAAEG,IAAgB,IACzH,OAAO,C,CAIb,OAAO,CACT,EAEO,EAAA5lB,UAAP,SAAqEmlB,EAA+BzzB,GAClG,IAeIqO,EAfEU,EAAY0kB,EAAQ/1B,QAAO,SAAAE,GAAK,OAAAA,EAAEyE,QAAQ7H,OAAS,EAAAT,SAASE,QAA5B,IAChCk6B,EAAcV,EAAQ/1B,QAAO,SAAAE,GAAK,OAAAA,EAAEyE,QAAQ7H,OAAS,EAAAT,SAASC,MAA5B,IAClCo6B,EAAMD,EACTr1B,QAAO,SAACs1B,EAAKC,GAUZ,OATAD,EAAIC,EAAQhyB,QAAQnI,IAAMi6B,EAAYz2B,QAAO,SAAA42B,GAC3C,OAAID,IAAYC,GAAWp4B,OAAOm4B,EAAQhyB,QAAQnI,MAAQgC,OAAOo4B,EAAQjyB,QAAQnI,KAI9E8F,EAAK/D,SAASo4B,EAAQhyB,QAAQ7H,KAAM65B,EAAQhyB,QAAQnI,KAAO8F,EAAK/D,SAASo4B,EAAQhyB,QAAQ7H,KAAM65B,EAAQhyB,QAAQnI,IAAI+B,SAASq4B,EAAQjyB,QAAQ7H,KAAM85B,EAAQjyB,QAAQnI,GAEvK,IACGiE,KAAI,SAAAP,GAAK,OAAAA,EAAEyE,QAAQnI,EAAV,IACLk6B,CACT,GAAG,CAAC,GAEN,IACE/lB,GAAU,aAAiB+lB,GAAKj2B,KAAI,SAAAoQ,GAAS,OAAAA,EAAMpQ,KAAI,SAAAjE,GAAM,OAAAi6B,EAAY71B,MAAK,SAAAV,GAAK,OAAA1B,OAAO0B,EAAEyE,QAAQnI,MAAQgC,OAAOhC,EAAhC,GAAtB,GAAhB,G,CAC7C,MAAOgB,GAEP,MADAqJ,QAAQpJ,IAAI,CAACi5B,IAAG,EAAEp0B,KAAI,EAAEyzB,QAAO,IACzBv4B,C,CAIR,OAFAmT,EAAQlO,KAAK4O,GACbV,EAAQjO,UACDiO,CACT,EAUA,YAAAlQ,IAAA,SAA8B2J,EAAkChB,EAAoBpJ,EAA2C62B,QAA3C,IAAA72B,IAAAA,EAAA,WAAqC,gBAAM,IAAA62B,IAAAA,GAAA,GAC7H,IAAMb,EAA6C,IAAIC,EAqEvD,OAlEAj5B,KAAKqO,aACF5K,KAAI,SAAAP,GAAK,OAAAA,CAAA,IACT6B,SAAQ,SAAAwK,GACP,IAAI+E,EAEJ,GAAKtR,EAAOuM,GAAZ,CAKA,IAAMY,EAAUZ,EAAOY,QAKvB,GAAIA,GAAW/D,IAAmB,EAAAlN,aAAaE,OAAQ,CACrD,IAAM06B,EAAQvqB,EAAOY,QAAQ3Q,GACvByS,EAAQ1C,EAAO5H,QAAQnI,IAC7B8U,EAAY,EAAH,KACJ/E,GAAM,CACT5H,QAAS4H,EAAO5H,QAAQtG,mBAAkB,EAAO+K,GACjD+D,QAASZ,EAAOY,QAAQ9O,mBAAkB,EAAOkO,EAAO5H,QAAQ9H,aAExD8H,QAAQnI,GAAKs6B,EACvBxlB,EAAUnE,QAAQ3Q,GAAKyS,C,MAEvBqC,EAAY,EAAH,KACJ/E,GAAM,CACT5H,QAAS4H,EAAO5H,QAAQtG,mBAAkB,EAAO+K,GACjD+D,QAASZ,EAAO5H,QAAQxG,OAAM,MAEtBwG,QAAQnI,GAAK,UAASyT,MAAM7F,EAAkBmC,EAAO5H,QAASyE,GAG1E,GAAI+D,GAAW/D,IAAmB,EAAAlN,aAAaE,QAAUmQ,EAAOzP,OAAS,EAAAyS,WAAW/E,KAClF8G,EAAUnE,QAAQ1Q,SAAW8P,EAAO5H,QAAQlI,SAC5C6U,EAAU3M,QAAQlI,SAAW,UAASuS,YAAY5E,EAAkBmC,EAAOY,QAAS/D,QAIpF,GAFAkI,EAAUnE,QAAQ1Q,SAAW8P,EAAO5H,QAAQlI,SAC5C6U,EAAU3M,QAAQlI,SAAW,UAASuS,YAAY5E,EAAkBmC,EAAO5H,QAASyE,QAC1C,IAA/BkI,EAAU3M,QAAQlI,eAA+D,IAA5B8P,EAAO5H,QAAQlI,SAA0B,CACvG,GAAIo6B,EAIF,OAFA,UAAOp5B,IAAI,2BAA6B8O,EAAO5H,QAAQlI,eACvD,UAAOgB,IAAI,kCAAmC8O,GAG9C,UAAO9O,IAAI,sBAAwB8O,EAAO5H,QAAQ9H,SAAW,uBAAyBuM,GACtF,IAAMgC,EAAO,IAAI6qB,EAIjB,MAHA7qB,EAAK0D,OAAOvC,GACZ,UAAO9O,IAAI,oCAAsC2N,EAAKvM,WACtD,UAAOpB,IAAIQ,KAAKC,UAAUkM,EAAkB,KAAK,OAC3C,IAAInN,MAAM,6BAA+BmM,EAAiB,KAAOmD,EAAO5H,QAAQlI,S,CAKxF8P,EAAOzP,OAAS,EAAAyS,WAAW7E,UAC7B4G,EAAUylB,SAAWxqB,EAAO2E,MAC5BI,EAAUJ,MAAQ3E,EAAO2E,MAAMzQ,KAAI,SAAAQ,GACjC,OAAO,EAAP,KAAWA,GAAI,CAAEzE,GAAI4N,GAAkBhB,IAAmB,EAAAlN,aAAaC,MAAQ,EAAAD,aAAaE,OAAS,EAAAF,aAAaC,OAAS,KAAOiN,GAAgBnI,EAAKnE,MAAMmE,EAAKzE,KACpK,KAGFw5B,EAAQlnB,OAAOwC,E,CACjB,IACK0kB,CACT,EAEA,YAAA5iB,OAAA,WACE,OAAOpW,KAAKqO,aAAa5K,KAAI,SAAC8L,GAC5B,OAAO,EAAP,KACKA,GAAM,CACT5H,QAAS4H,EAAO5H,QAAQxG,OAAM,GAC9BgP,QAASZ,EAAOY,SAAWZ,EAAOY,QAAQhP,OAAM,IAEpD,GACF,EAEA,YAAAU,QAAA,SAAQC,GACN,YADM,IAAAA,IAAAA,EAAA,GACC,SAAW9B,KAAKqO,aAAa5K,KAAI,SAAC8L,GACvC,MAAO,oBAAaA,EAAOzP,KAAI,uBAAeyP,EAAO5H,QAAQnI,GAAE,YAAI+P,EAAO5H,QAAQhI,MAAK,YAAI,QAAS4P,EAAO5H,QAAU,WAAI4H,EAAO5H,QAAQjI,IAAG,KAAM,GAAE,sBAAc6P,EAAO5H,QAAQlI,SAAQ,YAAI,UAAW8P,EAAS,iBAAUA,EAAO1M,MAAK,MAAO,IAAE,OAAG,UAAW0M,EAAS,iBAAUtO,KAAKC,UAAUqO,EAAO2E,MAAO,KAAM,OAAU,GAC/T,IAAGjS,KAAK,KACV,EAEO,EAAAyU,SAAP,SAA+FC,GAC7F,IAAMvI,EAAyB,IAAI6qB,EAMnC,OALAtiB,EAAK5R,SAAQ,SAACwK,GACZA,EAAO5H,SAAU,IAAAlF,SAAY8M,EAAO5H,SACpC4H,EAAOY,QAAUZ,EAAOY,UAAW,IAAA1N,SAAY8M,EAAOY,SACtD/B,EAAK0D,OAAOvC,EACd,IACOnB,CACT,EACF,EAvMA,G,ysEC7EA,IAaI4rB,EAbJ,aACA,cACA,aAEA,cACA,cACA,UAEA,YACA,aACA,WACA,WAIA,aAcE,WAAYte,EAAiBue,GAA7B,WACEj6B,KAAKi6B,OAASA,EACdj6B,KAAK0b,QAAUA,EACf1b,KAAKk6B,MAAQ,IAAI,UAAO,CAAEvD,YAAa,KACvC32B,KAAKm6B,oBAAsBC,EAAYC,wBAAwBxiB,MAAK,SAAAiC,GAClE,EAAKkgB,aAAelgB,CACtB,GACF,CA+VF,OA7VQ,YAAAlL,iBAAN,W,6GAC2B,UAAM,IAAAoe,c,OAAzBsN,EAAmB,S,iBAGd,O,sBAAA,GAAM,UAAQjmB,UAAUoU,WAAWzoB,KAAKi6B,S,cAAhD30B,EAAQ,SAA+C,G,aAExD,M,SAAM,IAAI,EAAAi1B,yB,OAEZ,SAAMv6B,KAAKm6B,qB,OACgB,OAD3B,SAC2B,GAAM,UAAQve,mB,OAArB,SAAO,SAAiCuE,kB,OAoF5D,OApFME,EAAc,SAoFb,CAAP,GAlFMma,EAAU,SAAClS,EAAM7oB,EAAWg7B,EAAcC,GAE9C,IACEra,EAAYngB,MACV,SAAAiO,GAAO,OAAAA,EAAIsB,UAAUkN,YAAc2L,EAAK9oB,IAAMgC,OAAO8mB,EAAK9oB,MAAQgC,OAAO,EAAKy4B,UAAY9rB,EAAIsB,UAAUoN,UAAjG,IAFX,CAQA,IAAI8d,EAAe56B,EAAQ66B,EAC3B,GAAItS,EAAK7oB,WAAa,EAAKu6B,aAAax6B,KAAO86B,EAAkB,CAC/D,OAAQhS,EAAK9oB,IACX,IAAK,IACL,IAAK,eACHm7B,EAAgBP,EAAYS,oBAC5BD,GAAY,EACZ,MACF,IAAK,IACL,IAAK,eACHD,EAAgBP,EAAYU,sBAC5B,MACF,IAAK,eACHH,EAAgBP,EAAYW,qBAC5B,MACF,IAAK,eACHJ,EAAgBP,EAAYY,uBAE5BL,GACF,UAAOl6B,IACL,oCACA6nB,EAAK9oB,GACL8oB,EAAK3oB,MACL,KACAg7B,E,CAON,GAHIrS,EAAK9oB,KAAO,EAAKw6B,aAAax6B,KAChCO,GAAS,GAEPuoB,EAAK3lB,SAAU,CAIjB,IAAM,EAAM,UAAOxB,OAAM,aAAWmnB,EAAK3oB,QACnC2D,EAAS,IAAImvB,EAAKjvB,OAAO,CAC7B3D,SAAU,EAAAX,aAAaC,MACvBK,GAAI8oB,EAAK9oB,GACTC,SAAQ,EACRE,MAAOF,EAAWk7B,GAAiBrS,EAAK3oB,WAAQmrB,EAChDnoB,SAAU2lB,EAAK3lB,SACZc,KAAI,SAACF,GACJ,OAAOi3B,EAAQj3B,EAAO+kB,EAAK9oB,GAAIo7B,EAAW,EAC5C,IACC53B,QAAO,SAAAO,GAAS,QAAEA,CAAF,MAGrB,OADAD,EAAOvD,OAASA,EACTuD,C,CACF,MAA+B,mBAA3BsI,KAAK/L,SAASgM,UAA+C,cAAdyc,EAAKxoB,KAEtD,IAAI2yB,EAAK7xB,SAAS,CACvBf,SAAU,EAAAX,aAAaC,MACvBK,GAAI8oB,EAAK9oB,GACTC,SAAQ,EACRE,MAAO86B,EAAcL,EAAYa,qBAAuBb,EAAYc,qBAGpEx7B,IAAK,kCACC+6B,EAAc,gBAAkB,IACjC,cAAOC,EAAIS,IAAI,EAAE,QAGjB,IAAI1I,EAAK7xB,SAAS,CACvBf,SAAU,EAAAX,aAAaC,MACvBK,GAAI8oB,EAAK9oB,GACTC,SAAQ,EACRE,MAAO2oB,EAAK3oB,MACZD,IAAK4oB,EAAK5oB,K,CAGhB,GACe4F,I,QAGX,YAAAlD,eAAN,SAAqBuB,G,uGAEnB,GADA,UAAOlD,IAAI,gBAAiBkD,GACxBA,EAASlE,WAAaO,KAAKg6B,aAAax6B,GAE1C,OADA,UAAOiB,IAAI,oDACX,I,8CAG+B,mBAA3BmL,KAAK/L,SAASgM,UAAoE,0BAAnC,IAAIvL,IAAIqD,EAASjE,KAAKsyB,SAArE,MACW,GAAMhyB,KAAKk6B,MAAMlG,KAAI,gD,2BAEhC,OADA,UAAOvzB,IAAI,mCAAoCkD,GACxC,CAAP,EAAO,UAAQ0Q,UAAU4H,OAAO,CAC9Bxc,SAAUkE,EAASlE,SAAS8G,WAC5BzG,KAAM,c,kBAGV,MAAO,CAAP,EAPa,SAODN,I,OAED,SAAMQ,KAAKk6B,MAAMlG,KAAI,gD,2BAEhC,OADA,UAAOvzB,IAAI,mCAAoCkD,GACxC,CAAP,EAAO,UAAQ0Q,UAAU4H,OAAO,CAC9Bxc,SAAUkE,EAASlE,SAAS8G,WAC5B5G,MAAOgE,EAAShE,MAChBD,IAAKiE,EAASjE,M,kBAGlB,MAAO,CAAP,EARa,SAQDF,I,OAEZ,M,WAAM,IAAIS,MAAM,oBAAsB0D,EAAS9B,UAAY,KAAO,EAAE8D,S,yBAIlE,YAAArD,eAAN,SAAqBqB,G,uGAEnB,GADA,UAAOlD,IAAI,gBAAiBkD,GACxBA,EAASlE,WAAaO,KAAKg6B,aAAax6B,GAE1C,OADA,UAAOiB,IAAI,oDACX,I,8CAG+B,mBAA3BmL,KAAK/L,SAASgM,UAAoE,0BAAnC,IAAIvL,IAAIqD,EAASjE,KAAKsyB,SAArE,M,aAGF,SAAMhyB,KAAKk6B,MAAMlG,KAAI,gD,2BAEnB,OADA,UAAOvzB,IAAI,mCAAoCkD,GACxC,CAAP,EAAO,UAAQ0Q,UAAU+mB,OAAOz3B,EAASnE,GAAI,CAC3CG,MAAOgE,EAAShE,MAChBD,IAAKiE,EAASjE,M,kBAJlB,S,iBAQF,SAAMM,KAAKk6B,MAAMlG,KAAI,gD,2BAEnB,OADA,UAAOvzB,IAAI,iCAAkCkD,GACtC,CAAP,EAAO,UAAQ0Q,UAAUnB,KAAKvP,EAASnE,GAAI,CACzCC,SAAUkE,EAASlE,SAAS8G,a,yBAHhC,S,aAOA,M,WAAM,IAAItG,MAAM,oBAAsB0D,EAAS9B,UAAY,KAAO,EAAE8D,S,yBAIlE,YAAAnD,eAAN,SAAqBmB,G,yGACnB,GAAIA,EAASlE,WAAaO,KAAKg6B,aAAax6B,GAE1C,OADA,UAAOiB,IAAI,oDACX,IAEI46B,EAAa13B,EAASnE,GAC5B,UAAOiB,IAAI,gBAAiBkD,G,iBAE1B,O,sBAAA,GAAM3D,KAAKk6B,MAAMlG,KAAI,gD,2BAEnB,OADA,UAAOvzB,IAAI,mCAAoCkD,GACxC,CAAP,EAAO,UAAQ0Q,UAAUlB,OAAOkoB,G,yBAFlC,S,+BAKA,UAAO56B,IAAI,oBAAsBkD,EAAS9B,UAAY,KAAO,EAAE8D,QAAU,gB,+BAIvE,YAAAT,aAAN,SAAmB5B,G,2GAGjB,GAFO7D,EAAmB6D,EAAM,SAAf3D,EAAS2D,EAAM,MAChC,UAAO7C,IAAI,sBAAuB6C,GAC9BA,EAAO7D,WAAaO,KAAKg6B,aAAax6B,GAExC,OADA,UAAOiB,IAAI,oDACX,I,iBAGa,O,sBAAA,GAAMT,KAAKk6B,MAAMlG,KAAI,gD,2BAEhC,OADA,UAAOvzB,IAAI,yCAA0C6C,GAC9C,CAAP,EAAO,UAAQ+Q,UAAU4H,OAAO,CAC9Bxc,SAAUA,EAAS8G,WACnB5G,MAAK,I,kBAGT,MAAO,CAAP,EAPa,SAODH,I,OAEZ,M,WAAM,IAAIS,MAAM,oBAAsBqD,EAAOzB,UAAY,KAAO,EAAE8D,S,yBAIhE,YAAAwP,YAAN,SAAkB3V,EAAkB0U,G,gHAElC,OADA,UAAOzT,IAAI,qBAAsB,CAAEjB,GAAE,EAAE0U,MAAK,IACxC1U,IAAOQ,KAAKg6B,aAAax6B,IAC3B,UAAOiB,IAAI,oDACX,KAEiB,GAAM,UAAQ4T,UAAUoU,WAAWjpB,I,OAA/C87B,EAAY,SAAsC,G,uCAE9Cz4B,EAAQ,E,wBAAGA,EAAQqR,EAAM1P,OAChC,GAAM,UAAQ6P,UAAUnB,KAAKgB,EAAMrR,GAAOrD,GAAI,CAAEC,SAAUD,EAAG+G,WAAY1D,MAAK,KADxC,M,OACtC,S,wBADwCA,I,gCAI1C,M,WAAM,IAAI5C,MAAM,4BAA8BT,EAAK,KAAO,EAAEmG,S,UAI1D21B,EAAS34B,SAAS6B,SAAW0P,EAAM1P,OAAnC,aACI+2B,EAAoBD,EAAS34B,SAASc,KAAI,SAACF,EAAMc,GAAM,OAACA,EAAGd,EAAJ,IAAYP,QAAO,SAAC,G,IAAGO,EAAK,KACvF,OAAAA,EAAM7D,KACDwU,EAAMhU,MAAK,SAAA+D,GAAQ,OAAAA,EAAKnE,OAAS,EAAAT,SAASE,UAAYiC,OAAOyC,EAAKzE,MAAQgC,OAAO+B,EAAM/D,GAApE,KACnB0U,EAAMhU,MAAK,SAAA+D,GAAQ,OAAAA,EAAKnE,OAAS,EAAAT,SAASC,QAAUkC,OAAOyC,EAAKzE,MAAQgC,OAAO+B,EAAM/D,GAAlE,GAFxB,I,yCAKA,UAAOiB,IAAI,0CAA2C,CAAC86B,kBAAmBA,EAAkB93B,KAAI,SAAC,GAAc,OAAZ,KAAM,KAAejE,GAAT,M,IAClF,EAAA+7B,E,0BAAA,YAAlB,OAAC14B,EAAK,KAAEU,EAAK,KACtB,GAAM,UAAQ8Q,UAAUnB,KAAK3P,EAAM/D,GAAI,CAAEC,SAAUD,EAAG+G,WAAY1D,MAAK,MAD3B,O,QAC5C,S,0BAD2B,I,oCAI7B,M,WAAM,IAAI5C,MAAM,4BAA8BT,EAAK,KAAO,EAAEmG,S,0BAK5D,YAAAR,aAAN,SAAmB7B,G,iHAGjB,GAFO9D,EAAuB8D,EAAM,GAAzB3D,EAAmB2D,EAAM,MAAlB7D,EAAY6D,EAAM,SACpC,UAAO7C,IAAI,sBAAuB6C,GAC9BA,EAAO7D,WAAaO,KAAKg6B,aAAax6B,GAExC,OADA,UAAOiB,IAAI,gDACX,IAEF,GAAI6C,EAAOvD,OAET,OADA,UAAOU,IAAI,2CACX,I,iBAGA,O,sBAAA,GAAMT,KAAKk6B,MAAMlG,KAAI,gD,2BAEnB,OADA,UAAOvzB,IAAI,yCAA0C6C,GAC9C,CAAP,EAAO,UAAQ+Q,UAAU+mB,OAAO57B,EAAG+G,WAAY,CAC7C5G,MAAK,I,yBAHT,S,aAOA,M,WAAM,IAAIM,MAAM,2BAA6BT,EAAK,KAAO,EAAEmG,S,OAE1C,SAAM,UAAQ0O,UAAUoU,WAAWjpB,I,OACtD,GADMmzB,EAAa,SAAwC,GACvD,EAAAnvB,OAAOf,QAAQkwB,GAAWtvB,WAAW5D,GACvC,MAAM,IAAIQ,MAAM,4CAA8CT,EAAK,wBAA0BC,G,iBAG7F,O,sBAAA,GAAMO,KAAKk6B,MAAMlG,KAAI,gD,2BAEnB,OADA,UAAOvzB,IAAI,uCAAwC6C,GAC5C,CAAP,EAAO,UAAQ+Q,UAAUnB,KAAK1T,EAAG+G,WAAY,CAAE9G,SAAQ,I,yBAFzD,S,aAKA,M,WAAM,IAAIQ,MAAM,yBAA2BT,EAAK,KAAO,EAAEmG,S,yBAIvD,YAAAP,aAAN,SAAmB9B,G,yGAGjB,GAFM9D,EAAK8D,EAAO9D,GAClB,UAAOiB,IAAI,sBAAuBjB,GAC9B8D,EAAO7D,WAAaO,KAAKg6B,aAAax6B,GAExC,OADA,UAAOiB,IAAI,gDACX,IAEF,GAAI6C,EAAOvD,OAET,OADA,UAAOU,IAAI,kCACX,I,iBAGA,O,sBAAA,GAAMT,KAAKk6B,MAAMlG,KAAI,gD,2BAEnB,OADA,UAAOvzB,IAAI,yCAA0C6C,GAC9C,CAAP,EAAO,UAAQ+Q,UAAUmnB,WAAWh8B,EAAG+G,Y,yBAFzC,S,+BAKA,UAAO9F,IAAI,oBAAsB6C,EAAOzB,UAAY,KAAO,EAAE8D,QAAU,iB,+BAI9D,EAAA4iB,mBAAb,SAAgCtZ,EAAgB1J,EAAqBk2B,G,uGACnE,GAAgB,SAAZxsB,EACF,MAAO,CAAP,EAAO,UAAQtE,KAAKX,WAAW,c,+CAGnB,EAAAzE,GAAA,MAAc,GAAM60B,EAAYvR,qBAAqB5Z,I,OAAxC,EAAC,S,iBAOxB,OAPF1J,EAAY,EAERk2B,IACFl2B,EAAYA,EAAUb,MAAMa,EAAUnF,QAAQq7B,GAAkB,IAIhE,GAAMv3B,QAAQwK,IACZnJ,EAAU9B,KAAI,SAAMi4B,GAAQ,qC,kDAEZ,O,sBAAA,GAAM,UAAQrnB,UAAUwH,IAAI6f,I,OAExC,MAAO,CAAP,EAFY,SACG,GACL/7B,MAAMgK,QAAQ,OAAQ,Q,OAEhC,O,SAAO,CAAP,EAAO,U,oCARf,MAAO,CAAP,EACE,SAWA1H,KAAK,M,OAEP,O,SAAO,CAAP,EAAO,UAAQ0I,KAAKX,WAAW,wB,yBAItB,EAAA6e,qBAAb,SAAkC5Z,EAAqBod,G,YAAA,IAAAA,IAAAA,EAAA,I,2FACrD,YAAuB,IAAZpd,EACF,CAAP,EAAOod,IAETA,EAAKsP,QAAQ1sB,GACD,GAAM,UAAQoF,UAAUwH,IAAI5M,K,OAExC,OAFM2sB,EAAM,UACN/3B,EAAK+3B,EAAI,IACRn8B,WAAawP,EACX,CAAP,EAAOod,GAEF,CAAP,EAAOrsB,KAAK6oB,qBAAqBhlB,EAAGpE,SAAU4sB,I,QAGnC,EAAAgO,sBAAb,W,6FACOL,EAAD,Y,iBAGgB,O,sBAAA,GAAM,UAAQ3lB,UAAUwH,IAAI,M,cAA5Cme,EAAgB,SAAkC,G,uCAIhC,O,sBAAA,GAAM,UAAQ3lB,UAAUwH,IAAI,iB,cAA5Cme,EAAgB,SAA6C,G,aAG7C,O,SAAA,GAAM,UAAQ3lB,UAAU8T,W,qBAAxC6R,EAAgB,SAAmC,IAG/Br3B,S,gCAI1B,MAAO,CAAP,EAAOq3B,G,QAGT,YAAA/b,YAAA,WACE,OAAO/Z,QAAQC,SAAQ,EACzB,EA5WgB,EAAA02B,oBAA8B,gBAC9B,EAAAC,sBAAgC,kBAChC,EAAAC,qBAA+B,iBAC/B,EAAAC,uBAAiC,mBACjC,EAAAE,qBAA+B,cAC/B,EAAAD,qBAA+B,GAwWjD,C,CApXA,G,UAAqBb,C,+xDCfrB,iBACA,cAEA,cACA,UAEA,cAEA,aAIE,WAAY1e,GACV1b,KAAK0b,QAAUA,EACf1b,KAAKk6B,MAAQ,IAAI,UAAO,CAAEvD,YAAa,IACzC,CA4IF,OA1IQ,YAAA/nB,iBAAN,W,gGACa,SAAM,UAAQqe,KAAKC,MAAM,CAClC2O,WAAY,Y,OAId,OAFA5O,GAHIA,EAAO,UAGCjqB,QAAO,SAAA84B,GAAO,OAACA,EAAIC,SAAL,IAEnB,CAAP,EAAO,IAAI,EAAAv4B,OAAO,CAChB7D,MAAO,GACPH,GAAI,OACJK,SAAU,EAAAX,aAAaC,MACvBwD,UAAU,aAAKsqB,EAAKxpB,KAAI,SAAAu4B,GAAK,OAAAA,EAAEC,QAAF,KAAax4B,KAAI,SAACw4B,EAAU53B,GACvD,OAAO,IAAI,EAAAb,OAAO,CAChB7D,MAAO,UAAY0E,EACnB7E,GAAIy8B,EACJx8B,SAAU,OACVI,SAAU,EAAAX,aAAaC,MACvBwD,SAAUsqB,EACPjqB,QAAO,SAAAg5B,GAAK,OAAAA,EAAEC,WAAaA,CAAf,IACZh5B,MAAK,SAACi5B,EAAGC,GAAO,OAAAD,EAAGr5B,MAAQs5B,EAAGt5B,KAAd,IAChBY,KAAI,SAAAu4B,GAAK,WAAI,EAAAp7B,SAAS,CACrBpB,GAAIw8B,EAAEx8B,GACNG,MAAOq8B,EAAEr8B,MACTD,IAAKs8B,EAAEt8B,IACPD,SAAUw8B,EACVp8B,SAAU,EAAAX,aAAaC,OALf,KAQhB,O,QAIE,YAAAiD,eAAN,SAAqBuB,G,gGAEnB,OADA,UAAOlD,IAAI,eAAgBkD,GACD,SAAtBA,EAASlE,UACX,UAAOgB,IAAI,wCACX,KAE6B,mBAA3BmL,KAAK/L,SAASgM,UAAoE,UAAnC,IAAIvL,IAAIqD,EAASjE,KAAKmM,UACvE,UAAOpL,IAAI,+DACX,KAEW,GAAMT,KAAKk6B,MAAMlG,KAAI,WAChC,iBAAQ/G,KAAKhR,OAAO,EAAD,GACjBggB,SAAuC,iBAAtBt4B,EAASlE,SAAwBmH,SAASjD,EAASlE,UAAYkE,EAASlE,SACzFC,IAAKiE,EAASjE,UAE8B,IAAjC,UAAQ08B,sBAAwC,CAAEC,WAAW,IAAO,CAC/ErkB,QAAQ,IALV,K,OAQF,OATMsQ,EAAO,SASb,GAAMgU,K,OACN,OADA,SACO,CAAP,EAAOhU,EAAK9oB,I,QAGR,YAAA8C,eAAN,SAAqBqB,G,0FAEnB,OADA,UAAOlD,IAAI,eAAgBkD,GACD,SAAtBA,EAASlE,UACX,UAAOgB,IAAI,wCACX,KAEF,GAAMT,KAAKk6B,MAAMlG,KAAI,WACnB,iBAAQ/G,KAAKmO,OAAOz3B,EAASnE,GAAI,CAC/BE,IAAKiE,EAASjE,KADhB,K,OAIF,OALA,SAKA,GAAMM,KAAKk6B,MAAMlG,KAAI,WACnB,iBAAQ/G,KAAK/Z,KAAKvP,EAASnE,GAAI,CAC7By8B,SAAUt4B,EAASlE,SACnBoD,OAAQ,GAFV,K,OAKF,OANA,SAMA,GAAMy5B,K,cAAN,S,YAGI,YAAA95B,eAAN,SAAqBmB,G,gGAGnB,OAFM03B,EAAa13B,EAASnE,GAC5B,UAAOiB,IAAI,eAAgBkD,GACD,SAAtBA,EAASlE,UACX,UAAOgB,IAAI,wCACX,KAEF,GAAMT,KAAKk6B,MAAMlG,KAAI,WAAM,iBAAQ/G,KAAK9Z,OAAOkoB,EAApB,K,OAC3B,OADA,SACA,GAAMiB,K,cAAN,S,YAGI,YAAAp3B,aAAN,SAAmB5B,G,0FAEJ,OADb,UAAO7C,IAAI,qBAAsB6C,GACpB,GAAMtD,KAAKk6B,MAAMlG,KAAI,WAChC,iBAAQuI,QAAQtgB,QAAhB,K,OAEF,MAAO,CAAP,EAHa,SAGDzc,I,QAGR,YAAA2V,YAAN,SAAkB3V,EAAkB0U,G,gHAEb,OADrB,UAAOzT,IAAI,oBAAqB,CAAEjB,GAAE,EAAE0U,MAAK,IACtB,GAAM,UAAQ+Y,KAAKC,MAAM,CAC5C+O,SAAUz8B,K,OADNg9B,EAAe,S,uCAIV35B,EAAQ,E,wBAAGA,EAAQqR,EAAM1P,OAChC,GAAM,UAAQyoB,KAAK/Z,KAAKgB,EAAMrR,GAAOrD,GAAI,CAAEqD,MAAK,KADV,M,OACtC,S,wBADwCA,I,gCAI1C,M,WAAM,IAAI5C,MAAM,4BAA8BT,EAAK,KAAO,EAAEmG,S,UAI1D62B,EAAah4B,SAAW0P,EAAM1P,OAA9B,aACI+2B,EAAoBiB,EAAa/4B,KAAI,SAACq4B,EAAKz3B,GAAM,OAACA,EAAGy3B,EAAJ,IAAU94B,QAAO,SAAC,G,IAAG84B,EAAG,KAC7E,OAAC5nB,EAAMhU,MAAK,SAAA+D,GAAQ,OAAAzC,OAAOs6B,EAAIt8B,MAAQgC,OAAOyC,EAAKzE,GAA/B,GAApB,I,6CAG6B,EAAA+7B,E,0BAAA,YAAlB,OAAC14B,EAAK,KAAEU,EAAK,KACtB,GAAM,UAAQ0pB,KAAK/Z,KAAK3P,EAAM/D,GAAI,CAACqD,MAAK,MADI,O,QAC5C,S,0BAD2B,I,oCAI7B,M,WAAM,IAAI5C,MAAM,4BAA8BT,EAAK,KAAO,EAAEmG,S,QAGhE,SAAM22B,K,eAAN,S,YAGI,YAAAn3B,aAAN,SAAmB7B,G,0EACjB,UAAO7C,IAAI,4BAA6B6C,G,WAGpC,YAAA8B,aAAN,SAAmB9B,G,gGAGjB,OAFM9D,EAAK8D,EAAO9D,GAClB,UAAOiB,IAAI,qBAAsBjB,GACjC,GAAMQ,KAAKk6B,MAAMlG,KAAI,WAAM,iBAAQja,OAAO5G,OAAO3T,EAAtB,K,cAA3B,S,YAGI,YAAAye,YAAN,W,gGACe,SAAM,UAAQgP,KAAKC,MAAM,CACpC2O,WAAY,Y,OAEd,OAHM5O,EAAO,SAGN,CAAP,EAAO3L,QAAQ2L,EAAKzoB,S,QAExB,EAnJA,GAqJA,SAAS83B,IACP,OAAOp4B,QAAQ6zB,KAAK,CAClB,IAAI7zB,SAAc,SAAAC,GAChB,UAAQ8oB,KAAKwP,UAAU/jB,aAAY,SAASP,IAC1C,UAAQ8U,KAAKwP,UAAU9jB,eAAeR,GACtC4L,YAAW,WAAM,OAAA5f,GAAA,GAAW,IAC9B,GACF,IACA,IAAID,SAAQ,SAAAC,GAAW,OAAA4f,WAAW5f,EAAS,IAApB,KAE3B,C,ysECvKA,kBACA,cACA,UACA,cAUA,aAUE,WAAYu4B,EAAmBC,EAAmBC,EAAuEn4B,EAAuBo4B,EAAoBC,QAApB,IAAAD,IAAAA,GAAA,QAAoB,IAAAC,IAAAA,GAAA,GAClK98B,KAAK08B,QAAUA,EACf18B,KAAK28B,QAAUA,EACf38B,KAAK48B,UAAYA,EACjB58B,KAAKyE,cAAgBA,EACrBzE,KAAK68B,iBAAqC,IAAhBA,GAAqCA,EAC/D78B,KAAK88B,SAAWA,EAChB98B,KAAK8I,OAAS,CACZwE,OAAQ,IAAI,UACZC,OAAQ,IAAI,UACZC,KAAM,IAAI,UACVC,OAAQ,IAAI,UACZC,QAAS,IAAI,UAEjB,CAwRF,OAtRE,YAAAX,SAAA,WACE,OAAO/M,KAAK8I,MACd,EAEM,YAAAyH,IAAN,W,0FACE,SAAMvQ,KAAK+8B,SAAS/8B,KAAK08B,QAAS18B,KAAK28B,U,OACvC,OADA,SACA,GAAM38B,KAAKg9B,a,OACX,OADA,SACA,GAAMh9B,KAAKi9B,e,OACX,OADA,SACO,CAAP,EAAOj9B,KAAK8I,Q,QAGR,YAAAi0B,SAAN,SAAe5sB,EAAmBC,G,0FAEhC,SAAMlM,QAAQC,W,OAEd,GAFA,SACA,UAAO1D,IAAI,wBAAyB0P,EAASC,GACxB,WAAjBD,EAAQrQ,MAAsC,WAAjBsQ,EAAQtQ,KACvC,MAAO,CAAP,EAAOE,KAAKk9B,WAAW/sB,EAASC,IAC3B,GAAqB,aAAjBD,EAAQrQ,MAAwC,aAAjBsQ,EAAQtQ,KAChD,MAAO,CAAP,EAAOE,KAAKm9B,aAAahtB,EAASC,IAElC,MAAM,IAAInQ,MAAM,0BAA4BkQ,EAAQrQ,KAAO,KAAOsQ,EAAQtQ,M,QAIxE,YAAAo9B,WAAN,SAAiBvK,EAAsBH,G,8GACjCxyB,KAAK68B,YACY,GAAM78B,KAAKuV,iBAAiBod,EAAWH,IADxD,M,OAEF,IADmB,SAEjB,U,iBAYJ,OARIG,EAAUhzB,QAAU6yB,EAAU7yB,YAAuC,IAAvBgzB,EAAUlzB,eAA0D,IAAvB+yB,EAAU/yB,UAEvGO,KAAK8I,OAAOyE,OAAOuE,OAAO,CAAChS,KAAM,EAAAyS,WAAWhF,OAAQ5F,QAAS6qB,EAAWriB,QAASwiB,IAK7EyK,EAAoB5K,EAAU7vB,SAAS+B,MAAM,GACnD,GAAMX,EAASN,IAAIkvB,EAAUhwB,UAAU,SAAM06B,EAAKx6B,GAAK,qC,sEAC/CuN,EAAUgtB,EAAkBx5B,MAAK,SAACL,GAAU,OAAA85B,EAAIv9B,OAASyD,EAAMzD,MAAQ,EAAK88B,UAAUS,EAAK95B,EAA/C,KAGhD,GAAMvD,KAAK+8B,SAASM,EAAKjtB,IADvB,M,OAGF,OAFA,SACAgtB,EAAkBrqB,OAAOqqB,EAAkBh9B,QAAQgQ,GAAU,GAC7D,I,OAGF,OAAIoiB,EAAUzyB,QAAUyyB,EAAU3yB,WAAa,EAAAX,aAAaC,OAK5Da,KAAK8I,OAAO2E,OAAOqE,OAAO,CAAChS,KAAM,EAAAyS,WAAW9E,OAAQ9F,QAAS01B,EAAKx6B,MAAK,IAHrE,I,SAID,I,OAIH,OAnBA,SAmBA,GAAMkB,EAASN,IAAI25B,GAAmB,SAAME,EAAUz6B,GAAK,qC,2BACzD,OAAI8vB,EAAU5yB,QAAU4yB,EAAU9yB,WAAa,EAAAX,aAAaC,OAI5Da,KAAK8I,OAAOwE,OAAOwE,OAAO,CAAChS,KAAM,EAAAyS,WAAWjF,OAAQ3F,QAAS21B,EAAUz6B,MAAK,IAF1E,G,SAGD,I,cANH,SAQI2vB,EAAU7vB,SAAS6B,OAAS,GAC9BxE,KAAK8I,OAAO4E,QAAQoE,OAAO,CACzBhS,KAAM,EAAAyS,WAAW7E,QACjB/F,QAAS6qB,EACTte,MAAOse,EAAU7vB,SAASc,KAAI,SAAAY,GAAK,OAAGvE,KAAMuE,EAAEvE,KAAMN,GAAI6E,EAAE7E,GAAvB,M,YAKnC,YAAA29B,aAAN,SAAmBI,EAA0BC,G,uGAEvCx9B,KAAK68B,YACM,GAAM78B,KAAKy9B,mBAAmBF,EAAaC,IADtD,M,cACFE,EAAa,S,aAEbA,EAAaH,EAAY59B,QAAU69B,EAAY79B,OAAS49B,EAAY79B,MAAQ89B,EAAY99B,I,wBAEtFg+B,GACF19B,KAAK8I,OAAOyE,OAAOuE,OAAO,CAAEhS,KAAM,EAAAyS,WAAWhF,OAAQ5F,QAAS61B,EAAartB,QAASotB,I,YAIlF,YAAAE,mBAAN,SAAyBF,EAA0BC,G,kGACjC,SAAMD,EAAYz8B,Q,OAClB,OADVssB,EAAU,SACA,GAAMoQ,EAAY18B,Q,OAClC,OADMusB,EAAU,SACT,CAAP,EAAOD,IAAYC,G,QAGf,YAAA9X,iBAAN,SAAuBod,EAAsBH,G,kGAC3B,SAAMG,EAAU7xB,KAAKd,KAAKyE,gB,OAC1B,OADV2oB,EAAU,SACA,GAAMoF,EAAU1xB,KAAKd,KAAKyE,gB,OAC1C,OADM4oB,EAAU,SACT,CAAP,EAAOD,IAAYC,G,QAGf,YAAA2P,UAAN,W,yHACE,UAAOv8B,IAAI,0BAGPmV,GAAa,E,qBAIVA,EAAY,MAAF,OACfA,GAAa,EACT+nB,OAAY,EAAwBC,OAAY,EAGpDrqB,EAAgBvT,KAAK8I,OAAOwE,OAAOe,a,wBAC3BuH,KAAe+nB,EAAepqB,EAAcoX,SAAQ,MAE1D,GAAMzmB,QAAQC,W,OAAd,SACM05B,EAAcF,EAAah2B,QACjCm2B,EAAgB99B,KAAK8I,OAAO2E,OAAOY,a,wBAC3BuH,KAAegoB,EAAeE,EAAcnT,SAAQ,MAE1D,GAAMzmB,QAAQC,W,cAAd,SACM45B,EAAcH,EAAaj2B,QAE7B3H,KAAK48B,UAAUmB,EAAaF,KACR,WAArBE,EAAYj+B,OACTE,KAAK88B,UAAYiB,EAAYl9B,mBAAmBg9B,GAAe,KACnE79B,KAAK8I,OAAOwE,OAAO0G,QAAQ2pB,GAC3B39B,KAAK8I,OAAO2E,OAAOuG,QAAQ4pB,GAC3B59B,KAAK8I,OAAO0E,KAAKsE,OAAO,CACtBhS,KAAM,EAAAyS,WAAW/E,KACjB7F,QAASk2B,EACT1tB,QAAS4tB,EACTl7B,MAAO86B,EAAa96B,MACpBm7B,SAAUJ,EAAa/6B,QAEzB+S,GAAa,EAEb,GAAM5V,KAAK+8B,SAASgB,EAAaF,KAd/B,M,OAcF,S,uDAMNtqB,EAAgBvT,KAAK8I,OAAOwE,OAAOe,a,uEAGjC,SAAMnK,QAAQC,W,OAAd,SACM05B,EAAcF,EAAah2B,QACjCm2B,EAAgB,EAAKh1B,OAAO2E,OAAOY,a,yFAGjC,SAAMnK,QAAQC,W,cAAd,SACM45B,EAAcH,EAAaj2B,SAC3BwI,EAAU4tB,EAAYt8B,eAC1Bo8B,EAAY/9B,MACZ,SAAAmE,GAAQ,SAAK24B,UAAU34B,EAAM45B,EAArB,IACR,SAAA55B,GAAQ,OAAAA,EAAKpD,mBAAmBg9B,EAAxB,MAGJG,OAAQ,EACZ,EAAKl1B,OAAOwE,OAAO0G,QAAQ2pB,GACvBxtB,IAAY4tB,EACd,EAAKj1B,OAAO2E,OAAOuG,QAAQ4pB,IAGrBK,EAAmBF,EAAY58B,OAAM,GACrC+8B,EAAiBD,EAAiB18B,SAAS,EAAAlC,SAASC,OAAQ6Q,EAAQ1Q,UACpE0+B,EAAeF,EAAiB18B,SAAS4O,EAAQrQ,KAAMqQ,EAAQ3Q,IACrEw+B,EAAWE,EAAev7B,SAASvC,QAAQ+9B,GAC3CD,EAAev7B,SAASoQ,OAAOirB,EAAU,GACzCJ,EAAaj2B,QAAUs2B,EACvBL,EAAaj2B,QAAQrG,eAEvB,EAAKwH,OAAO0E,KAAKsE,OAAO,CACtBhS,KAAM,EAAAyS,WAAW/E,KACjB7F,QAASk2B,EACT1tB,QAAO,EACPtN,MAAO86B,EAAa96B,MACpBm7B,SAAUA,GAAYJ,EAAa/6B,QAErC+S,GAAa,EACTzF,EAAQrQ,OAAS,EAAAT,SAASC,OAA1B,MACF,GAAM,EAAKy9B,SAAS5sB,EAAS0tB,KAxB7B,M,OAwBA,S,2CAGIztB,EAAUytB,EAAYp8B,eAC1Bs8B,EAAYj+B,MACZ,SAAAmE,GAAQ,SAAK24B,UAAUmB,EAAa95B,EAA5B,IACR,SAAAA,GAAQ,OAAAA,EAAKpD,mBAAmBk9B,EAAxB,IAENl7B,OAAK,EACLuN,GACF,EAAKtH,OAAO2E,OAAOuG,QAAQ4pB,GACvBxtB,IAAYytB,EACd,EAAK/0B,OAAOwE,OAAO0G,QAAQ2pB,IAGrBS,EAAmBP,EAAY18B,OAAM,GACrCk9B,EAAiBD,EAAiB78B,SAAS,EAAAlC,SAASC,OAAQ8Q,EAAQ3Q,UACpE6+B,EAAgBF,EAAiB78B,SAAS6O,EAAQtQ,KAAMsQ,EAAQ5Q,IACtEqD,EAAQw7B,EAAe17B,SAASvC,QAAQk+B,GACxCD,EAAe17B,SAASoQ,OAAOlQ,EAAO,GACtC86B,EAAah2B,QAAUy2B,EACvBT,EAAah2B,QAAQrG,eAEvB,EAAKwH,OAAO0E,KAAKsE,OAAO,CACtBhS,KAAM,EAAAyS,WAAW/E,KACjB7F,QAASyI,EACTD,QAAS4tB,EACTl7B,MAAOA,GAAS86B,EAAa96B,MAC7Bm7B,SAAUJ,EAAa/6B,QAEzB+S,GAAa,EACTmoB,EAAYj+B,OAAS,EAAAT,SAASC,OAA9B,MACF,GAAM,EAAKy9B,SAASgB,EAAa3tB,KAvBjC,M,OAuBA,S,wDAjEAwF,KAAegoB,EAAeE,EAAcnT,SAAQ,M,4FALtD/U,KAAe+nB,EAAepqB,EAAcoX,SAAQ,O,0EA+ExD4T,EAAQv+B,KAAK8I,OAAO0E,KAAKa,aACfrO,KAAK8I,OAAOyE,OAAOc,aAC3BtJ,SAAQ,SAAAq2B,GACVmD,EAAM36B,MAAK,SAAAsP,GAAQ,OAAA1R,OAAO0R,EAAKvL,QAAQnI,MAAQgC,OAAO45B,EAAOzzB,QAAQnI,GAAlD,KACrB,EAAKsJ,OAAOyE,OAAOyG,QAAQonB,EAE/B,I,YAGI,YAAA6B,YAAN,W,4FAoBE,IAAWtP,KAnBX,UAAOltB,IAAI,8BACL+9B,EAAU,CAAC,EACXC,EAAU,CAAC,EAGjBz+B,KAAK8I,OAAOwE,OAAOe,aAChBtJ,SAAQ,SAAAwK,GACPivB,EAAQjvB,EAAO5H,QAAQlI,WAAY,CACrC,IACFO,KAAK8I,OAAO2E,OAAOY,aAChBtJ,SAAQ,SAAAwK,GACPkvB,EAAQlvB,EAAO5H,QAAQlI,WAAY,CACrC,IACFO,KAAK8I,OAAO0E,KAAKa,aACdtJ,SAAQ,SAAAwK,GACPivB,EAAQjvB,EAAO5H,QAAQlI,WAAY,EACnCg/B,EAAQlvB,EAAOY,QAAQ1Q,WAAY,CACrC,I,WAESkuB,GACT,IAAMgF,EAAY,EAAK+J,QAAQn7B,SAAS,EAAAlC,SAASC,OAAQquB,GACzD,IAAKgF,E,iBAIL,IAAMH,EAAY,EAAKmK,QAAQl7B,eAAe,EAAApC,SAASC,QAAQ,SAAC2E,GAAS,SAAK24B,UAAUjK,EAAW1uB,EAA1B,IACrEuuB,IACFgM,EAAQhM,EAAUhzB,KAAM,E,SARLi/B,E,EAAZ9Q,GAYX,IAAWA,K,WAAAA,GACT,IAAM6E,EAAY,EAAKmK,QAAQp7B,SAAS,EAAAlC,SAASC,OAAQquB,GACnD+Q,EAAY,EAAK51B,OAAO4E,QAAQW,aAAazK,MAAK,SAAAV,GAAK,OAAA1B,OAAO0B,EAAEyE,QAAQnI,MAAQgC,OAAOgxB,EAAUhzB,GAA1C,IACzDk/B,GACF,EAAK51B,OAAO4E,QAAQsG,QAAQ0qB,GAE9B,EAAK51B,OAAO4E,QAAQoE,OAAO,CACzBhS,KAAM,EAAAyS,WAAW7E,QACjB/F,QAAS6qB,EACTte,MAAOse,EAAU7vB,SAASc,KAAI,SAAAY,GAAK,OAAGvE,KAAMuE,EAAEvE,KAAMN,GAAI6E,EAAE7E,GAAvB,K,SAThBg/B,E,EAAZ7Q,G,iBAaf,EAhTA,G,6OCNA,MACMgR,EAAuB,KAG7B,MAAMC,EACJ3uB,WAAAA,CAAY4uB,GACV7+B,KAAK6+B,IAAMA,EACX7+B,KAAK8+B,uBAAwB,EAC7B9X,aAAY,IAAMhnB,KAAK++B,aAAa,MAEpCC,EAAAA,EAAQtmB,YAAY,uBAAuBkJ,IACrCA,EAAOqd,UACTj/B,KAAK8+B,uBAAwB,EAE7B9+B,KAAK8+B,uBAAwB,CAC/B,GAEJ,CAEA,eAAMC,GACJ,IAAK/+B,KAAK8+B,sBACR,OAEF,MAAM3iB,QAAiBkc,EAAAA,QAAqBlY,iBAC5C,IAAK,IAAItH,KAAasD,EAAU,CAC9B,MACM9D,SADgBkE,IAAAA,IAAY1D,IACbpJ,UACfgP,EAAWpG,EAAKoG,UAAY,EAC5BygB,EAAW7mB,EAAKuE,cA1BE,GA2BxB,GAAIvE,EAAK+F,UACPpe,KAAK6+B,IAAI1lB,aAAaN,QAGxB,GAAIR,EAAKgG,OAAShG,EAAK2E,WAAa,GAClC,GAAI0B,KAAKC,MAAQ3e,KAAKm/B,mBAAmBD,EAAU7mB,EAAK2E,WAAYyB,GAAYA,EAAU,CACxFze,KAAK6+B,IAAI1lB,aAAaN,GACtB,QACF,OAIA6F,KAAKC,MACM,IAAXugB,EAAkB,GAAK7mB,EAAKoG,UAE5Bze,KAAK6+B,IAAI1lB,aAAaN,EAE1B,CACF,CAcAsmB,kBAAAA,CAAmBD,EAAUliB,EAAYyB,GACvC,MAAM2gB,EAAgB96B,KAAK+6B,KAAKV,GAAmC,IAAXO,EAAkB,KAC1E,OAAIliB,EAAaoiB,GAAiB3gB,EAAWkgB,EAAuBjgB,KAAKC,MAChEra,KAAKiI,IAAIoyB,EAAiC,IAAXO,EAAkB,GAAK56B,KAAKg7B,IAAI,EAAGtiB,IAElE2hB,EAAuBA,GAAwB3hB,EAAaoiB,EAEvE,EAGa,MAAMG,EACnBtvB,WAAAA,GACEjQ,KAAKw/B,SAAW,CAAC,EACjBx/B,KAAKy/B,UAAY,GAEjBz/B,KAAK8a,OAAS,IAAI8jB,EAAa5+B,MAI/BqpB,EAAAA,YAAQxN,IAAI,CAACxU,IAAK,mBAAoBwQ,MAAK+R,UAAkC,IAA3B2D,MAAOmS,GAAeC,EACtE3/B,KAAKsZ,YAAYomB,GACjB1/B,KAAK4/B,UAAYF,EACbA,IACF1/B,KAAKqH,IAAM,KACb,GAEJ,CAEAiS,UAAAA,CAAWC,GACTvZ,KAAKuZ,QAAUA,CACjB,CAEA,YAAMG,CAAOrS,GACX,IAAIq4B,QAAuBrW,EAAAA,YAAQxN,IAAI,CAAExU,IAAK,mBAC9C,GAAIq4B,EAAgB,CAClB,IAAIG,QAAkBnH,IAAAA,OAAoBrxB,GAO1C,SAN0BqxB,IAAAA,WACxBrxB,EACAq4B,EACA,aAGoBG,EACpB,MAAM,IAAI5/B,MAAM,8BAElBD,KAAKqH,IAAMA,CACb,CACArH,KAAK4/B,UAAW,EAChB5/B,KAAKsZ,YAAW,EAClB,CAEAK,WAAAA,GACE,OAAOzV,QAAQC,QAAQnE,KAAK4/B,SAC9B,CAEA,iBAAMvmB,GACJ,MAAM8C,QAAiBI,IAAAA,iBACvB,IAAK,MAAMP,KAAWG,EACpBnc,KAAKmZ,aAAa6C,EAAQxc,GAE9B,CAEA,kBAAM2Z,CAAaN,EAAWO,GAC5B,GAAIA,EAQF,OAPIpZ,KAAKw/B,SAAS3mB,IAChB4U,aAAaztB,KAAKw/B,SAAS3mB,SAE7B7Y,KAAKw/B,SAAS3mB,GAAakL,YACzB,IAAM/jB,KAAKmZ,aAAaN,IAjIL,MAuIvB,IAAImD,QAAgBO,IAAAA,IAAY1D,GAC5BmD,EAAQvM,UAAUsO,UAIjB/B,EAAQvM,UAAU8J,SAAYyC,EAAQvM,UAAU2O,mBAIhCpe,KAAK8/B,cACXC,EAAAA,IAKqB,IAAhC/jB,EAAQvM,UAAU2O,gBACdpe,KAAKwZ,YAAYX,SAEjB7Y,KAAKwZ,YAAYX,EAAWmD,EAAQvM,UAAU2O,iBAP9CpC,EAAQoB,QAAQ,CAAEgB,UAAWpC,EAAQvM,UAAU2O,YAAa,IAStE,CAEA,gBAAMxF,CAAWC,EAAWC,GAC1B,IAAIkD,QAAgBO,IAAAA,IAAY1D,GAE3BC,SACGkD,EAAQoB,QAAQ,CAAE7D,SAAS,UAE7ByC,EAAQpD,YAChB,CAEA,iBAAMY,CAAYX,EAAWvC,GAA6B,IAAnBmD,EAASW,UAAA5V,OAAA,QAAAsmB,IAAA1Q,UAAA,IAAAA,UAAA,GAC9C,IAAKpa,KAAKuZ,QACR,OAEF,IAAIyC,QAAgBO,IAAAA,IAAY1D,GAChC,IAAImD,EAAQvM,UAAUsO,QAAtB,CAGAgG,YAAW,IAAM/jB,KAAKggC,gBAAgB,KACtC,UACQhkB,EAAQrP,KAAK2J,EAAUmD,EAC/B,CAAE,MAAO4E,GACPxU,QAAQwU,MAAMA,EAChB,CACAre,KAAKggC,cAPL,CAQF,CAEA,kBAAMA,GACJhgC,KAAKy/B,UAAU16B,SAAQrD,GAAMA,KAC/B,CAEA,eAAMo+B,GACJ,IAAK9/B,KAAK4/B,SACR,OAAOK,EAAAA,GAET,MAAM9jB,QAAiBI,IAAAA,iBACvB,IAAI2jB,EAAgB/jB,EAAS/X,QAAO,CAACwd,EAAQ5F,KAC3C,MAAMkM,EAAUlM,EAAQvM,UACxB,OAAImS,IAAWme,EAAAA,IAAkB7X,EAAQnK,QAChCgiB,EAAAA,GACEne,IAAWqe,EAAAA,IAAiB/X,EAAQ7J,QAAU6J,EAAQnK,QACxDkiB,EAAAA,GAEAE,EAAAA,EACT,GACCA,EAAAA,IAQH,OANID,IAAkBC,EAAAA,IAChBhkB,EAASmE,OAAMtE,IAAYA,EAAQvM,UAAU8J,YAC/C2mB,EAAgBE,EAAAA,IAIbF,CACT,CAEAlnB,cAAAA,CAAeb,GACbnY,KAAKy/B,UAAUh6B,KAAK0S,GACpB,IAAIkoB,GAAe,EACnB,MAAO,KACDA,IACJrgC,KAAKy/B,UAAU1sB,OAAO/S,KAAKy/B,UAAUr/B,QAAQ+X,GAAW,GACxDkoB,GAAe,EAAI,CAEvB,CAEA,YAAMzmB,GACJ,MAAMuC,QAAiBI,IAAAA,uBACjBrY,QAAQwK,IACZyN,EAAS1Y,KAAImmB,UACPzb,EAAIsB,UAAUsO,eACV5P,EAAIiP,QAAQ,CAChBW,SAAS,EACTK,WAAW,GAEf,IAGN,EAGF,IAAIjH,EACJooB,EAAiBroB,aAAe,WAI9B,OAHKC,IACHA,EAAY,IAAIooB,GAEXpoB,CACT,C,m6ECxPA,eAEA,cACA,cACA,UACA,UACA,cACA,cACA,cACA,cAQA,WAgBMsf,EAAU,IA6BhB,aAiBE,WAAYzrB,GAbL,KAAAs1B,qBAA+B,KAK9B,KAAA50B,UAAW,EACX,KAAA6X,eAA6B,KAG7B,KAAAf,OAAQ,EACR,KAAAD,QAAS,EACT,KAAAge,0BAAqC,KAG3CvgC,KAAKgL,OAASA,EACdhL,KAAK02B,WAAa,IAAI,UAAO,CAAEC,YAAa,KAC5C32B,KAAKwgC,aAAe,IAAI,UACxBxgC,KAAKqjB,gBAAkB,IAAIuD,gBAC3B5mB,KAAKglB,YAAchlB,KAAKqjB,gBAAgB0B,MAC1C,CA24BF,OAz4BS,EAAA1J,iBAAP,WACE,MAAO,CACLvb,KAAM,sBACNJ,IAAK,sBACLigB,SAAU,MACVC,SAAU,SACV6gB,WAAY,GACZ7d,oBAAoB,EACpBC,gBAAgB,EAChB/F,cAAc,EAElB,EAEA,YAAAM,QAAA,SAAQ/E,GACNrY,KAAKgL,OAAS,EAAH,GAAQqN,EACrB,EAEA,YAAA5I,QAAA,WACE,OAAO,EAAP,KAAYixB,EAA0BrlB,oBAAuBrb,KAAKgL,OACpE,EAEA,YAAA0R,SAAA,WACE,IAAMrE,EAAOrY,KAAKyP,UAClB,OAAO4I,EAAK0E,QAAU1E,EAAKsH,SAASlJ,SAAS,KAAO4B,EAAKsH,SAAW,OAAS,IAAIrf,IAAI+X,EAAK3Y,KAAKsyB,SAAW3Z,EAAKsH,SAAW,IAAM,IAAIrf,IAAI+X,EAAK3Y,KAAKsyB,SACpJ,EAEA,YAAApiB,gBAAA,SAAgB/L,GACd,IACE,OAAOyd,SAAS,CAAC,SAAU,QAAS,QAAQ9P,OAAOxR,KAAKugC,0BAA4B,CAAC,eAAiB,IAAIngC,QAAQ,IAAIE,IAAIuD,EAAGnE,KAAKmM,U,CAClI,MAAOrL,GACP,OAAO,C,CAEX,EAEA,YAAAuiB,mBAAA,SAAmBC,GACjB,IAAMC,EAAY,IAAI3iB,IAAI0iB,GACpB2d,EAAW1d,EAAUC,SAAS9iB,QAAQ,aACvC6iB,EAAUC,WAAUD,EAAUC,SAAW,IAC9CD,EAAUE,OAAS,GACnBF,EAAUniB,KAAO,GACjBmiB,EAAUC,SAAWD,EAAUC,SAASgD,UAAU,GAAIya,EAAWA,OAAW7V,GAC5E,IAAM1H,EAASH,EAAU1c,WACzB,OAAO6c,GAAwC,MAA9BA,EAAOA,EAAO5e,OAAS,GAAa,IAAM,GAC7D,EAEM,YAAA8Z,YAAN,SAAkBC,EAAiB8H,G,YAAjB,IAAA9H,IAAAA,GAAA,QAAiB,IAAA8H,IAAAA,GAAA,G,8GACD,QAA5B,EAAAjP,UAAUC,cAAV,MACe,iDAAa,MAAgB,K,OAAxCwD,EAAW,SAAgChE,QAC7CyP,OAAc,EAAEjI,GAAQ,E,iBAET,O,sBAAA,GAAMxD,EAAQ0L,YAAYC,SAAS,CAAEC,QAAS,CAACzmB,KAAKgL,OAAOtL,IAAM,Q,cAAlF4mB,EAAiB,S,+BAEjBjI,GAAQ,EACRxU,QAAQC,KAAK,G,aAEf,IAAKuU,IAAUiI,EACb,MAAM,IAAI,EAAAI,wB,iBAId,SAAM1mB,KAAK4gC,+B,OAUG,OAVd,SAEA5gC,KAAKqjB,gBAAkB,IAAIuD,gBAC3B5mB,KAAKglB,YAAchlB,KAAKqjB,gBAAgB0B,OAEpC/kB,KAAKyiB,iBACPsE,cAAc/mB,KAAKyiB,iBAIrB,EAAAziB,KAAc,GAAMA,KAAK6gC,e,OACzB,GADA,EAAKte,OAAS,SACV8D,EACFrmB,KAAKuiB,QAAS,OACT,IAAKviB,KAAKuiB,OACf,MAAM,IAAI,EAAA4B,oB,OAEZnkB,KAAKyiB,gBAAkBuE,aAAY,WAAM,OAAC,EAAKxE,OAAS,EAAKqe,aAApB,GAvGvB,MAyGlB7gC,KAAK0L,UAAW,EAChB1L,KAAKwiB,OAAQ,E,YAGT,YAAAjD,eAAN,W,0FAGE,OAFAvf,KAAKwiB,OAAQ,EACbuE,cAAc/mB,KAAKyiB,iBACnB,GAAMziB,KAAK8gC,e,cAAX,S,YAGI,YAAA7gB,WAAN,W,0FAGE,OAFAjgB,KAAKwiB,OAAQ,EACbuE,cAAc/mB,KAAKyiB,iBACnB,GAAMziB,KAAK8gC,e,cAAX,S,YAGF,YAAAz0B,OAAA,WACErM,KAAK0L,UAAW,EAChB1L,KAAK02B,WAAWqK,QAChB/gC,KAAKqjB,gBAAgBC,QACrBtjB,KAAKujB,gBAAkBvjB,KAAKujB,gBAC9B,EAEM,YAAAyd,iBAAN,W,8EACE,MAAO,CAAP,EAAOhhC,KAAKwgC,aAAanjB,QAAQ,QAAQ,gD,8DACvC,GAAIrd,KAAK6f,KACP,MAAO,CAAP,EAAO7f,KAAK6f,MAGd,UAAOpf,IAAI,sBACP4D,EAAI,EACJgU,EAAO,G,iBAGF,SAAMrY,KAAK82B,YAChB,MACA,gEAAyDzyB,EAAC,kBAzKlD,O,OA2KV,GAJAsS,EAAO,UAIF5U,MAAMwI,QAAQoM,EAAK0B,MACtB,MAAM,IAAI,EAAA4oB,8BAEZ5oB,EAAOA,EAAK7G,OAAOmF,EAAK0B,MACxBhU,I,oBA/KU,MAgLHsS,EAAK0B,KAAK7T,OAAoB,Y,iBAsBvC,OApBM6P,GAAY,aAChBgE,EAAK5U,KAAI,SAACI,GACR,IAAMF,EAAW,CACfnE,GAAIqE,EAAGrE,GACPE,IAAMmE,EAAG8W,QAAU9W,EAAGnE,IACtBC,MAAOkE,EAAGlE,MACVF,SAAU,KACVI,SAAU,EAAAX,aAAaE,QAGzB,OAAOyE,EAAGiwB,QAAQrwB,KAAI,SAAChE,GACrB,IAAM0D,EAAI,EAAH,GAAQQ,GAEf,OADAR,EAAE1D,SAAWA,EACN,IAAI,EAAAmB,SAASuC,EACtB,GACF,KAGF,UAAO1C,IAAI,iCAAkC4T,GAC7CrU,KAAK6f,KAAOxL,EACL,CAAP,EAAOA,G,kBAIL,YAAAzF,iBAAN,SAAuBsoB,G,YAAA,IAAAA,IAAAA,GAAA,G,4DAGrB,OAFAl3B,KAAK6f,KAAO,KAEPqX,EAGI,CAAP,EAAOl3B,KAAKkhC,4BAFL,CAAP,EAAOlhC,KAAKmhC,yB,QAMV,YAAAC,iBAAN,SAAuBzT,EAAwB0T,G,YAAA,IAAAA,IAAAA,EAAA,G,yFAC1B,SAAMrhC,KAAK82B,YAC5B,MACA,8DAAuDnJ,EAAQ,mBAAW0T,K,OAE5E,GAJMC,EAAa,UAIdv/B,MAAMwI,QAAQ+2B,EAAWjpB,MAC5B,MAAM,IAAI,EAAA4oB,8BAEZ,MAAO,CAAP,EAAOK,EAAWjpB,M,QAGd,YAAAkpB,gBAAN,W,uGAGE,OAFIj8B,EAAO,IAAI,EAAA9B,OAAO,CAAEhE,IAAK,EAAGK,SAAU,EAAAX,aAAaE,SAEvD,GAAM2E,EAASC,KACbhE,KAAKgL,OAAOy1B,WAAW12B,MAAM,KAAKrF,MAAM,IACxC,SAAM88B,GAAO,qC,qEACKl8B,EAAK3C,UAAY2C,EAAK3C,SAAS6B,QAAU,EAAAc,EAAK3C,S,OAA/C,M,OAA2D,SAAM3C,KAAKohC,iBAAiB97B,EAAK9F,K,OAAlC,EAAC,S,wBACtEiiC,EADW,EACiB79B,MAC9B,SAACN,GAAW,OAAAA,EAAO3D,QAAU6hC,CAAjB,KAEV,OAEIha,EAAO,CACXka,cAAep8B,EAAK9F,GACpBG,MAAO6hC,GAEI,GAAMxhC,KAAK82B,YACtB,OACA,iDACA,mBACAtP,K,OAEF,GAAyB,iBANnB7Q,EAAO,UAMG1S,KACd,MAAM,IAAI,EAAAg9B,8BAEZQ,EAAe,CAAEjiC,GAAImX,EAAK1S,KAAKzE,GAAImD,SAAU,GAAIhD,MAAOgX,EAAK1S,KAAKtE,O,wBAEpE2F,EAAO,IAAI,EAAA9B,OAAO,CAAEhE,GAAIiiC,EAAajiC,GAAIG,MAAO8hC,EAAa9hC,MAAOE,SAAU,EAAAX,aAAaE,S,aAE7F,I,OAEF,OA5BA,SA4BO,CAAP,EAAOkG,G,QAGH,YAAA47B,yBAAN,W,yGACM57B,EAAO,IAAI,EAAA9B,OAAO,CAAEhE,IAAK,EAAGK,SAAU,EAAAX,aAAaE,SACnDY,KAAKgL,OAAOy1B,WACP,GAAMzgC,KAAKuhC,mBADhB,M,OACFj8B,EAAO,S,iBAGO,OAAhB,EAAAA,EAAgB,GAAMtF,KAAK2hC,aAAar8B,EAAK9F,IAAK,I,OAElD,OAFA,EAAKmD,SAAW,SAChB3C,KAAKsF,KAAOA,EACL,CAAP,EAAOA,EAAKnE,S,QAGR,YAAAggC,uBAAN,W,2GACM77B,EAAO,IAAI,EAAA9B,OAAO,CAAEhE,IAAK,EAAGK,SAAU,EAAAX,aAAaE,SAEnDY,KAAKgL,OAAOy1B,WACP,GAAMzgC,KAAKuhC,mBADhB,M,OACFj8B,EAAO,S,iBAKgB,OAFzBtF,KAAK6f,KAAO,KACZva,EAAK1C,QAAS,EACd,EAAA0C,E,KAAyB,GAAMtF,KAAK4hC,eAAet8B,EAAK9F,K,OAExD,OAFA,EAAKuB,WAAc,EAAA8gC,KAAM,SAAkC,GAC3D7hC,KAAKsF,KAAOA,EAAKnE,OAAM,GAChB,CAAP,EAAOmE,G,QAGH,YAAAs8B,eAAN,SAAqBjU,G,mEACnB,MAAO,CAAP,EAAO3tB,KAAK82B,YACV,MACA,yDAAkDnJ,EAAQ,UAEzDmU,OAAM,WACL,MAAO,CAAEzpB,KAAM,IACjB,IACCR,MAAK,SAAClB,GACL,OAAOA,EAAK0B,IACd,I,QAGE,YAAAspB,aAAN,SAAmBhU,EAAwB0T,G,2GACpB,SAAMrhC,KAAK82B,YAC9B,MACA,yDAAkDnJ,EAAQ,4BAAoB0T,K,OA6BhF,OA/BMU,EAAe,SAIfp/B,EAAWo/B,EAAa1pB,KACxB2pB,EAAkB,SAACrU,EAAUhrB,GACjC,OAAOA,EAASc,KAAI,SAACQ,GACnB,GAAkB,aAAdA,EAAKnE,KAIP,MAHI,WAAYmE,GAA2C,OAAnC,EAAKs8B,4BAC3B,EAAKA,2BAA4B,GAE5B,IAAI,EAAA3/B,SAAS,CAClBpB,GAAIyE,EAAKzE,GAAK,IAAMmuB,EACpBhuB,MAAOsE,EAAKtE,MACZF,SAAUkuB,EACVjuB,IAAKuE,EAAK0W,QAAU1W,EAAKvE,IACzBG,SAAU,EAAAX,aAAaE,SAEpB,GAAkB,WAAd6E,EAAKnE,KAAmB,CACjC,IAAMmiC,EAAc,IAAI,EAAAz+B,OAAO,CAC7BhE,GAAIyE,EAAKzE,GACTC,SAAUkuB,EACVhuB,MAAOsE,EAAKtE,MACZE,SAAU,EAAAX,aAAaE,SAIzB,OAFA6iC,EAAYr/B,OAAS0e,QAAQrd,EAAKtB,UAClCs/B,EAAYt/B,SAAWq/B,EAAgB/9B,EAAKzE,GAAIyE,EAAKtB,UAAY,IAC1Ds/B,C,CAEX,GACF,EACO,CAAP,EAAOD,EAAgBrU,EAAUhrB,I,QAG7B,YAAA6S,mBAAN,SAAyBmY,EAAwBjf,G,2GAE/C,KADMpL,EAAStD,KAAKsF,KAAKjC,WAAWsqB,IAElC,MAAM,IAAI1tB,MAAM,gDAElB,OAAIqD,EAAOV,OACF,CAAP,EAAOU,EAAOnC,OAAM,GAAMwB,UAGxB+L,EACS,GAAM1O,KAAK2hC,aAAahU,GAAW,IAD5C,M,cACFhrB,EAAW,S,aAEA,SAAM3C,KAAK2hC,aAAahU,EAAU,I,OAa7C,OAbAhrB,EAAW,SACL,EAAU,SAAMA,GAAQ,qC,sCAC5B,MAAO,CAAP,EAAOoB,EAASC,KAAKrB,GAAU,SAAMY,GAAK,qC,wDACxC,OAAMA,aAAiB,EAAAC,OAGlBD,EAAMX,OAAP,MACiB,GAAM5C,KAAK4hC,eAAer+B,EAAM/D,KAHnD,I,OAGM0iC,EAAa,SACnB3+B,EAAMxC,UAAY,CAAE8gC,KAAMK,G,iBAE5B,SAAM,EAAQ3+B,EAAMZ,W,cAApB,S,aACC,G,QAEL,GAAM,EAAQA,I,OAAd,S,iBAKF,OAHAW,EAAOX,SAAWA,EAClBW,EAAOV,QAAS,EAChB5C,KAAKsF,KAAKhE,cACH,CAAP,EAAOgC,EAAOnC,OAAM,GAAMwB,U,QAGtB,YAAAuC,aAAN,SAAmB5B,G,wGAMjB,GALA,UAAO7C,IAAI,kCAAmC,CAAC6C,OAAM,IAC/C7D,EAAW6D,EAAO7D,SAClBE,EAAQ2D,EAAO3D,QAEfszB,EAAejzB,KAAKsF,KAAKjC,WAAW5D,IAExC,MAAM,IAAI,EAAAwyB,yBAMC,OAJPzK,EAAO,CACXka,cAAejiC,EACfE,MAAOA,GAEI,GAAMK,KAAK82B,YACtB,OACA,iDACA,mBACAtP,I,OAEF,GAAyB,iBANnB7Q,EAAO,UAMG1S,KACd,MAAM,IAAI,EAAAg9B,8BAOZ,OAJAhO,EAAatwB,SAAS8C,KACpB,IAAI,EAAAjC,OAAO,CAAEhE,GAAImX,EAAK1S,KAAKzE,GAAIG,MAAK,EAAEF,SAAQ,EAAEI,SAAU,EAAAX,aAAaE,UAEzEY,KAAKsF,KAAKhE,cACH,CAAP,EAAOqV,EAAK1S,KAAKzE,I,QAGb,YAAAyU,iBAAN,SAAuBxU,EAAwB6D,G,4GAC7C,IAAkC,IAA9BtD,KAAKsgC,qBACP,MAAM,IAAIrgC,MAAM,+CAElB,GAAIqD,EAAO1B,QAAU,GACnB,MAAM,IAAI3B,MAAM,kDAIlB,GAFA,UAAOQ,IAAI,gCAAiC,CAAEhB,SAAQ,EAAE6D,OAAM,MACxD2vB,EAAejzB,KAAKsF,KAAKjC,WAAW5D,IAExC,MAAM,IAAI,EAAAwyB,yBAENlH,EAAO,IAAIC,KACf,CACE,wCACA,wEACA,UAAe7D,UAAU7jB,IAE3B,CACExD,KAAM,eAIJ0nB,EAAO,IAAI2a,UACZC,OAAO,YAAarX,EAAM,e,iBAItB,O,sBAAA,GAAM/qB,KAAK82B,YAChB,OACA,yDAAkDr3B,EAAQ,WAC1D,sBACA+nB,I,cAJF7Q,EAAO,S,aAQP,M,WADA3W,KAAKsgC,sBAAuB,EACtB,E,OA8BR,OA3BM0B,EAAkB,SAACr/B,EAAUnD,EAAIG,EAAOF,GAC5C,OAAO,IAAI,EAAA+D,OAAO,CAChBhE,GAAE,EACFG,MAAK,EACLF,SAAQ,EACRI,SAAU,EAAAX,aAAaE,OACvBuD,SAAUA,EAASc,KAAI,SAACQ,GACtB,GAAkB,aAAdA,EAAKnE,KACP,OAAO,IAAI,EAAAc,SAAS,CAClBpB,GAAIyE,EAAKzE,GAAK,IAAMA,EACpBG,MAAOsE,EAAKtE,MACZD,IAAKuE,EAAK0W,QAAU1W,EAAKvE,IACzBD,SAAUD,EACVK,SAAU,EAAAX,aAAaE,SAEpB,GAAkB,WAAd6E,EAAKnE,KACd,OAAOkiC,EAAgB/9B,EAAKtB,SAAUsB,EAAKzE,GAAIyE,EAAKtE,MAAOH,GAG3D,MADAqK,QAAQpJ,IAAI,SAAUwD,GAChB,IAAIhE,MAAM,SAEpB,KAEJ,EACM2J,EAAWo4B,EAAgBrrB,EAAK0B,KAAM5Y,EAAU6D,EAAO3D,MAAO2D,EAAO7D,UAC3EwzB,EAAatwB,SAAWiH,EAASzI,OAAM,GAAMwB,SAC7C3C,KAAKsF,KAAKhE,cACH,CAAP,EAAOsI,G,QAGH,YAAAzE,aAAN,SAAmB7B,G,wGAIjB,GAHA,UAAO7C,IAAI,kCAAmC,CAAE6C,OAAM,IAChD9D,EAAK8D,EAAO9D,KACZmzB,EAAY3yB,KAAKsF,KAAKjC,WAAWC,EAAO9D,KAE5C,MAAM,IAAI,EAAAozB,yBAEZ,GAAID,EAAUtvB,WAAWC,EAAO7D,UAC9B,MAAM,IAAIQ,MAAM,iCAMlB,OAJMunB,EAAO,CACXka,cAAep+B,EAAO7D,SACtBE,MAAO2D,EAAO3D,OAEhB,GAAMK,KAAK82B,YACT,MACA,yDAAkDt3B,GAClD,mBACAgoB,I,OAGF,GAPA,WAMM6a,EAAkBriC,KAAKsF,KAAKjC,WAAWsvB,EAAUlzB,WAErD,MAAM,IAAI,EAAA6iC,+BAMZ,GAJAD,EAAgB1/B,SAAW0/B,EAAgB1/B,SAASK,QAClD,SAACO,GAAU,OAAA/B,OAAO+B,EAAM/D,MAAQgC,OAAOhC,EAA5B,MAEP+iC,EAAkBviC,KAAKsF,KAAKjC,WAAWC,EAAO7D,WAElD,MAAM,IAAI,EAAA8yB,uB,OAEZgQ,EAAgB5/B,SAAS8C,KAAKktB,GAC9BA,EAAUhzB,MAAQ2D,EAAO3D,MACzBgzB,EAAUlzB,SAAW6D,EAAO7D,SAC5BO,KAAKsF,KAAKhE,c,YAGN,YAAA6T,YAAN,SAAkB3V,EAAkB0U,G,gGAQlC,OAPA,UAAOzT,IAAI,iCAAkC,CAAEjB,GAAE,EAAE0U,MAAK,IAClDsT,EAAO,CACXnP,KAAMnE,EAAMzQ,KAAI,SAACQ,GAAS,OACxBzE,GAAIgC,OAAOyC,EAAKzE,IAAIuK,MAAM,KAAK,GAC/BjK,KAAMmE,EAAKnE,KAFa,KAK5B,GAAME,KAAK82B,YACT,QACA,yDAAkDt3B,EAAE,eACpD,mBACAgoB,I,cAJF,S,YAQI,YAAApiB,aAAN,SAAmB9B,G,oGAIjB,OAHA,UAAO7C,IAAI,kCAAmC,CAAE6C,OAAM,IAChD9D,EAAK8D,EAAO9D,IACZmzB,EAAY3yB,KAAKsF,KAAKjC,WAAW7D,IAIvC,GAAMQ,KAAK82B,YACT,SACA,yDAAkDt3B,KAJlD,I,cAEF,UAIMgG,EAASxF,KAAKsF,KAAKjC,WAAWsvB,EAAUlzB,aAE5C+F,EAAO7C,SAAW6C,EAAO7C,SAASK,QAChC,SAACO,GAAU,OAAA/B,OAAO+B,EAAM/D,MAAQgC,OAAOhC,EAA5B,IAEbQ,KAAKsF,KAAKhE,e,YAIR,YAAAkhC,aAAN,SAAmBhjC,G,kGAGJ,OAFb,UAAOiB,IAAI,4BAEE,GAAMT,KAAK82B,YACtB,MACA,oDAAsDt3B,I,OAExD,GAAyB,iBAJnBmX,EAAO,UAIG1S,KACd,MAAM,IAAI,EAAAg9B,8BAOZ,OAJMp9B,EAAK8S,EAAK1S,MACR6vB,QAAQtvB,SACdX,EAAGiwB,QAAU,CAAC,OAET,CAAP,EAAOjwB,EAAGiwB,QAAQrwB,KAAI,SAAChE,GACrB,OAAO,IAAI,EAAAmB,SAAS,CAClBpB,GAAIqE,EAAGrE,GAAK,IAAMC,EAClBC,IAAKmE,EAAG8W,QAAU9W,EAAGnE,IACrBC,MAAOkE,EAAGlE,MACVF,SAAUA,EACVG,KAAMiE,EAAGjE,KACTC,SAAU,EAAAX,aAAaE,QAE3B,K,QAGI,YAAAqjC,oBAAN,SAA0B/iC,G,2GACpBA,EAAIsX,cAAcnH,WAAW,eAC1B7P,KAAKugC,0BAGG,GAAMvgC,KAAK82B,YACtB,MACA,4EAAqErH,mBACnE,kBALK,CAAP,GAAO,GAFP,M,OAUF,OANM,EAAO,UAMJpX,KAAK7T,SACNb,EAAW,EAAK0U,KAAKzU,MAAK,SAAAD,GAAY,OAAAA,EAASgX,SAAWjb,CAApB,KAEnC,CAAP,SAAWiE,GAAQ,CAAElE,SAAUkE,EAASmwB,QAAQ,GAAIp0B,IAAG,KAKlD,CAAP,GAAO,G,OAGE,SAAMM,KAAK82B,YACtB,MACA,+DAAwDrH,mBACtD/vB,M,OAGJ,OANMiX,EAAO,UAMJ0B,KAAK7T,OACL,CAAP,SAAWmS,EAAK0B,KAAK,IAAE,CAAE5Y,SAAUkX,EAAK0B,KAAK,GAAGyb,QAAQ,GAAIp0B,IAAG,KAExD,CAAP,GAAO,G,QAIL,YAAA0C,eAAN,SAAqByB,G,8EAKnB,OAJA,UAAOpD,IAAI,4BAA6BoD,GAIjC,CAAP,EAAO7D,KAAKwgC,aAAanjB,QAAQxZ,EAAGnE,KAAK,gD,oEAEvC,GAAIM,KAAKsF,QACPi9B,EAAkBviC,KAAKsF,KAAKjC,WAAWQ,EAAGpE,WAExC,MAAM,IAAI,EAAAwyB,yBAIW,SAAMjyB,KAAKyiC,oBAAoB5+B,EAAGnE,M,cAArDgjC,EAAmB,WAEvB7+B,EAAGrE,GAAKkjC,EAAiBljC,GAAK,IAAMqE,EAAGpE,UACjCkjC,EAAkB9+B,EAAG1C,SACXxB,MAAQ+iC,EAAiB/iC,MACzC,GAAMK,KAAKsC,eAAeqgC,KAJxB,M,cAIF,S,aAEMnb,EAAO,CACX9nB,IAAKmE,EAAGnE,IACRC,MAAOkE,EAAGlE,MACVm0B,QAAS,CAACjwB,EAAGpE,WAGXkX,OAAI,E,iBAEC,O,sBAAA,GAAM3W,KAAK82B,YAChB,OACA,mDACA,mBACAtP,I,cAJF7Q,EAAO,S,aAOP,I,sBAAiB,EAAAgL,UACf,MAAM,IAAI,EAAAS,oBAAoBve,GAEhC,MAAM,E,OAER,GAAyB,iBAAd8S,EAAK1S,KACd,MAAM,IAAI,EAAAg9B,8BAEZp9B,EAAGrE,GAAKmX,EAAK1S,KAAKzE,GAAK,IAAMqE,EAAGpE,S,iBAWlC,OARMmjC,EAAe/+B,EAAG1C,SACX3B,GAAKqE,EAAGrE,GAAGuK,MAAM,KAAK,GACnC/J,KAAK6f,MAAQ7f,KAAK6f,KAAKpa,KAAKm9B,GACxB5iC,KAAKsF,OACPi9B,EAAgB5/B,SAAS8C,KAAKm9B,GAC9B5iC,KAAKsF,KAAKhE,eAGL,CAAP,EAAOuC,EAAGrE,I,kBAIR,YAAA8C,eAAN,SAAqB4vB,G,oFAOnB,OANA,UAAOzxB,IAAI,4BAA6ByxB,GAElC,EAA4B1wB,OAAO0wB,EAAM1yB,IAAIuK,MAAM,KAAlD84B,EAAU,KAAEC,EAAW,KAIvB,CAAP,EAAO9iC,KAAKwgC,aAAanjB,QAAQwlB,GAAY,gD,qEAC/B,SAAM7iC,KAAKwiC,aAAaK,I,OAGpC,GAHMjH,EAAM,WAENpJ,EAAYxyB,KAAKsF,KAAKjC,WAAW6uB,EAAMzyB,WAE3C,MAAM,IAAI,EAAAwyB,yBAGNzK,EAAO,CACX9nB,IAAKwyB,EAAMxyB,IACXC,MAAOuyB,EAAMvyB,MACbm0B,QAAS8H,EACNn4B,KAAI,SAACI,GAAO,OAAAA,EAAGpE,QAAH,IACZuD,QACC,SAACvD,GACC,OAAAA,GAAY+B,OAAO/B,KAAc+B,OAAOshC,MAEtC,EAAKx9B,KAAKjC,WAAW5D,IAAa,EAAK6F,KAAKjC,WAAW5D,GAAUgC,eAAe,YAAY,SAAA4C,GAAK,OAAAA,EAAE3D,aAAawxB,EAAf,MAA2B,EAAK5sB,KAAKjC,WAAW5D,GAAUmD,OAF7J,IAIH4O,OAAO,CAAC0gB,EAAMzyB,WACjBG,KAAMg8B,EAAI,GAAGh8B,M,iBAIb,O,sBAAA,GAAMI,KAAK82B,YACT,MACA,2DAAoD+L,GACpD,mBACArb,I,cAJF,S,aAOA,I,sBAAiB,EAAA7F,UACf,MAAM,IAAI,EAAAU,oBAAoB6P,GAEhC,MAAM,E,OASR,OANKM,EAAU7vB,SAASiB,MAAK,SAAAK,GAAQ,OAAAzC,OAAOyC,EAAKzE,MAAQgC,OAAO0wB,EAAM1yB,KAAqB,aAAdyE,EAAKnE,IAA7C,KACnC0yB,EAAU7vB,SAAS8C,KAAKysB,GAE1BA,EAAM1yB,GAAKqjC,EAAa,IAAM3Q,EAAMzyB,SACpCO,KAAKsF,KAAKhE,cAEH,CAAP,EAAO4wB,EAAM1yB,I,kBAIX,YAAAgD,eAAN,SAAqBmB,G,sFAMnB,OALA,UAAOlD,IAAI,4BAA6B,CAAEkD,SAAQ,IAC5CnE,EAAKmE,EAASnE,GACd,EAAyBgC,OAAOhC,GAAIuK,MAAM,KAAzC84B,EAAU,KAAEpjC,EAAQ,KAGpB,CAAP,EAAOO,KAAKwgC,aAAanjB,QAAQwlB,GAAY,gD,4DAEzC,O,sBAAA,GAAM7iC,KAAK82B,YACT,SACA,yDAAkDr3B,EAAQ,sBAAcojC,K,OAG7D,OALb,SAKa,GAAM7iC,KAAKghC,oB,cAAlBnhB,EAAO,SACPkjB,EAAYljB,EAAKmJ,WACrB,SAACrlB,GAAa,OAAAnC,OAAOmC,EAASnE,MAAQgC,OAAOqhC,EAA/B,IAEhBhjB,EAAK9M,OAAOgwB,EAAW,G,+BAEvB,UAAOtiC,IAAI,wCAA0C,EAAEkF,QAAU,iB,yCAKjE,YAAAi7B,4BAAN,W,kGACE,GAAuC,OAAnC5gC,KAAKugC,0BACP,U,iBAGa,O,uBAAA,GAAMvgC,KAAK82B,YACtB,MACA,oE,WAFIngB,EAAO,UAIH0B,KAAK7T,OAAX,YACFxE,KAAKugC,2BAA4B,E,iBAEpB,O,sBAAA,GAAMvgC,KAAKoC,eAAe,IAAI,EAAAxB,SAAS,CAACpB,GAAI,KAAMC,SAAU,KAAME,MAAO,UAAWD,IAAK,qBAAsBG,SAAU,EAAAX,aAAaE,W,OACjJ,OADMI,EAAK,SACX,GAAMQ,KAAKwC,eAAe,IAAI,EAAA5B,SAAS,CAACpB,GAAE,EAAEC,SAAU,KAAME,MAAO,UAAWD,IAAK,qBAAsBG,SAAU,EAAAX,aAAaE,W,cAAhI,S,6BAEAY,KAAKugC,2BAA4B,E,aAEnC,U,cAEFvgC,KAAKugC,0BAA4B,WAAY5pB,EAAK0B,KAAK,G,8BAEvDrY,KAAKugC,2BAA4B,E,iCAI/B,YAAAzJ,YAAN,SAAkBY,EAAaC,EAAe73B,EAAoB0nB,EAAiBoQ,G,YAArC,IAAA93B,IAAAA,EAAA,WAAoB,IAAA0nB,IAAAA,EAAA,WAAiB,IAAAoQ,IAAAA,GAAA,G,8HAKjF,GAJMl4B,EAAMM,KAAK+iB,mBAAmB/iB,KAAKgL,OAAOtL,KAAOi4B,EAEnDE,GAAW,EAEX/3B,GAAQA,EAAK2W,SAAS,oBACxB+Q,EAAOvmB,KAAKC,UAAUsmB,QACjB,GAAI1nB,GAAQA,EAAK2W,SAAS,qCAAsC,CAErE,IADMsC,EAAS,IAAI8W,gBACd,EAAL,EAA2B,EAAA/sB,OAAO0T,QAAQgR,GAAQ,CAAC,GAAxB,eAAhB,OAACngB,EAAG,KAAEkmB,EAAK,KACpBxU,EAAOhQ,IAAI1B,EAAKkmB,GAElB/F,EAAOzO,EAAOxS,U,CAKhB,GAFA,UAAO9F,IAAI,kBAAWi3B,EAAI,YAAIh4B,IAEE,QAA5B,EAAA0X,UAAUC,cACZ,MAAO,CAAP,EAAOrX,KAAK83B,kBAAkBJ,EAAMh4B,EAAKI,EAAM0nB,EAAMoQ,IAGjDlT,EAAa,EAAAC,OAAO7e,OACxB9F,KAAKgL,OAAO2U,SAAW,IAAM3f,KAAKgL,OAAO4U,U,iBAInC,O,sBAAA,GAAM5f,KAAK02B,WAAW1C,KAAI,WAE9B,OADA,UAAOvzB,IAAI,mBAAYi3B,EAAI,YAAIh4B,IACxBwE,QAAQ6zB,KAAK,CAClBnT,MAAMllB,EAAK,EAAF,CACPmiB,OAAQ6V,EACR7S,YAAa,EAAK7Z,OAAO4X,mBAAqB,UAAY,OAC1DsB,QAAS,EAAF,KACDpkB,GAAiB,wBAATA,GAAkC,CAAE,eAAgBA,IAAO,CACvEglB,cAAe,SAAWJ,IAE5BK,OAAQ,EAAKC,aACTwC,IAAS,CAAC,MAAO,QAAQ/Q,SAASihB,EAAK1gB,gBAAkB,CAAEwQ,KAAI,KAErE,IAAItjB,SAAQ,SAACC,EAASkW,GACpB,OAAA0J,YAAW,WACT8T,GAAW,EACXxd,EAAO,IAAI,EAAA2d,oBACb,GAAGvB,EAHH,KAMN,K,cApBAxS,EAAM,S,aAsBN,G,WAAI4T,EAAU,MAAM,EACpB,GAAI73B,KAAK0L,SAAU,MAAM,IAAI,EAAAoB,mBAE7B,MADAjD,QAAQpJ,IAAI,GACN,IAAI,EAAAinB,a,OAKZ,GAFA,UAAOjnB,IAAI,iCAA0Bi3B,EAAI,YAAIh4B,IAEzCukB,EAAIgU,aAAej4B,KAAKgL,OAAO6X,eACjC,MAAM,IAAI,EAAA8E,cAGZ,GAAIiQ,EACF,MAAO,CAAP,EAAO3T,GAGT,GAAmB,MAAfA,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAC5B,MAAM,IAAI,EAAA0D,oB,OAEO,MAAfrB,EAAIrC,QAAkBqC,EAAIrC,QAAU,KACtC,gBAAOnhB,IAAI,YAAGi3B,EAAI,YAAIh4B,EAAG,mCAA2BukB,EAAIrC,OAAM,MAAQ,GAAMqC,EAAI6D,SAD9E,M,OAEF,MADA,WAAW,EAA2D,SAAkB5B,UAAU,EAAG,OAC/F,IAAI,EAAAvE,UAAUsC,EAAIrC,OAAQ8V,G,OAIzB,O,sBAAA,GAAMzT,EAAItN,Q,cAAjBA,EAAO,S,aAEP,M,WAAM,IAAI,EAAAmL,mBAAmB,EAAEnc,S,OAEjC,GAAoB,YAAhBgR,EAAKiL,OACP,MAAM,IAAI3hB,MAAM,mCAAqCy3B,EAAO,IAAMC,EAAS,QAAU12B,KAAKC,UAAUyV,IAGtG,MAAO,CAAP,EAAOA,G,QAGK,YAAAkqB,YAAd,W,8EAmBE,OAlBA7gC,KAAKskB,eAAkB,8B,wDACT,SAAMtkB,KAAK82B,YACrB,OACA,+CACA,KACA,MACA,I,OAGF,GAAmB,OARb7S,EAAM,UAQJrC,QAAiC,MAAfqC,EAAIrC,OAC5B,MAAM,IAAI,EAAA0D,oBAEZ,GAAmB,MAAfrB,EAAIrC,QAAiC,MAAfqC,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAClD,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQ,QAGlC,MAAO,CAAP,EAAsB,MAAfqC,EAAIrC,QAAiC,MAAfqC,EAAIrC,Q,OAE5B,CAAP,EAAO5hB,KAAKskB,e,QAGA,YAAAwc,YAAd,W,iGACM9gC,KAAKskB,eACP,GAAMtkB,KAAKskB,gBADT,M,OACF,S,iBAEF,OAAKtkB,KAAKuiB,OAGE,GAAMviB,KAAK82B,YACrB,SACA,+CACA,KACA,MACA,IAPA,I,OAUF,MAAO,CAAP,EAAsB,MARV,SAQDlV,Q,QAGC,YAAAkW,kBAAd,SAAgCJ,EAAch4B,EAAaI,EAAc0nB,EAAWoQ,G,+GAE9EC,GAAW,EACTnT,EAAa,EAAAC,OAAO7e,OACxB9F,KAAKgL,OAAO2U,SAAW,IAAM3f,KAAKgL,OAAO4U,U,iBAGnC,O,sBAAA,GAAM5f,KAAK02B,WAAW1C,KAAI,WAE9B,OADA,UAAOvzB,IAAI,mBAAYi3B,EAAI,YAAIh4B,IACxBwE,QAAQ6zB,KAAK,CAClB,gBAAK7S,QAAQ,EAAD,CACVxlB,IAAG,EACHmiB,OAAQ6V,EACRQ,kBAAmB,EAAKltB,OAAO6X,eAC/BqB,QAAS,EAAF,KACDpkB,GAAiB,wBAATA,GAAkC,CAAE,eAAgBA,IAAO,CACvEglB,cAAe,SAAWJ,IAE5BsD,aAAc,QACVR,IAAS,CAAC,MAAO,QAAQ/Q,SAASihB,EAAK1gB,gBAAkB,CAAEqB,KAAMmP,KAEvE,IAAItjB,SAAQ,SAACC,EAASkW,GACpB,OAAA0J,YAAW,WACT8T,GAAW,EACXxd,EAAO,IAAI,EAAA2d,oBACb,GAAGvB,EAHH,KAMN,K,cArBAxS,EAAM,S,aAuBN,G,WAAI4T,EAAU,MAAM,EAEpB,MADAhuB,QAAQpJ,IAAI,GACN,IAAI,EAAAinB,a,OAKZ,GAFA,UAAOjnB,IAAI,iCAA0Bi3B,EAAI,YAAIh4B,IAEzCukB,EAAIrC,OAAS,KAAOqC,EAAIrC,QAAU,IACpC,MAAM,IAAI,EAAA+F,cAGZ,GAAIiQ,EACF,MAAO,CAAP,EAAO3T,GAGT,GAAmB,MAAfA,EAAIrC,QAAiC,MAAfqC,EAAIrC,OAC5B,MAAM,IAAI,EAAA0D,oBAEZ,GAAmB,MAAfrB,EAAIrC,QAAkBqC,EAAIrC,QAAU,IACtC,MAAM,IAAI,EAAAD,UAAUsC,EAAIrC,OAAQ8V,GAGlC,GAAoB,aADd/gB,EAAOsN,EAAI5L,MACRuJ,OACP,MAAM,IAAI3hB,MAAM,mCAAqCy3B,EAAO,IAAMh4B,EAAM,QAAUuB,KAAKC,UAAUyV,IAGnG,MAAO,CAAP,EAAOA,G,QAGT,YAAAsH,YAAA,WACE,OAAO/Z,QAAQC,SAAQ,EACzB,EAEM,YAAA6+B,WAAN,SAAiBtjC,G,gGAEb,O,sBAAA,GAAMM,KAAK82B,YACT,OACA,yDACA,mBACA,CACEp3B,IAAG,K,cALP,S,+BASAmK,QAAQC,KAAK,G,+BAGnB,EAl6BA,G,gxBC/DA,cACA,cAEA,0BAmCA,QAlCE,YAAAqd,UAAA,SAAU7jB,GACR,MAAO,mBAAYtD,KAAKmzB,iBAAiB7vB,EAAQ,IAAG,aACtD,EAEA,YAAA2/B,qBAAA,SAAqB74B,GACnB,OAAOA,EAAOT,QAAQ,YAAY,SAAAu5B,GAAQ,WAAOA,EAAKC,WAAW,GAAK,GAA5B,GAC5C,EAEA,YAAAhQ,iBAAA,SAAiB7vB,EAAQ8/B,GAAzB,WACE,OAAO9/B,EAAOX,SACXc,KAAI,SAAAF,GACH,GAAIA,aAAiB,EAAA3C,SACnB,MACE,UAAGwiC,EAAM,wBAAgB,EAAKH,qBAAqB1/B,EAAM7D,KAAI,mBAAW,GAAE,iBAAS6D,EAAM/D,GAAE,aAAK,EAAKyjC,qBAAqB1/B,EAAM5D,OAAM,UAEnI,GAAI4D,aAAiB,EAAAC,OAAQ,CAClC,IAAM6/B,EAAaD,EAAS,KAC5B,MACE,UAAGA,EAAM,uBAAe7/B,EAAM/D,GAAE,aAAK,EAAKyjC,qBAAqB1/B,EAAM5D,OAAM,WAC3E,UAAGyjC,EAAM,oBAAY,EAAKjQ,iBACxB5vB,EACA8/B,IACD,OAAGD,EAAM,a,CAGhB,IACCnhC,KAAK,GACV,EAEA,YAAAmkB,YAAA,SAAYkd,GACV,IAAMpuB,GAA6C,IAAAquB,eAAcD,GAEjE,OADApuB,EAAMnQ,SAAQ,SAAAy+B,GAAOA,EAAE/jC,SAAW,GAAI,IAC/B,IAAI,EAAA+D,OAAO,CAAChE,GAAI,IAAKG,MAAO,OAAQgD,SAAUuS,EAAOrV,SAAU,EAAAX,aAAaE,OAAQW,QAAQ,GACrG,EACF,EAnCA,GAqCA,UAAe,IAAI0jC,EAMN,EAAAC,cAAgB,SAAClc,GAC5B,IAAMmc,EAAKnc,EAAK5jB,KAAK,MAAMggC,QAI3B,MAF+D,iBAAvCD,EAAGE,KAAK,2BAGvBrc,EAAK7kB,SAAS,MAAMihC,QAGiB,iBAAtBD,EAAGE,KAAK,UAGvBrc,GAGkC,iBAAvBmc,EAAGE,KAAK,YAMVF,EAAG7b,OAHZN,EAAK7kB,SAAS,MAAMihC,QAU/B,EAEa,EAAAL,cAAgB,SAACr5B,GAC5B,IAAM45B,EAAIC,EAAQt6B,KAAKS,GAEjBsd,EAAOsc,EAAE,QACThqB,EAA4C,GAC5CkqB,GAAM,IAAAN,eAAclc,GAAM7kB,SAAS,MAEnCshC,EAAY,SAAC3b,EAA4B7oB,GAC7C,IAAMykC,EAAM5b,EAAK3lB,WAAWwhC,GAAG,GACzBxkC,OAA8B,IAAfukC,EAAIpc,OAAyBoc,EAAIpc,OAAS,GAC3DpoB,EAAM,GACJF,OAA+B,IAAnB0kC,EAAIL,KAAK,MAAwBK,EAAIL,KAAK,MAAQ,GAChElhC,EAAgD,GAEpD,OAAQuhC,EAAI,GAAG38B,MACb,IAAK,KAUH,OADA5E,EAPW2lB,EAAK3lB,SAAS,MAAMihC,QAChBjhC,WAEAyhC,UAAU3gC,KAAI,SAAC4gC,GAC5B,MAAiB,OAAbA,EAAI98B,KAAsB,KACvB08B,EAAUH,EAAEO,GAAM7kC,EAC3B,IACcwD,QAAO,SAACiB,GAAS,OAAS,OAATA,CAAA,IACxB,IAAI,EAAAT,OAAO,CAAChE,GAAE,EAAEG,MAAK,EAAEF,SAAQ,EAAEkD,SAAQ,EAAE9C,SAAU,EAAAX,aAAaE,SAC3E,IAAK,IAGH,OADAM,EAAMwkC,EAAIL,KAAK,SAAW,GACnB,IAAI,EAAAjjC,SAAS,CAACpB,GAAE,EAAEG,MAAK,EAAED,IAAG,EAAED,SAAQ,EAAEI,SAAU,EAAAX,aAAaE,SAE1E,MAAM,IAAIa,MAAM,kBAClB,EAQA,OANA+jC,EAAIhgC,MAAK,SAAC80B,EAAG70B,GACX,IAAMqkB,EAAOwb,EAAE7/B,GACTV,EAAQ0gC,EAAU3b,GACxBxO,EAAKrU,KAAKlC,EACZ,IAEOuW,CACT,C,83FCtHA,iBACA,cACA,cACA,cACA,UACA,cACA,WAEA,cACA,aAEMjP,EAAqB,GAE3B,2B,8CAqUA,QArUuD,OAMrD,YAAA4B,aAAA,SAAaC,GACX1M,KAAK0M,UAAYA,CACnB,EAEA,YAAAZ,oBAAA,WACE,MAAO,CAEL,kBACA,mBAGA,aACA,iBAGA,iBAEJ,EAEM,YAAAiB,SAAN,W,iHAuD0B,OAtDlBK,EAAmBpN,KAAK8K,SAASuC,cAEjC2C,EAAc,GACdE,EAAe,IAAI,UACvBlQ,KAAKmL,eACLnL,KAAKkL,eAEL,SAACuF,EAAYD,GACX,OAAIA,EAAU1Q,OAAS2Q,EAAW3Q,OAIV,aAApB2Q,EAAW3Q,MAA0C,aAAnB0Q,EAAU1Q,MAAuB2Q,EAAW/Q,MAAQ8Q,EAAU9Q,OAGhG+Q,EAAW/P,aAAa8P,MAIxB,UAASH,SAASjD,EAAkBqD,EAAYD,MAHlDR,EAAYvK,KAAK,CAAC+K,EAAWC,KACtB,EAOX,GACAzQ,KAAKyE,eACL,GACA,GAEI6L,EAAgB,IAAI,UACxBtQ,KAAKkL,cACLlL,KAAKmL,gBACL,SAACqF,EAAWC,GACV,OAAIA,EAAW3Q,OAAS0Q,EAAU1Q,OAIV,aAApB2Q,EAAW3Q,MAA0C,aAAnB0Q,EAAU1Q,MAAuB2Q,EAAW/Q,MAAQ8Q,EAAU9Q,OAGhG+Q,EAAW/P,aAAa8P,MAIxB,UAASH,SAASjD,EAAkBqD,EAAYD,MAHlDR,EAAYvK,KAAK,CAAC+K,EAAWC,KACtB,EAOX,GACAzQ,KAAKyE,eACL,GACA,GAEsB,GAAMyL,EAAaK,O,OAClB,OADnBnF,EAAkB,SACC,GAAMkF,EAAcC,O,OAC7C,OADMlF,EAAmB,SACzB,GAAMtH,EAASN,IAAIuM,GAAa,SAAC,G,IAACQ,EAAS,KAAEC,EAAU,KACrD,OAAO,EAAKC,WAAW,EAAK1F,OAAQwF,EAAWC,EAAWjR,GAC5D,K,OAEA,OAJA,SAIO,CAAP,EAAO,CAAC4L,gBAAe,EAAEC,iBAAgB,I,QAGrC,YAAA8D,aAAN,SAAmBhE,G,gGAEU,OAD3B,UAAO1K,IAAI,sCACX,EAAA0K,EAA2B,GAAMnL,KAAKgL,OAAO4D,kBAAiB,I,cAA9D,EAAejM,SAAY,SAA0CA,S,YAGjE,YAAAgK,KAAN,W,8GAIE,OAHA3M,KAAKiL,WAAW,KAEhBjL,KAAK4M,eAAiB5M,KAAK0M,YAAc,EAAAxN,aAAaE,OAAS,EAAAF,aAAaC,MAAQ,EAAAD,aAAaE,OACjG,GAAMY,KAAK6M,e,OAIX,GAJA,SAEA7M,KAAKiL,WAAW,KAEZjL,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mB,OAGZ,UAAOrM,IAAI,CAACyK,cAAelL,KAAKkL,cAAeC,eAAgBnL,KAAKmL,eAAgBe,cAAelM,KAAKkM,gBAEnGlM,KAAKoL,iBAAoBpL,KAAKqL,iBAA/B,MAC4C,GAAMrL,KAAK+M,Y,OAAnD,EAAwC,SAAtC3B,EAAe,kBAAEC,EAAgB,mBACzC,UAAO5K,IAAI,CAAE2K,gBAAe,EAAEC,iBAAgB,IAC9CrL,KAAKoL,gBAAkBA,EACvBpL,KAAKqL,iBAAmBA,EACxBrL,KAAKiL,WAAW,K,iBAGlB,GAAIjL,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mB,OAMR9M,KAAK0M,YAAc,EAAAxN,aAAaE,QAClCuR,EAAmB3Q,KAAKoL,gBACxBwF,EAAmB5Q,KAAKqL,iBACxBsP,EAAS3a,KAAKgL,SAEd2F,EAAmB3Q,KAAKqL,iBACxBuF,EAAmB5Q,KAAKoL,gBACxBuP,EAAS3a,KAAK+K,WAKX/K,KAAKskC,WAAN,OACF,EAAAtkC,KAAkB,GAAMA,KAAKukC,WAAW3zB,EAAkBD,EAAkB3Q,KAAK0M,a,OAAjF,EAAK43B,WAAa,SAClB,UAAO7jC,IAAI,CAAC6jC,WAAYtkC,KAAKskC,a,iBAG/B,GAAItkC,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBASZ,GANA9M,KAAKuL,eAAiBzI,OAAOC,OAAO/C,KAAKskC,YAAYlgC,QAAO,SAAC+J,EAAKC,GAAS,OAAAA,EAAKC,aAAa7J,OAAS2J,CAA3B,GAAgC,GAEvGnO,KAAK0M,YAAc,EAAAxN,aAAaC,OAClCa,KAAK8N,cAAc9N,KAAKskC,WAAW72B,QAGjCzN,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAaZ,OAVA,UAAOrM,IAAI,aAAeT,KAAK0M,UAAY,gBAE3C1M,KAAKwkC,eAAiB,CACpBl3B,OAAQ,IAAI,UACZC,OAAQ,IAAI,UACZC,KAAM,IAAI,UACVC,OAAQ,IAAI,UACZC,QAAS,IAAI,WAGf,GAAM1N,KAAKykC,cAAc9pB,EAAQ3a,KAAKskC,WAAYtkC,KAAK0M,UAAW1M,KAAKwkC,eAAgB7zB,EAAiBjD,U,cAAxG,SAEI,gBAAiB1N,KAAKgL,SAAWhL,KAAK0kC,iBAClCt3B,EAAmBpN,KAAK8K,SAASuC,cACvC,UAAO5M,IAAI,uBACXT,KAAK0kC,eAAiB/zB,EAAiBjD,QAAQjK,IAAI2J,EAAkBpN,KAAK0M,YAGxE,gBAAiB1M,KAAKgL,QAAU,gBAAiB2P,EACnD,GAAM3a,KAAK2O,mBAAmBgM,EAAQ3a,KAAK0kC,iBADzC,M,OACF,S,mCAIE,YAAAH,WAAN,SACE3zB,EACAD,EACAvE,G,yGAcA,OAZMgB,EAAmBpN,KAAK8K,SAASuC,cAEjCs3B,EAAgC,CACpCr3B,OAAQ,IAAI,UACZC,OAAQ,IAAI,UACZC,KAAM,IAAI,UACVC,OAAQ,IAAI,UACZC,QAASkD,EAAiBlD,QAAQvM,SAKpC,GAAM4C,EAASC,KAAK2M,EAAiBrD,OAAOe,cAAc,SAAMkB,GAAM,qC,0DAEpD,SAAMvP,KAAK4kC,sBAAsBr1B,EAAO5H,QAASyF,EAAkBhB,I,cAA7EzE,EAAU,SACVwI,EAAUZ,EAAO5H,QACvBA,EAAQrG,cACR6O,EAAQ7O,cAERqjC,EAAUr3B,OAAOwE,OAAO,EAAD,KAAKvC,GAAM,CAAEzP,KAAM,EAAAyS,WAAWjF,OAAQ3F,QAAO,EAAEwI,QAAO,K,aAC5EtF,I,OAEH,OAVA,SAUA,GAAM9G,EAASC,KAAK4M,EAAiBtD,OAAOe,cAAc,SAAMkB,GAAM,qC,kCACpEo1B,EAAUl3B,OAAOqE,OAAO,EAAD,KAAMvC,GAAM,CAAEzP,KAAM,EAAAyS,WAAW9E,U,YACrD5C,I,OAEH,OAJA,SAIA,GAAM9G,EAASC,KAAK4M,EAAiBrD,OAAOc,cAAc,SAAMkB,GAAM,qC,0CAC9D5H,EAAU4H,EAAOY,QAAQ9O,mBAAkB,EAAOkO,EAAO5H,QAAQ9H,WAC/DL,GAAK+P,EAAO5H,QAAQnI,GAC5BmI,EAAQlI,SAAW8P,EAAO5H,QAAQlI,UAE5B0Q,EAAUZ,EAAO5H,QAAQtG,mBAAkB,EAAOkO,EAAOY,QAAQtQ,WAC/DL,GAAK+P,EAAOY,QAAQ3Q,GAC5B2Q,EAAQ1Q,SAAW8P,EAAOY,QAAQ1Q,SAClCklC,EAAUp3B,OAAOuE,OAAO,CAAEhS,KAAM,EAAAyS,WAAWhF,OAAQ5F,QAAO,EAAEwI,QAAO,I,YAClEtF,I,OAEH,OAXA,SAWA,GAAM9G,EAASC,KAAK4M,EAAiBpD,KAAKa,cAAc,SAAMkB,GAAM,qC,wCAC5D5H,EAAU4H,EAAO5H,QAAQtG,mBAAkB,EAAOkO,EAAOY,QAAQtQ,WAC/DL,GAAK+P,EAAOY,QAAQ3Q,GAC5BmI,EAAQlI,SAAW8P,EAAOY,QAAQ1Q,SAElCklC,EAAUn3B,KAAKsE,OAAO,CAAEhS,KAAM,EAAAyS,WAAW/E,KAAM7F,QAAO,I,YACrDkD,I,OAEH,OARA,SAQO,CAAP,EAAO85B,G,QAGK,YAAAC,sBAAd,SAAwF3gC,EAAiBmJ,EAAmCy3B,G,gHACpIz0B,EAAUnM,EAAK5C,mBAAkB,EAAOwjC,IACtCrlC,GAAK,UAASyT,MAAM7F,EAAkBnJ,EAAM4gC,GACpDz0B,EAAQ3Q,SAAW,UAASuS,YAAY5E,EAAkBnJ,EAAM4gC,GAC5Dz0B,aAAmB,EAAA5M,QACf,EAAmB,GACzB,GAAM4M,EAAQtM,UAAS,SAAMP,EAAO0vB,GAAY,qC,kCAC9C1vB,EAAM/D,GAAK,UAASyT,MAAM7F,EAAkB7J,EAAOshC,QAC3B,IAAbthC,EAAM/D,IACf,EAAiBiG,KAAKlC,GAExBA,EAAM9D,SAAWwzB,EAAazzB,G,eAP9B,M,cAEF,SAOA4Q,EAAQ9O,cAER,EAAiByD,SAAQ,SAAAd,GACvB,IAAMX,EAAS8M,EAAQ/M,WAAWY,EAAKxE,UACvC6D,EAAOX,SAAWW,EAAOX,SAASK,QAAO,SAAAqB,GAAK,OAAAA,EAAE7E,EAAF,GAChD,I,aAEA4Q,EAAQ9O,c,iBAEV,MAAO,CAAP,EAAO8O,G,QAGH,YAAAq0B,cAAN,SACEtiC,EACA2iC,EACA14B,EACAiH,EACAC,G,6GACA,UAAO7S,IAAI,6BAA+B2L,GAEtCmH,EAAgBuxB,EAAWx3B,OAAOe,a,wBAC/BkF,EAAc/O,OAAS,GAC5B,UAAO/D,IAAI2L,EAAiB,uBAC5B,GAAMrI,EAASC,KACbuP,GACA,SAAChE,GAAW,SAAKiE,cAAcrR,EAAUoN,EAAQnD,EAAgB04B,EAAWx3B,OAAQgG,EAAUD,EAAlF,GACZxI,KAL2B,M,cAE7B,SAKA0I,EAAgBuxB,EAAWx3B,OAAOe,a,aAGpC,GAAIrO,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAKZ,OAFA,UAAOrM,IAAI2L,EAAiB,uBAE5B,GAAMrI,EAASC,KACb8gC,EAAWv3B,OAAOc,cAClB,SAACkB,GAAW,SAAKkE,cAActR,EAAUoN,EAAQnD,EAAgB04B,EAAWv3B,OAAQ8F,EAAxE,GACZxI,I,OAGF,GANA,SAMI7K,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAOZ,GAJMM,EAAmBpN,KAAK8K,SAASuC,cAEjC03B,EAAcD,EAAWt3B,KAAK/J,IAAI2J,EAAkBhB,GAEtDpM,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAKZ,GAFM6G,EAAU,UAAKC,UAAUmxB,EAAY12B,aAAcrO,KAAKmM,cAAcC,IAExEpM,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAIZ,OADA,UAAOrM,IAAI2L,EAAiB,qBAC5B,GAAMrI,EAASC,KAAK2P,GAAS,SAAAE,GAAS,OAAA9P,EAASC,KAAK6P,GAAO,SAACtE,GAC1D,OAAO,EAAKkE,cAActR,EAAUoN,EAAQnD,EAAgB24B,EAAa1xB,EAC3E,GAAGxI,EAFmC,GAEd,I,OAExB,GAJA,SAII7K,KAAK0L,SACP,MAAM,IAAI,EAAAoB,mBAIZ,OADA,UAAOrM,IAAI2L,EAAiB,uBAC5B,GAAMrI,EAASC,KAAK8gC,EAAWr3B,OAAOY,cAAc,SAACkB,GACnD,OAAO,EAAKuE,cAAc3R,EAAUoN,EAAQnD,EAAgB04B,EAAWr3B,OAAQ4F,EACjF,GAAGxI,I,cAFH,S,YAKF,YAAAuL,OAAA,WACE,OAAO,EAAP,KACK,UAAmB4D,UAAU5D,OAAOoE,MAAMxa,OAAK,CAClDsW,SAAU,kBAEd,EACF,EArUA,CAAuD,W,mECD1C,KAAe0uB,OAAO,SACtB,KAAiBA,OAAO,WACxB,KAAiBA,OAAO,WACxB,KAAkBA,OAAO,W,k8CCbtC,kBAGE,WAAYr/B,GAAZ,MACE,YAAMA,IAAQ,K,OAEd7C,OAAOmiC,eAAe,EAAM3iB,EAAatI,W,CAC3C,CACF,OARkC,OAQlC,EARA,CAAkC/Z,OAArB,EAAAqiB,aAAAA,EAUb,kBACE,mBACE,YAAM,4CAA0C,K,OAChD,EAAK9D,KAAO,EACZ1b,OAAOmiC,eAAe,EAAMhT,EAAyBjY,W,CACvD,CACF,OAN8C,OAM9C,EANA,CAA8CsI,GAAjC,EAAA2P,yBAAAA,EAQb,kBACE,mBACE,YAAM,mDAAiD,K,OACvD,EAAKzT,KAAO,EACZ1b,OAAOmiC,eAAe,EAAM9S,EAA2BnY,W,CACzD,CACF,OANgD,OAMhD,EANA,CAAgDsI,GAAnC,EAAA6P,2BAAAA,EAQb,kBACE,mBACE,YAAM,8CAA4C,K,OAClD,EAAK3T,KAAO,EACZ1b,OAAOmiC,eAAe,EAAM5S,EAAuBrY,W,CACrD,CACF,OAN4C,OAM5C,EANA,CAA4CsI,GAA/B,EAAA+P,uBAAAA,EAQb,kBACE,mBACE,YAAM,4CAA0C,K,OAChD,EAAK7T,KAAO,EACZ1b,OAAOmiC,eAAe,EAAM1S,EAAuBvY,W,CACrD,CACF,OAN4C,OAM5C,EANA,CAA4CsI,GAA/B,EAAAiQ,uBAAAA,EAQb,kBACE,mBACE,YAAM,mDAAiD,K,OACvD,EAAK/T,KAAO,EACZ1b,OAAOmiC,eAAe,EAAM3C,EAA+BtoB,W,CAC7D,CACF,OANoD,OAMpD,EANA,CAAoDsI,GAAvC,EAAAggB,+BAAAA,EAQb,kBACE,mBACE,YAAM,yCAAuC,K,OAC7C,EAAK9jB,KAAO,EACZ1b,OAAOmiC,eAAe,EAAMrS,EAAyB5Y,W,CACvD,CACF,OAN8C,OAM9C,EANA,CAA8CsI,GAAjC,EAAAsQ,yBAAAA,EAQb,kBACE,mBACE,YAAM,uCAAqC,K,OAC3C,EAAKpU,KAAO,EACZ1b,OAAOmiC,eAAe,EAAMC,EAAuBlrB,W,CACrD,CACF,OAN4C,OAM5C,EANA,CAA4CsI,GAA/B,EAAA4iB,uBAAAA,EAWb,kBACE,mBACE,YAAM,yCAAuC,K,OAC7C,EAAK1mB,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMlS,EAAwB/Y,W,CACtD,CACF,OAN6C,OAM7C,EANA,CAA6CsI,GAAhC,EAAAyQ,wBAAAA,EAQb,kBAEE,WAAY9uB,GAAZ,MACE,YAAM,yDAAuD,K,OAC7D,EAAKua,KAAO,GACZ,EAAKva,KAAOA,EACZnB,OAAOmiC,eAAe,EAAMzjB,EAA4BxH,W,CAC1D,CACF,OARiD,OAQjD,EARA,CAAiDsI,GAApC,EAAAd,4BAAAA,EAUb,kBAEE,WAAYvd,GAAZ,MACE,YAAM,mEAAiE,K,OACvE,EAAKua,KAAO,GACZ,EAAKva,KAAOA,EACZnB,OAAOmiC,eAAe,EAAMxjB,EAAsBzH,W,CACpD,CACF,OAR2C,OAQ3C,EARA,CAA2CsI,GAA9B,EAAAb,sBAAAA,EAUb,kBACE,mBACE,YAAM,yCAAuC,K,OAC7C,EAAKjD,KAAO,GACZ1b,OAAOmiC,eAAe,EAAME,EAAyBnrB,W,CACvD,CACF,OAN8C,OAM9C,EANA,CAA8CsI,GAAjC,EAAA6iB,yBAAAA,EAQb,kBACE,mBACE,YAAM,+DAA6D,K,OACnE,EAAK3mB,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMG,EAA+BprB,W,CAC7D,CACF,OANoD,OAMpD,EANA,CAAoDsI,GAAvC,EAAA8iB,+BAAAA,EAQb,kBACE,mBACE,YAAM,+CAA6C,K,OACnD,EAAK5mB,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMhE,EAA8BjnB,W,CAC5D,CACF,OANmD,OAMnD,EANA,CAAmDsI,GAAtC,EAAA2e,8BAAAA,EAQb,kBACE,mBACE,YAAM,6BAA2B,K,OACjC,EAAKziB,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMjN,EAAoBhe,W,CAClD,CACF,OANyC,OAMzC,EANA,CAAyCsI,GAA5B,EAAA0V,oBAAAA,EAQb,kBACE,mBACE,YAAM,gFAA8E,K,OACpF,EAAKxZ,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMvd,EAAa1N,W,CAC3C,CACF,OANkC,OAMlC,EANA,CAAkCsI,GAArB,EAAAoF,aAAAA,EAQb,kBACE,mBACE,YAAM,iDAA+C,K,OACrD,EAAKlJ,KAAO,GACZ1b,OAAOmiC,eAAe,EAAM3f,EAAoBtL,W,CAClD,CACF,OANyC,OAMzC,EANA,CAAyCsI,GAA5B,EAAAgD,oBAAAA,EAQb,kBAGE,WAAY1D,EAAgBC,GAA5B,MACE,YAAM,4BAAqBD,EAAM,oBAAYC,EAAM,wDAAqD,K,OACxG,EAAKrD,KAAO,GACZ,EAAKoD,OAASA,EACd,EAAKC,OAASA,EACd/e,OAAOmiC,eAAe,EAAMtjB,EAAU3H,W,CACxC,CACF,OAV+B,OAU/B,EAVA,CAA+BsI,GAAlB,EAAAX,UAAAA,EAYb,kBAEE,WAAYI,GAAZ,MACE,YAAM,0FAAwF,K,OAC9F,EAAKvD,KAAO,GACZ,EAAKuD,SAAWA,EAChBjf,OAAOmiC,eAAe,EAAMnjB,EAAmB9H,W,CACjD,CACF,OARwC,OAQxC,EARA,CAAwCsI,GAA3B,EAAAR,mBAAAA,EAUb,kBACE,mBACE,YAAM,iGAA+F,K,OACrG,EAAKtD,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMI,EAA6BrrB,W,CAC3D,CACF,OANkD,OAMlD,EANA,CAAkDsI,GAArC,EAAA+iB,6BAAAA,EAQb,kBAGE,WAAY/hC,EAAeK,GAA3B,MACE,YAAM,uBAAgBL,EAAM,sDAA8CK,KAAW,K,OACrF,EAAK6a,KAAO,GACZ,EAAKlb,OAASA,EACd,EAAKK,SAAWA,EAChBb,OAAOmiC,eAAe,EAAMjjB,EAAoChI,W,CAClE,CACF,OAVyD,OAUzD,EAVA,CAAyDsI,GAA5C,EAAAN,oCAAAA,EAYb,kBAGE,WAAYE,GAAZ,MACE,YAAM,6DAAsDA,EAAQ,gBAAa,K,OACjF,EAAK1D,KAAO,GACZ,EAAK0D,SAAWA,EAChBpf,OAAOmiC,eAAe,EAAMK,EAAuBtrB,W,CACrD,CACF,OAT4C,OAS5C,EATA,CAA4CsI,GAA/B,EAAAgjB,uBAAAA,EAWb,kBAIE,WAAY1jB,EAAeM,GAA3B,MACE,YAAM,4BAAqBN,EAAM,0DAAkDM,KAAW,K,OAC9F,EAAK1D,KAAO,GACZ,EAAKoD,OAASA,EACd,EAAKM,SAAWA,EAChBpf,OAAOmiC,eAAe,EAAMhjB,EAAcjI,W,CAC5C,CACF,OAXmC,OAWnC,EAXA,CAAmCsI,GAAtB,EAAAL,cAAAA,EAab,kBAIE,mBACE,YAAM,iEAA+D,K,OACrE,EAAKzD,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMte,EAAW3M,W,CACzC,CACF,OATgC,OAShC,EATA,CAAgCsI,GAAnB,EAAAqE,WAAAA,EAWb,kBACE,mBACE,YAAM,qCAAmC,K,OACzC,EAAKnI,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMM,EAAqBvrB,W,CACnD,CACF,OANwC,OAMxC,EANA,CAAwCsI,GAA3B,EAAAxV,mBAAAA,EAQb,kBACE,mBACE,YAAM,uCAAqC,K,OAC3C,EAAK0R,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMM,EAAqBvrB,W,CACnD,CACF,OAN0C,OAM1C,EANA,CAA0CsI,GAA7B,EAAAijB,qBAAAA,EAUb,kBAGE,WAAYpjB,GAAZ,MACE,YAAM,4DAAqDA,EAAO,4HAAyH,K,OAC3L,EAAK3D,KAAO,GACZ,EAAK2D,QAAUA,EACfrf,OAAOmiC,eAAe,EAAMv1B,EAAcsK,W,CAC5C,CACF,OATmC,OASnC,EATA,CAAmCsI,GAAtB,EAAA5S,cAAAA,EAWb,kBACE,mBACE,YAAM,sGAAoG,K,OAC1G,EAAK8O,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMvf,EAAgB1L,W,CAC9C,CACF,OANqC,OAMrC,EANA,CAAqCsI,GAAxB,EAAAoD,gBAAAA,EAQb,kBACE,mBACE,YAAM,2GAAyG,K,OAC/G,EAAKlH,KAAO,GACZ1b,OAAOmiC,eAAe,EAAM3U,EAA+BtW,W,CAC7D,CACF,OANoD,OAMpD,EANA,CAAoDsI,GAAvC,EAAAgO,+BAAAA,EAQb,kBACE,mBACE,YAAM,qFAAmF,K,OACzF,EAAK9R,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMjV,EAAgBhW,W,CAC9C,CACF,OANqC,OAMrC,EANA,CAAqCsI,GAAxB,EAAA0N,gBAAAA,EAQb,kBACE,mBACE,YAAM,oKAAkK,K,OACxK,EAAKxR,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMtd,EAAc3N,W,CAC5C,CACF,OANmC,OAMnC,EANA,CAAmCsI,GAAtB,EAAAqF,cAAAA,EAQb,kBACE,mBACE,YAAM,qIAAmI,K,OACzI,EAAKnJ,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMtf,EAAoB3L,W,CAClD,CACF,OANyC,OAMzC,EANA,CAAyCsI,GAA5B,EAAAqD,oBAAAA,EAQb,kBAEE,WAAYhiB,GAAZ,MACE,YAAM,uEAAgEA,EAAS9B,aAAY,K,OAC3F,EAAK2c,KAAO,GACZ,EAAK7a,SAAWA,EAChBb,OAAOmiC,eAAe,EAAM7iB,EAAoBpI,W,CAClD,CACF,OARyC,OAQzC,EARA,CAAyCsI,GAA5B,EAAAF,oBAAAA,EAUb,kBACE,mBACE,YAAM,wDAAsD,K,OAC5D,EAAK5D,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMve,EAAwB1M,W,CACtD,CACF,OAN6C,OAM7C,EANA,CAA6CsI,GAAhC,EAAAoE,wBAAAA,EAQb,kBACE,mBACE,YAAM,6BAA2B,K,OACjC,EAAKlI,KAAO,GACZ1b,OAAOmiC,eAAe,EAAM9gB,EAAoBnK,W,CAClD,CACF,OANyC,OAMzC,EANA,CAAyCsI,GAA5B,EAAA6B,oBAAAA,EAQb,kBACE,mBACE,YAAM,sCAAoC,K,OAC1C,EAAK3F,KAAO,GACZ1b,OAAOmiC,eAAe,EAAM1K,EAAyBvgB,W,CACvD,CACF,OAN8C,OAM9C,EANA,CAA8CsI,GAAjC,EAAAiY,yBAAAA,EAQb,kBAEE,WAAY52B,GAAZ,MACE,YAAM,uEAAgEA,EAAS9B,aAAY,K,OAC3F,EAAK2c,KAAO,GACZ,EAAK7a,SAAWA,EAChBb,OAAOmiC,eAAe,EAAM5iB,EAAoBrI,W,CAClD,CACF,OARyC,OAQzC,EARA,CAAyCsI,GAA5B,EAAAD,oBAAAA,EAUb,kBACE,mBACE,YAAM,mEAAiE,K,OACvE,EAAK7D,KAAO,GACZ1b,OAAOmiC,eAAe,EAAMtU,EAAuB3W,W,CACrD,CACF,OAN4C,OAM5C,EANA,CAA4CsI,GAA/B,EAAAqO,uBAAAA,C","sources":["webpack://floccus/./src/lib/Tree.ts","webpack://floccus/./src/lib/Crypto.ts","webpack://floccus/./src/lib/native/I18n.ts","webpack://floccus/./src/lib/strategies/Default.ts","webpack://floccus/./src/lib/Controller.ts","webpack://floccus/./src/lib/browser-api.js","webpack://floccus/./src/lib/strategies/Merge.ts","webpack://floccus/./src/lib/AdapterFactory.ts","webpack://floccus/./src/lib/Account.ts","webpack://floccus/./src/lib/DefunctCrypto.js","webpack://floccus/./_locales/ lazy ^.*","webpack://floccus/./src/lib/native/NativeAccount.ts","webpack://floccus/./src/lib/adapters/WebDav.ts","webpack://floccus/./src/lib/browser/BrowserAccount.ts","webpack://floccus/./src/lib/Logger.js","webpack://floccus/./src/lib/browser/BrowserDetection.ts","webpack://floccus/./src/lib/native/NativeTree.ts","webpack://floccus/./src/lib/adapters/GoogleDrive.ts","webpack://floccus/./src/lib/adapters/Caching.ts","webpack://floccus/./src/lib/serializers/Xbel.ts","webpack://floccus/./src/lib/isTest.ts","webpack://floccus/./src/lib/Mappings.ts","webpack://floccus/./src/lib/adapters/Git.ts","webpack://floccus/./src/lib/adapters/Linkwarden.ts","webpack://floccus/./src/lib/native/NativeAccountStorage.js","webpack://floccus/./src/lib/Diff.ts","webpack://floccus/./src/lib/browser/BrowserTree.ts","webpack://floccus/./src/lib/LocalTabs.ts","webpack://floccus/./src/lib/Scanner.ts","webpack://floccus/./src/lib/native/NativeController.js","webpack://floccus/./src/lib/adapters/NextcloudBookmarks.ts","webpack://floccus/./src/lib/serializers/Html.ts","webpack://floccus/./src/lib/strategies/Unidirectional.ts","webpack://floccus/./src/lib/interfaces/Controller.ts","webpack://floccus/./src/errors/Error.ts"],"sourcesContent":["import Crypto from './Crypto'\nimport Logger from './Logger'\nimport TResource from './interfaces/Resource'\nimport * as Parallel from 'async-parallel'\n\nconst STRANGE_PROTOCOLS = ['data:', 'javascript:', 'about:', 'chrome:', 'file:']\n\nexport const ItemLocation = {\n  LOCAL: 'Local',\n  SERVER: 'Server'\n} as const\n\nexport type TItemLocation = (typeof ItemLocation)[keyof typeof ItemLocation];\n\nexport type TOppositeLocation<L extends TItemLocation> = L extends typeof ItemLocation.LOCAL ? typeof ItemLocation.SERVER : L extends typeof ItemLocation.SERVER ? typeof ItemLocation.LOCAL : never\n\nexport const ItemType = {\n  FOLDER: 'folder',\n  BOOKMARK: 'bookmark'\n} as const\n\nexport type TItemType = (typeof ItemType)[keyof typeof ItemType];\n\ninterface IItemIndex<L extends TItemLocation> {\n  // eslint-disable-next-line no-use-before-define\n  [ItemType.BOOKMARK]: Record<string|number,Bookmark<L>>,\n  // eslint-disable-next-line no-use-before-define\n  [ItemType.FOLDER]: Record<string|number,Folder<L>>,\n}\n\nexport class Bookmark<L extends TItemLocation> {\n  public type = ItemType.BOOKMARK\n  public id: string | number\n  public parentId: string | number |null\n  public title: string\n  public url: string\n  public tags: string[]\n  public location: L\n  public isRoot = false\n  private hashValue: string\n\n  constructor({ id, parentId, url, title, tags, location }: { id:string|number, parentId:string|number, url:string, title:string, tags?: string[], location: L }) {\n    this.id = id\n    this.parentId = parentId\n    this.title = title\n    this.tags = tags\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.location = location || ItemLocation.LOCAL\n\n    if (this.location !== ItemLocation.LOCAL && this.location !== ItemLocation.SERVER) {\n      throw new Error('Location failed validation')\n    }\n\n    try {\n      // not a regular bookmark\n      if (STRANGE_PROTOCOLS.some(proto => url.indexOf(proto) === 0)) {\n        this.url = url\n        return\n      }\n\n      const urlObj = new URL(url)\n      this.url = urlObj.href\n    } catch (e) {\n      Logger.log('Failed to normalize', url)\n      this.url = url\n    }\n  }\n\n  canMergeWith<L2 extends TItemLocation>(otherItem: TItem<L2>): boolean {\n    if (otherItem instanceof Bookmark) {\n      return this.url === otherItem.url\n    }\n    return false\n  }\n\n  childrenSimilarity<L2 extends TItemLocation>(otherItem: TItem<L2>): number {\n    return 0\n  }\n\n  async hash():Promise<string> {\n    if (!this.hashValue) {\n      this.hashValue = await Crypto.sha256(\n        JSON.stringify({ title: this.title, url: this.url })\n      )\n    }\n    return this.hashValue\n  }\n\n  clone(withHash?: boolean):Bookmark<L> {\n    return new Bookmark(this)\n  }\n\n  cloneWithLocation<L2 extends TItemLocation>(withHash:boolean, location: L2): Bookmark<L2> {\n    return new Bookmark({\n      ...this,\n      location,\n    })\n  }\n\n  createIndex():any {\n    return { [this.id]: this }\n  }\n\n  // TODO: Make this return the correct type based on the type param\n  findItem(type:TItemType, id:string|number):TItem<L>|null {\n    if (type === 'bookmark' && String(id) === String(this.id)) {\n      return this\n    }\n    return null\n  }\n\n  // TODO: Make this return the correct type based on the type param\n  findItemFilter(type:TItemType, fn:(item:TItem<L>)=>boolean, prefer:(item: TItem<L>)=>number = () => 1):TItem<L>|null {\n    if (type === ItemType.BOOKMARK && fn(this)) {\n      return this\n    }\n    return null\n  }\n\n  count():number {\n    return 1\n  }\n\n  inspect(depth = 0):string {\n    return (\n      Array(depth < 0 ? 0 : depth)\n        .fill('  ')\n        .join('') +\n      `- #${this.id}[${this.title}](${this.url}) parentId: ${this.parentId}`\n    )\n  }\n\n  visitCreate(resource: TResource<L>):Promise<number | string> {\n    return resource.createBookmark(this)\n  }\n\n  visitUpdate(resource: TResource<L>): Promise<void> {\n    return resource.updateBookmark(this)\n  }\n\n  visitRemove(resource: TResource<L>): Promise<void> {\n    return resource.removeBookmark(this)\n  }\n\n  static hydrate<L2 extends TItemLocation>(obj: any):Bookmark<L2> {\n    return new Bookmark(obj)\n  }\n}\n\nexport class Folder<L extends TItemLocation> {\n  public type = ItemType.FOLDER\n  public id: number | string\n  public title?: string\n  public parentId: number | string\n  public children: TItem<L>[]\n  public hashValue: Record<string,string>\n  public isRoot = false\n  public loaded = true\n  public location: L\n  private index: IItemIndex<L>\n\n  constructor({ id, parentId, title, children, hashValue, loaded, location, isRoot }\n  :{\n    id:number|string,\n    parentId?:number|string,\n    title?:string,\n    // eslint-disable-next-line no-use-before-define\n    children?: TItem<L>[],\n    hashValue?:Record<'true'|'false',string>,\n    loaded?: boolean,\n    location: L,\n    isRoot?: boolean,\n  }) {\n    this.id = id\n    this.parentId = parentId\n    this.title = title\n    this.children = children || []\n    this.hashValue = {...hashValue}\n    this.loaded = loaded !== false\n    this.isRoot = isRoot\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.location = location || ItemLocation.LOCAL\n\n    if (this.location !== ItemLocation.LOCAL && this.location !== ItemLocation.SERVER) {\n      throw new Error('Location failed validation')\n    }\n  }\n\n  // eslint-disable-next-line no-use-before-define\n  findItemFilter(type:TItemType, fn:(Item)=>boolean, prefer:(Item)=>number = () => 1):TItem<L>|null {\n    if (!this.index) {\n      this.createIndex()\n    }\n    const candidates = Object.values(this.index[type]).filter(fn)\n    // return the preferred match based on a preference measure\n    return candidates.sort((a,b) => prefer(a) - prefer(b)).pop()\n  }\n\n  findFolder(id:string|number): Folder<L> {\n    if (String(this.id) === String(id)) {\n      return this\n    }\n\n    if (this.index) {\n      return this.index.folder[id]\n    }\n\n    // traverse sub folders\n    return this.children\n      .filter(child => child instanceof Folder)\n      .map(folder => folder as Folder<L>)\n      .map(folder => folder.findFolder(id))\n      .filter(folder => !!folder)[0]\n  }\n\n  findBookmark(id:string|number):Bookmark<L> {\n    if (this.index) {\n      return this.index.bookmark[id]\n    }\n    const bookmarkFound = this.children\n      .filter(child => child instanceof Bookmark)\n      .map(child => child as Bookmark<L>)\n      .find(bm => String(bm.id) === String(id))\n    if (bookmarkFound) {\n      return bookmarkFound\n    }\n    // traverse sub folders\n    return this.children\n      .filter(child => child instanceof Folder)\n      .map(folder => folder as Folder<L>)\n      .map(folder => folder.findBookmark(id))\n      .filter(bookmark => !!bookmark)[0]\n  }\n\n  // eslint-disable-next-line no-use-before-define\n  findItem(type:TItemType, id:string|number):TItem<L>|null {\n    if (type === ItemType.FOLDER) {\n      return this.findFolder(id)\n    } else {\n      return this.findBookmark(id)\n    }\n  }\n\n  async traverse(fn: (item:TItem<L>, folder: Folder<L>)=>void): Promise<void> {\n    await Parallel.each(this.children, async item => {\n      await fn(item, this)\n      if (item.type === 'folder') {\n        // give the browser time to breathe\n        await Promise.resolve()\n        await item.traverse(fn)\n      }\n    }, 10)\n  }\n\n  // eslint-disable-next-line no-use-before-define\n  canMergeWith<L2 extends TItemLocation>(otherItem: TItem<L2>): boolean {\n    if (otherItem instanceof Folder) {\n      return this.title === otherItem.title\n    }\n    return false\n  }\n\n  childrenSimilarity<L2 extends TItemLocation>(otherItem: TItem<L2>): number {\n    if (otherItem instanceof Folder) {\n      return this.children.reduce(\n        (count, item) =>\n          otherItem.children.find(i => i.title === item.title) ? count + 1 : count,\n        0\n      ) / Math.max(this.children.length, otherItem.children.length)\n    }\n    return 0\n  }\n\n  async hash(preserveOrder = false): Promise<string> {\n    if (this.hashValue && this.hashValue[String(preserveOrder)]) {\n      return this.hashValue[String(preserveOrder)]\n    }\n\n    if (!this.loaded) {\n      throw new Error('Trying to calculate hash of a folder that isn\\'t loaded')\n    }\n\n    const children = this.children.slice()\n    if (!preserveOrder) {\n      // only re-sort unless we sync the order of the children as well\n      children.sort((c1, c2) => {\n        if (c1.title < c2.title) {\n          return -1\n        }\n        if (c2.title < c1.title) {\n          return 1\n        }\n        return 0\n      })\n    }\n    if (!this.hashValue) this.hashValue = {}\n    this.hashValue[String(preserveOrder)] = await Crypto.sha256(\n      JSON.stringify({\n        title: this.title,\n        children: await Parallel.map(\n          this.children,\n          child => child.hash(preserveOrder),\n          1\n        )\n      })\n    )\n    return this.hashValue[String(preserveOrder)]\n  }\n\n  clone(withHash?:boolean):Folder<L> {\n    return new Folder({\n      ...this,\n      ...(!withHash && { hashValue: {} }),\n      children: this.children.map(child => child.clone(withHash))\n    })\n  }\n\n  cloneWithLocation<L2 extends TItemLocation>(withHash:boolean, location: L2):Folder<L2> {\n    return new Folder({\n      ...this,\n      location,\n      ...(!withHash && { hashValue: {} }),\n      children: this.children.map(child => child.cloneWithLocation(withHash, location))\n    })\n  }\n\n  count():number {\n    if (!this.index) {\n      this.createIndex()\n    }\n    return Object.keys(this.index.bookmark).length\n  }\n\n  countFolders():number {\n    if (!this.index) {\n      this.createIndex()\n    }\n    return Object.keys(this.index.folder).length\n  }\n\n  createIndex():IItemIndex<L> {\n    this.index = {\n      folder: { [this.id]: this },\n      bookmark: this.children\n        .filter(child => child instanceof Bookmark)\n        .reduce((obj, child) => {\n          obj[child.id] = child\n          return obj\n        }, {})\n    }\n\n    this.children\n      .filter(child => child instanceof Folder)\n      .map(child => child.createIndex())\n      .forEach(subIndex => {\n        Object.assign(this.index.folder, subIndex.folder)\n        Object.assign(this.index.bookmark, subIndex.bookmark)\n      })\n    return this.index\n  }\n\n  inspect(depth = 0):string {\n    return (\n      Array(depth < 0 ? 0 : depth)\n        .fill('  ')\n        .join('') +\n      `+ #${this.id}[${this.title}] parentId: ${this.parentId}, hash: ${this\n        .hashValue[String(true)] || this.hashValue[String(false)]}\\n` +\n      this.children\n        .map(child =>\n          child && child.inspect ? child.inspect(depth + 1) : String(child)\n        )\n        .join('\\n')\n    )\n  }\n\n  visitCreate(resource: TResource<L>):Promise<number | string> {\n    return resource.createFolder(this)\n  }\n\n  visitUpdate(resource: TResource<L>): Promise<void> {\n    return resource.updateFolder(this)\n  }\n\n  visitRemove(resource: TResource<L>): Promise<void> {\n    return resource.removeFolder(this)\n  }\n\n  static hydrate<L2 extends TItemLocation>(obj: {id: string|number, parentId?: string|number, title?: string, location: L2, children: any[], isRoot: boolean}): Folder<L2> {\n    return new Folder({\n      ...obj,\n      children: obj.children\n        ? obj.children.map(child => {\n          // Firefox seems to set 'url' even for folders\n          if ('url' in child && typeof child.url === 'string') {\n            return Bookmark.hydrate(child)\n          } else {\n            return Folder.hydrate(child)\n          }\n        })\n        : null\n    })\n  }\n\n  static getAncestorsOf<L2 extends TItemLocation>(item: TItem<L2>, tree: Folder<L2>): TItem<L2>[] {\n    const ancestors = [item]\n    let parent = item\n    while (String(parent.id) !== String(tree.id)) {\n      ancestors.push(parent)\n      parent = tree.findItem(ItemType.FOLDER, parent.parentId)\n      if (!parent) {\n        throw new Error('Item is not a descendant of the tree passed')\n      }\n    }\n    ancestors.reverse()\n    return ancestors\n  }\n}\n\nexport type TItem<L extends TItemLocation> = Bookmark<L> | Folder<L>\n\nexport function hydrate<L extends TItemLocation>(obj: any) {\n  if (obj.type === ItemType.FOLDER) {\n    return Folder.hydrate<L>(obj)\n  }\n  if (obj.type === ItemType.BOOKMARK) {\n    return Bookmark.hydrate<L>(obj)\n  }\n  throw new Error(`Cannot hydrate object ${JSON.stringify(obj)}`)\n}\n","import { fromUint8Array, toUint8Array } from 'js-base64'\n\nexport default class Crypto {\n  static iterations = 250000\n  static ivLength = 16\n\n  static async sha256(message: string): Promise<string> {\n    const msgBuffer = new TextEncoder().encode(message) // encode as UTF-8\n    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer) // hash the message\n    const hashHex = this.bufferToHexstr(new Uint8Array(hashBuffer)) // convert bytes to hex string\n    return hashHex\n  }\n\n  static bufferToHexstr(buffer: Uint8Array): string {\n    return Array.from(new Uint8Array(buffer))\n      .map(b => ('00' + b.toString(16)).slice(-2))\n      .join('') // convert bytes to hex string\n  }\n\n  static hexstrToBuffer(hex: string): Uint8Array {\n    for (\n      var bytes = new Uint8Array(hex.length / 2), c = 0;\n      c < hex.length;\n      c += 2\n    ) {\n      bytes[c / 2] = parseInt(hex.substr(c, 2), 16)\n    }\n    return bytes\n  }\n\n  static async prepareKey(passphrase: string, salt: string): Promise<CryptoKey> {\n    const enc = new TextEncoder()\n    const passphraseBytes = enc.encode(passphrase)\n    const saltBytes = enc.encode(salt)\n    const key = await crypto.subtle.importKey('raw', passphraseBytes, 'PBKDF2', false, ['deriveKey'])\n    return crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        hash: 'SHA-256',\n        salt: saltBytes,\n        iterations: Crypto.iterations\n      },\n      key,\n      {\n        name: 'AES-GCM',\n        length: 256\n      },\n      false,\n      ['encrypt', 'decrypt']\n    )\n  }\n\n  static async decryptAES(key: string, payload: string, salt: string) : Promise<string> {\n    const cryptoKey = await this.prepareKey(key, salt)\n    const buffer = toUint8Array(payload)\n    const iv = buffer.slice(0, this.ivLength)\n    const ciphertext = buffer.slice(this.ivLength)\n\n    const plaintextBytes = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, cryptoKey, ciphertext)\n    return new TextDecoder().decode(plaintextBytes)\n  }\n\n  static async encryptAES(key: string, message: string, salt: string): Promise<string> {\n    // Generate a random 16 byte initialization vector\n    const iv = this.getRandomBytes(this.ivLength)\n    const messageBytes = new TextEncoder().encode(message)\n    const cryptoKey = await this.prepareKey(key, salt)\n    const ciphertext = await crypto.subtle.encrypt(\n      { name: 'AES-GCM', iv },\n      cryptoKey,\n      messageBytes\n    )\n\n    const resultBytes = this.concatBytes(iv, new Uint8Array(ciphertext))\n\n    return fromUint8Array(resultBytes)\n  }\n\n  static concatBytes(array1: Uint8Array, array2: Uint8Array): Uint8Array {\n    const result = new Uint8Array(array1.length + array2.length)\n    result.set(array1, 0)\n    result.set(array2, array1.length)\n    return result\n  }\n\n  static getRandomBytes(bytelength: number) : Uint8Array {\n    const rand = new Uint8Array(bytelength)\n    crypto.getRandomValues(rand)\n    return rand\n  }\n}\n","import IntlMessageFormat from 'intl-messageformat'\nimport DEFAULT_MESSAGES from '../../../_locales/en/messages.json'\n\n// hehe, ignore all the things...\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst context = require.context(\n  '../../../_locales',\n  true,\n  /^.*?\\.json$/,\n  'lazy'\n)\n\ninterface TranslationEntry {\n  message: string;\n}\ninterface Messages {\n  [key: string]: TranslationEntry;\n}\n\nexport default class I18n {\n  private locales: string[];\n  private locale = 'en'\n  private messages: Messages | undefined;\n  private defaultMessages: Messages;\n  constructor(locale: string) {\n    this.locales = [locale]\n    this.defaultMessages = DEFAULT_MESSAGES\n    this.messages = DEFAULT_MESSAGES\n  }\n\n  setLocales(locales:string[]):void {\n    this.locales = locales\n  }\n\n  async load():Promise<void> {\n    for (const locale of this.locales) {\n      try {\n        const fileName = './' + locale.replace('-', '_') + '/messages.json'\n        const imported = await context(fileName)\n        console.log(imported)\n        this.messages = imported\n        this.locale = locale\n        break\n      } catch (error) {\n        console.warn(error)\n      }\n      try {\n        const fileName = './' + locale.split('-')[0] + '/messages.json'\n        const imported = await context(fileName)\n        console.log(imported)\n        this.messages = imported\n        this.locale = locale.split('-')[0]\n        break\n      } catch (error) {\n        console.warn(error)\n      }\n    }\n  }\n\n  /**\n   * Get a formatted message with the given name\n   */\n  public getMessage(messageName: string, content?: any, formats?: any): string {\n    const string = this.doGetMessage(messageName)\n    if (string) {\n      const message = new IntlMessageFormat(string.message, this.locale, formats).format(content)\n      if (!message) {\n        return messageName\n      }\n      if (Array.isArray(message)) {\n        return message.join('')\n      }\n      return message\n    }\n    return messageName\n  }\n\n  /**\n   * Get message with given name from the default locale\n   */\n  private getDefaultLocaleMessage(messageName: string): TranslationEntry | null {\n    if (!Object.hasOwnProperty.call(this.defaultMessages, messageName)) {\n      console.warn(`WARN: No message found with name ${messageName} in default locale en`)\n      return null\n    }\n    return this.defaultMessages[messageName]\n  }\n\n  /**\n   * Get message with given name\n   */\n  private doGetMessage(messageName: string): TranslationEntry | null {\n    if (!this.messages || !Object.hasOwnProperty.call(this.messages, messageName)) {\n      console.warn(`No message found with name ${messageName} in locale ${this.locale}. Using default locale 'en'`)\n      return this.getDefaultLocaleMessage(messageName)\n    }\n    return this.messages[messageName]\n  }\n}\n\nexport const i18n = new I18n('en')\n","import {\n  Bookmark,\n  Folder,\n  TItem,\n  ItemType,\n  ItemLocation,\n  TItemLocation,\n  TOppositeLocation,\n} from '../Tree'\nimport Logger from '../Logger'\nimport Diff, {\n  ActionType,\n  CreateAction,\n  MoveAction,\n  PlanStage1, PlanStage2, PlanStage3,\n  RemoveAction,\n  ReorderAction,\n  UpdateAction\n} from '../Diff'\nimport Scanner, { ScanResult } from '../Scanner'\nimport * as Parallel from 'async-parallel'\nimport { throttle } from 'throttle-debounce'\nimport Mappings, { MappingSnapshot } from '../Mappings'\nimport TResource, { OrderFolderResource, TLocalTree } from '../interfaces/Resource'\nimport { TAdapter } from '../interfaces/Adapter'\nimport { CancelledSyncError, FailsafeError } from '../../errors/Error'\n\nimport NextcloudBookmarksAdapter from '../adapters/NextcloudBookmarks'\nimport CachingAdapter from '../adapters/Caching'\n\nconst ACTION_CONCURRENCY = 12\n\nexport default class SyncProcess {\n  protected mappings: Mappings\n  protected localTree: TLocalTree\n  protected server: TAdapter\n  protected cacheTreeRoot: Folder<typeof ItemLocation.LOCAL>|null\n  protected canceled: boolean\n  protected preserveOrder: boolean\n  protected progressCb: (progress:number, actionsDone?:number)=>void\n\n  // Stage -1\n  protected localTreeRoot: Folder<typeof ItemLocation.LOCAL> = null\n  protected serverTreeRoot: Folder<typeof ItemLocation.SERVER> = null\n\n  // Stage 0\n  protected localScanResult: ScanResult<typeof ItemLocation.LOCAL, TItemLocation> = null\n  protected serverScanResult: ScanResult<typeof ItemLocation.SERVER, TItemLocation> = null\n\n  // Stage 1\n  private localPlanStage1: PlanStage1<typeof ItemLocation.SERVER, TItemLocation>\n  private serverPlanStage1: PlanStage1<typeof ItemLocation.LOCAL, TItemLocation>\n\n  // Stage 2\n  private localPlanStage2: PlanStage2<typeof ItemLocation.SERVER, TItemLocation, typeof ItemLocation.LOCAL>\n  private serverPlanStage2: PlanStage2<typeof ItemLocation.LOCAL, TItemLocation, typeof ItemLocation.SERVER>\n\n  // Stage 3\n  private localDonePlan: PlanStage3<typeof ItemLocation.SERVER, TItemLocation, typeof ItemLocation.LOCAL>\n  private serverDonePlan: PlanStage3<typeof ItemLocation.LOCAL, TItemLocation, typeof ItemLocation.SERVER>\n  private localReorders: Diff<typeof ItemLocation.SERVER, TItemLocation, ReorderAction<typeof ItemLocation.SERVER, TItemLocation>>\n  private serverReorders: Diff<typeof ItemLocation.LOCAL, TItemLocation, ReorderAction<typeof ItemLocation.LOCAL, TItemLocation>>\n\n  // Stage 4\n  private localReordersFinal: Diff<typeof ItemLocation.LOCAL, TItemLocation, ReorderAction<typeof ItemLocation.LOCAL, TItemLocation>>\n  private serverReorderFinal: Diff<typeof ItemLocation.SERVER, TItemLocation, ReorderAction<typeof ItemLocation.SERVER, TItemLocation>>\n\n  protected actionsDone = 0\n  protected actionsPlanned = 0\n\n  protected isFirefox: boolean\n\n  protected staticContinuation: any = null\n\n  // The location that has precedence in case of conflicts\n  protected masterLocation: TItemLocation\n\n  constructor(\n    mappings:Mappings,\n    localTree:TLocalTree,\n    server:TAdapter,\n    progressCb:(progress:number, actionsDone?:number)=>void\n  ) {\n    this.mappings = mappings\n    this.localTree = localTree\n    this.server = server\n\n    this.preserveOrder = 'orderFolder' in this.server\n\n    this.progressCb = throttle(500, true, progressCb) as (progress:number, actionsDone?:number)=>void\n    this.canceled = false\n    this.isFirefox = self.location.protocol === 'moz-extension:'\n  }\n\n  getMembersToPersist() {\n    return [\n      // Stage 0\n      'localScanResult',\n      'serverScanResult',\n\n      // Stage 1\n      'localPlanStage1',\n      'serverPlanStage1',\n\n      // Stage 2\n      'localPlanStage2',\n      'serverPlanStage2',\n\n      // Stage 3\n      'localDonePlan',\n      'serverDonePlan',\n      'localReorders',\n      'serverReorders',\n\n      // Stage 4\n      'localReorderPlan',\n      'serverReorderPlan',\n    ]\n  }\n\n  getMappingsInstance(): Mappings {\n    return this.mappings\n  }\n\n  setCacheTree(cacheTree: Folder<typeof ItemLocation.LOCAL>) {\n    this.cacheTreeRoot = cacheTree\n  }\n\n  public getTargetTree<L1 extends TItemLocation>(targetLocation: L1): Folder<L1> {\n    return (targetLocation === ItemLocation.SERVER ? this.serverTreeRoot : this.localTreeRoot) as Folder<L1>\n  }\n\n  async cancel() :Promise<void> {\n    this.canceled = true\n    this.server.cancel()\n  }\n\n  updateProgress():void {\n    if (typeof this.actionsDone === 'undefined') {\n      this.actionsDone = 0\n    }\n    this.actionsDone++\n    this.progressCb(\n      Math.min(\n        1,\n        0.5 + (this.actionsDone / (this.actionsPlanned + 1)) * 0.5\n      ),\n      this.actionsDone\n    )\n    Logger.log(`Executed ${this.actionsDone} actions from ${this.actionsPlanned} actions`)\n  }\n\n  setProgress({actionsDone, actionsPlanned}: {actionsDone: number, actionsPlanned: number}) {\n    this.actionsDone = actionsDone\n    this.actionsPlanned = actionsPlanned\n    this.progressCb(\n      Math.min(\n        1,\n        0.5 + (this.actionsDone / (this.actionsPlanned + 1)) * 0.5\n      ),\n      this.actionsDone\n    )\n  }\n\n  setDirection(direction:TItemLocation):void {\n    throw new Error('Unsupported method')\n  }\n\n  async sync(): Promise<void> {\n    // onSyncStart is already executed at this point\n    this.progressCb(0.15)\n\n    this.masterLocation = ItemLocation.LOCAL\n    await this.prepareSync()\n\n    // trees are loaded at this point\n    this.progressCb(0.35)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log({localTreeRoot: this.localTreeRoot, serverTreeRoot: this.serverTreeRoot, cacheTreeRoot: this.cacheTreeRoot})\n\n    if (!this.localScanResult && !this.serverScanResult) {\n      const { localScanResult, serverScanResult } = await this.getDiffs()\n      Logger.log({ localScanResult, serverScanResult })\n      this.localScanResult = localScanResult\n      this.serverScanResult = serverScanResult\n      this.progressCb(0.45)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if (!this.serverPlanStage1) {\n      this.serverPlanStage1 = await this.reconcileDiffs(this.localScanResult, this.serverScanResult, ItemLocation.SERVER)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if (!this.localPlanStage1) {\n      this.localPlanStage1 = await this.reconcileDiffs(this.serverScanResult, this.localScanResult, ItemLocation.LOCAL)\n    }\n\n    let mappingsSnapshot: MappingSnapshot\n\n    if (!this.serverPlanStage2) {\n      // have to get snapshot after reconciliation, because of concurrent creation reconciliation\n      mappingsSnapshot = this.mappings.getSnapshot()\n      Logger.log('Mapping server plan')\n\n      this.serverPlanStage2 = {\n        CREATE: this.serverPlanStage1.CREATE.map(mappingsSnapshot, ItemLocation.SERVER),\n        UPDATE: this.serverPlanStage1.UPDATE.map(mappingsSnapshot, ItemLocation.SERVER),\n        MOVE: this.serverPlanStage1.MOVE,\n        REMOVE: this.serverPlanStage1.REMOVE.map(mappingsSnapshot, ItemLocation.SERVER),\n        REORDER: this.serverPlanStage1.REORDER,\n      }\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if (!this.localPlanStage2) {\n      // have to get snapshot after reconciliation, because of concurrent creation reconciliation\n      if (!mappingsSnapshot) mappingsSnapshot = this.mappings.getSnapshot()\n      Logger.log('Mapping local plan')\n\n      this.localPlanStage2 = {\n        CREATE: this.localPlanStage1.CREATE.map(mappingsSnapshot, ItemLocation.LOCAL),\n        UPDATE: this.localPlanStage1.UPDATE.map(mappingsSnapshot, ItemLocation.LOCAL),\n        MOVE: this.localPlanStage1.MOVE,\n        REMOVE: this.localPlanStage1.REMOVE.map(mappingsSnapshot, ItemLocation.LOCAL),\n        REORDER: this.localPlanStage1.REORDER,\n      }\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log({localPlan: this.localPlanStage2, serverPlan: this.serverPlanStage2})\n\n    this.applyFailsafe(this.localPlanStage2.REMOVE)\n\n    if (!this.localDonePlan) {\n      this.localDonePlan = {\n        CREATE: new Diff(),\n        UPDATE: new Diff(),\n        MOVE: new Diff(),\n        REMOVE: new Diff(),\n        REORDER: new Diff(),\n      }\n\n      this.serverDonePlan = {\n        CREATE: new Diff(),\n        UPDATE: new Diff(),\n        MOVE: new Diff(),\n        REMOVE: new Diff(),\n        REORDER: new Diff(),\n      }\n    }\n\n    if (!this.localReorders) {\n      this.localReorders = this.localPlanStage2.REORDER\n      this.serverReorders = this.serverPlanStage2.REORDER\n    }\n\n    if (!this.actionsPlanned) {\n      this.actionsPlanned = Object.values(this.serverPlanStage2).reduce((acc, diff) => diff.getActions().length + acc, 0) +\n        Object.values(this.localPlanStage2).reduce((acc, diff) => diff.getActions().length + acc, 0)\n    }\n\n    Logger.log('Executing server plan')\n    await this.execute(this.server, this.serverPlanStage2, ItemLocation.SERVER, this.serverDonePlan, this.serverReorders)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log('Executing local plan')\n    await this.execute(this.localTree, this.localPlanStage2, ItemLocation.LOCAL, this.localDonePlan, this.localReorders)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if ('orderFolder' in this.server && !this.localReordersFinal) {\n      // mappings have been updated, reload\n      mappingsSnapshot = this.mappings.getSnapshot()\n      this.localReordersFinal = this.reconcileReorderings(this.localReorders, this.serverDonePlan, ItemLocation.LOCAL, mappingsSnapshot)\n      this.serverReorderFinal = this.reconcileReorderings(this.serverReorders, this.localDonePlan, ItemLocation.SERVER, mappingsSnapshot)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if ('orderFolder' in this.server) {\n      Logger.log('Executing reorderings')\n      await Promise.all([\n        this.executeReorderings(this.server, this.serverReorderFinal),\n        this.executeReorderings(this.localTree, this.localReordersFinal),\n      ])\n    }\n  }\n\n  protected async prepareSync() {\n    if (!this.localTreeRoot) {\n      Logger.log('Retrieving local tree')\n      const localTreeRoot = await this.localTree.getBookmarksTree()\n      Logger.log('Filtering out unaccepted local bookmarks')\n      this.filterOutUnacceptedBookmarks(localTreeRoot)\n      if (this.server instanceof NextcloudBookmarksAdapter) {\n        Logger.log('Filtering out duplicate bookmarks')\n        await this.filterOutDuplicatesInTheSameFolder(localTreeRoot)\n      }\n      this.localTreeRoot = localTreeRoot\n    }\n\n    // Cache tree might not have been initialized and thus have no id\n    this.cacheTreeRoot.id = this.localTreeRoot.id\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if (!this.serverTreeRoot) {\n      Logger.log('Retrieving server tree')\n      const serverTreeRoot = await this.server.getBookmarksTree()\n      Logger.log('Filtering out invalid server bookmarks')\n      this.filterOutInvalidBookmarks(serverTreeRoot)\n\n      if (this.canceled) {\n        throw new CancelledSyncError()\n      }\n\n      await this.mappings.addFolder({ localId: this.localTreeRoot.id, remoteId: serverTreeRoot.id })\n      const mappingsSnapshot = this.mappings.getSnapshot()\n\n      if ('loadFolderChildren' in this.server) {\n        Logger.log('Loading sparse tree as necessary')\n        // Load sparse tree\n        await this.loadChildren(serverTreeRoot, mappingsSnapshot, true)\n      }\n      this.serverTreeRoot = serverTreeRoot\n    }\n\n    // generate hash tables to find items faster\n    Logger.log('Generating indices for local tree')\n    this.localTreeRoot.createIndex()\n    Logger.log('Generating indices for cache tree')\n    this.cacheTreeRoot.createIndex()\n    Logger.log('Generating indices for server tree')\n    this.serverTreeRoot.createIndex()\n  }\n\n  protected applyFailsafe(removals: Diff<TItemLocation, TItemLocation, RemoveAction<TItemLocation, TItemLocation>>) {\n    const localCountTotal = this.localTreeRoot.count()\n    const localCountDeleted = removals.getActions().reduce((count, action) => count + action.payload.count(), 0)\n\n    Logger.log('Checking failsafe: ' + localCountDeleted + '/' + localCountTotal + '=' + (localCountDeleted / localCountTotal))\n    if (localCountTotal > 5 && localCountDeleted / localCountTotal > 0.5) {\n      const failsafe = this.server.getData().failsafe\n      if (failsafe !== false || typeof failsafe === 'undefined') {\n        throw new FailsafeError(Math.ceil((localCountDeleted / localCountTotal) * 100))\n      }\n    }\n  }\n\n  filterOutUnacceptedBookmarks(tree: Folder<TItemLocation>): void {\n    tree.children = tree.children.filter(child => {\n      if (child instanceof Bookmark) {\n        return this.server.acceptsBookmark(child)\n      } else {\n        this.filterOutUnacceptedBookmarks(child)\n        return true\n      }\n    })\n  }\n\n  filterOutInvalidBookmarks(tree: Folder<TItemLocation>): void {\n    tree.children = tree.children.filter(child => {\n      if (child instanceof Bookmark) {\n        // Chrome URLs cannot be added in firefox\n        if (this.isFirefox && child.url.startsWith('chrome')) {\n          return false\n        }\n        // Linkwarden supports bookmarks that have no URL eg. for directly uploaded files\n        if (child.url === null) {\n          return false\n        }\n      } else {\n        this.filterOutInvalidBookmarks(child)\n      }\n      return true\n    })\n  }\n\n  async filterOutDuplicatesInTheSameFolder(tree: Folder<TItemLocation>): Promise<void> {\n    const seenUrl = {}\n    const duplicates = []\n    tree.children = tree.children.filter(child => {\n      if (child.type === ItemType.BOOKMARK) {\n        if (seenUrl[child.url]) {\n          duplicates.push(child)\n          return false\n        }\n        seenUrl[child.url] = child\n      } else {\n        this.filterOutDuplicatesInTheSameFolder(child)\n      }\n      return true\n    })\n    duplicates.length &&\n      Logger.log(\n        'Filtered out the following duplicates before syncing',\n        duplicates\n      )\n  }\n\n  async getDiffs():Promise<{localScanResult:ScanResult<typeof ItemLocation.LOCAL, TItemLocation>, serverScanResult:ScanResult<typeof ItemLocation.SERVER, TItemLocation>}> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const newMappings = []\n\n    let localScanner, serverScanner\n    if (this.localTree.constructor.name === 'LocalTabs') {\n      // if we have the cache available, Diff cache and both trees\n      localScanner = new Scanner(\n        this.cacheTreeRoot,\n        this.localTreeRoot,\n        // We also allow canMergeWith for folders here, because Window IDs are not stable\n        // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n        (oldItem, newItem) => {\n          if (oldItem.type !== newItem.type) {\n            return false\n          }\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark' && oldItem.url !== newItem.url) {\n            return false\n          }\n          if (Mappings.mappable(mappingsSnapshot, oldItem, newItem)) {\n            return true\n          }\n          if (oldItem.type === 'folder' && oldItem.canMergeWith(newItem)) {\n            return true\n          }\n          return false\n        },\n        this.preserveOrder,\n      )\n      serverScanner = new Scanner(\n        this.cacheTreeRoot,\n        this.serverTreeRoot,\n        // We also allow canMergeWith here\n        // (for bookmarks, because e.g. for NextcloudFolders the id of moved bookmarks changes (because their id is \"<bookmarkID>;<folderId>\")\n        // (for folders because Window IDs are not stable)\n        // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n        (oldItem, newItem) => {\n          if (oldItem.type !== newItem.type) {\n            return false\n          }\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark' && oldItem.url !== newItem.url) {\n            return false\n          }\n          if (Mappings.mappable(mappingsSnapshot, oldItem, newItem)) {\n            newMappings.push([oldItem, newItem])\n            return true\n          }\n          if (oldItem.canMergeWith(newItem)) {\n            newMappings.push([oldItem, newItem])\n            return true\n          }\n          return false\n        },\n        this.preserveOrder,\n      )\n    } else {\n      // if we have the cache available, Diff cache and both trees\n      localScanner = new Scanner(\n        this.cacheTreeRoot,\n        this.localTreeRoot,\n        (oldItem, newItem) => {\n          if (oldItem.type !== newItem.type) {\n            return false\n          }\n          // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark' && oldItem.url !== newItem.url) {\n            return false\n          }\n          if (Mappings.mappable(mappingsSnapshot, oldItem, newItem)) {\n            return true\n          }\n          return false\n        },\n        this.preserveOrder\n      )\n      serverScanner = new Scanner(\n        this.cacheTreeRoot,\n        this.serverTreeRoot,\n        // We also allow canMergeWith here, because e.g. for NextcloudBookmarks the id of moved bookmarks changes (because their id is \"<bookmarkID>;<folderId>\")\n        (oldItem, newItem) => {\n          if (oldItem.type !== newItem.type) {\n            return false\n          }\n          // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark' && oldItem.url !== newItem.url) {\n            return false\n          }\n          if (Mappings.mappable(mappingsSnapshot, oldItem, newItem)) {\n            newMappings.push([oldItem, newItem])\n            return true\n          }\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark') {\n            if (oldItem.canMergeWith(newItem)) {\n              newMappings.push([oldItem, newItem])\n              return true\n            }\n          }\n          return false\n        },\n        this.preserveOrder\n      )\n    }\n    Logger.log('Calculating diffs for local and server trees relative to cache tree')\n    const localScanResult = await localScanner.run()\n    const serverScanResult = await serverScanner.run()\n    await Parallel.map(newMappings, ([localItem, serverItem]) => this.addMapping(this.server, localItem, serverItem.id), 10)\n    return {localScanResult, serverScanResult}\n  }\n\n  async reconcileDiffs<L1 extends TItemLocation, L2 extends TItemLocation, L3 extends TItemLocation>(\n    sourceScanResult:ScanResult<L1, L2>,\n    targetScanResult:ScanResult<TOppositeLocation<L1>, L3>,\n    targetLocation: TOppositeLocation<L1>\n  ): Promise<PlanStage1<L1, L2>> {\n    Logger.log('Reconciling diffs to prepare a plan for ' + targetLocation)\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const targetCreations = targetScanResult.CREATE.getActions()\n    const targetRemovals = targetScanResult.REMOVE.getActions()\n    const targetMoves = targetScanResult.MOVE.getActions()\n    const targetUpdates = targetScanResult.UPDATE.getActions()\n    const targetReorders = targetScanResult.REORDER.getActions()\n\n    const sourceCreations = sourceScanResult.CREATE.getActions()\n    const sourceRemovals = sourceScanResult.REMOVE.getActions()\n    const sourceMoves = sourceScanResult.MOVE.getActions()\n\n    const targetTree : Folder<TOppositeLocation<L1>> = (targetLocation === ItemLocation.LOCAL ? this.localTreeRoot : this.serverTreeRoot) as Folder<TOppositeLocation<L1>>\n    const sourceTree : Folder<L1> = (targetLocation === ItemLocation.LOCAL ? this.serverTreeRoot : this.localTreeRoot) as Folder<L1>\n\n    const allCreateAndMoveActions = (sourceScanResult.CREATE.getActions() as Array<CreateAction<L1, L2> | MoveAction<L1, L2> | CreateAction<TOppositeLocation<L1>, L3> | MoveAction<TOppositeLocation<L1>, L3>>)\n      .concat(sourceScanResult.MOVE.getActions())\n      .concat(targetScanResult.CREATE.getActions())\n      .concat(targetScanResult.MOVE.getActions())\n\n    const avoidTargetReorders = {}\n\n    // Prepare target plan\n    const targetPlan: PlanStage1<L1, L2> = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: new Diff(),\n    }\n\n    await Parallel.each(sourceScanResult.REMOVE.getActions(), async(action) => {\n      const concurrentRemoval = targetRemovals.find(targetRemoval =>\n        (action.payload.type === targetRemoval.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, targetRemoval.payload)) ||\n        Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, action.payload, targetRemoval))\n      if (concurrentRemoval) {\n        // Already deleted on target, do nothing.\n        return\n      }\n\n      const concurrentMove = targetMoves.find(targetMove =>\n        action.payload.type === targetMove.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, targetMove.payload)\n      )\n      if (concurrentMove && targetLocation === this.masterLocation) {\n        // moved on the target, moves from master take precedence, do nothing (i.e. leave target version intact)\n        return\n      }\n\n      targetPlan.REMOVE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(sourceScanResult.CREATE.getActions(), async(action) => {\n      const concurrentCreation = targetCreations.find(a => (\n        action.payload.parentId === Mappings.mapParentId(mappingsSnapshot, a.payload, action.payload.location) &&\n        action.payload.canMergeWith(a.payload)\n      ))\n      if (concurrentCreation) {\n        // created on both the target and sourcely, try to reconcile\n        const newMappings = []\n        const subScanner = new Scanner(\n          concurrentCreation.payload, // target tree\n          action.payload, // source tree\n          (oldItem, newItem) => {\n            if (oldItem.type === newItem.type && oldItem.canMergeWith(newItem)) {\n              // if two items can be merged, we'll add mappings here directly\n              newMappings.push([oldItem, newItem.id])\n              return true\n            }\n            return false\n          },\n          this.preserveOrder,\n          false\n        )\n        await subScanner.run()\n        newMappings.push([concurrentCreation.payload, action.payload.id])\n        await Parallel.each(newMappings, async([oldItem, newId]) => {\n          await this.addMapping(action.payload.location === ItemLocation.LOCAL ? this.localTree : this.server, oldItem, newId)\n        },1)\n        // TODO: subScanner may contain residual CREATE/REMOVE actions that need to be added to mappings\n        return\n      }\n      const concurrentRemoval = targetScanResult.REMOVE.getActions().find(targetRemoval =>\n        // target removal removed this creation's target (via some chain)\n        Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, targetRemoval)\n      )\n      if (concurrentRemoval) {\n        avoidTargetReorders[action.payload.parentId] = true\n        // Already deleted on target, do nothing.\n        return\n      }\n\n      targetPlan.CREATE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(sourceScanResult.MOVE.getActions(), async(action) => {\n      if (targetLocation === this.masterLocation) {\n        const concurrentMove = targetMoves.find(a =>\n          action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload))\n        if (concurrentMove) {\n          // Moved both on target and sourcely, source has precedence: do nothing sourcely\n          return\n        }\n      }\n      // FInd out if there's a removal in the target diff which already deletes this item (via some chain of MOVE|CREATEs)\n      const complexTargetTargetRemoval = targetRemovals.find(targetRemoval => {\n        return Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, targetRemoval)\n      })\n      const concurrentTargetOriginRemoval = targetRemovals.find(targetRemoval =>\n        (action.payload.type === targetRemoval.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, targetRemoval.payload)) ||\n        Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.oldItem, targetRemoval)\n      )\n      const concurrentSourceOriginRemoval = sourceRemovals.find(sourceRemoval => {\n        return Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, action.oldItem, sourceRemoval)\n      })\n      const concurrentSourceTargetRemoval = sourceRemovals.find(sourceRemoval =>\n        // We pass an empty folder here, because we don't want direct deletions of the moved folder's parent to count, as it's moved away anyway\n        Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, new Folder({id: 0, location: targetLocation}), action.payload, sourceRemoval)\n      )\n      if (complexTargetTargetRemoval) {\n        // target already deleted by a target|source REMOVE (connected via source MOVE|CREATEs)\n        if (!concurrentTargetOriginRemoval && !concurrentSourceOriginRemoval) {\n          // make sure this item is not already being removed, when it's no longer moved\n          // if (targetLocation === this.masterLocation) {\n          targetPlan.REMOVE.commit({ type: ActionType.REMOVE, payload: action.oldItem, oldItem: null })\n          SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, action.oldItem)\n          avoidTargetReorders[action.payload.id] = true\n          // }\n        }\n        return\n      }\n      if (concurrentSourceTargetRemoval) {\n        // target already deleted by a source REMOVE (connected via source MOVE|CREATEs)\n        if (targetLocation !== this.masterLocation) {\n          targetPlan.REMOVE.commit({ type: ActionType.REMOVE, payload: action.oldItem, oldItem: null })\n        }\n        SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, action.oldItem)\n        avoidTargetReorders[action.payload.id] = true\n        return\n      }\n      if (concurrentTargetOriginRemoval) {\n        // moved sourcely but removed on the target, recreate it on the target\n        if (targetLocation !== this.masterLocation) {\n          // only when coming from master do we recreate\n          const originalCreation = sourceCreations.find(creation => creation.payload.findItem(ItemType.FOLDER, action.payload.parentId))\n\n          // Remove subitems that have been (re)moved already by other actions\n          const newPayload = action.payload.clone()\n          if (newPayload.type === ItemType.FOLDER) {\n            newPayload.traverse((item, folder) => {\n              const removed = sourceRemovals.find(a => Mappings.mappable(mappingsSnapshot, item, a.payload))\n              const movedAway = sourceMoves.find(a => Mappings.mappable(mappingsSnapshot, item, a.payload))\n              if (removed || (movedAway && Mappings.mapParentId(mappingsSnapshot, movedAway.payload, item.location) !== item.parentId)) {\n                folder.children.splice(folder.children.indexOf(item), 1)\n              }\n            })\n          }\n\n          if (originalCreation && originalCreation.payload.type === ItemType.FOLDER) {\n            // in case the new parent is already a newly created item, merge it into that creation\n            const folder = originalCreation.payload.findFolder(action.payload.parentId)\n            folder.children.splice(action.index, 0, newPayload)\n          } else {\n            targetPlan.CREATE.commit({ type: ActionType.CREATE, oldItem: null, payload: newPayload })\n          }\n        }\n        return\n      }\n      // Find concurrent moves that form a hierarchy reversal together with this one\n      const concurrentHierarchyReversals = targetMoves.filter(targetMove => {\n        return Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, targetMove) &&\n          Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, targetMove.payload, action)\n      })\n      if (concurrentHierarchyReversals.length) {\n        if (targetLocation !== this.masterLocation) {\n          targetPlan.MOVE.commit(action)\n\n          concurrentHierarchyReversals.forEach(a => {\n            // moved sourcely but moved in reverse hierarchical order on target\n            const payload = a.oldItem.cloneWithLocation(false, action.payload.location)\n            const oldItem = a.payload.cloneWithLocation(false, action.oldItem.location)\n            oldItem.id = Mappings.mapId(mappingsSnapshot, a.payload, action.oldItem.location)\n            oldItem.parentId = Mappings.mapParentId(mappingsSnapshot, a.payload, action.oldItem.location)\n\n            if (\n              // Don't create duplicates!\n              targetPlan.MOVE.getActions().find(move => String(move.payload.id) === String(payload.id)) ||\n              sourceMoves.find(move => String(move.payload.id) === String(payload.id)) ||\n              // Don't move back into removed territory\n              targetRemovals.find(remove => Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, remove)) ||\n              sourceRemovals.find(remove => Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, action.payload, remove))\n            ) {\n              return\n            }\n\n            // revert target move\n            targetPlan.MOVE.commit({ ...a, payload, oldItem })\n            SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, payload)\n            SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, oldItem)\n          })\n        } else {\n          SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, action.oldItem)\n          SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, action.payload)\n        }\n        return\n      }\n\n      targetPlan.MOVE.commit(action)\n    }, 1)\n\n    await Parallel.each(sourceScanResult.UPDATE.getActions(), async(action) => {\n      const concurrentUpdate = targetUpdates.find(a =>\n        action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload))\n      if (concurrentUpdate && targetLocation === this.masterLocation) {\n        // Updated both on target and sourcely, source has precedence: do nothing sourcely\n        return\n      }\n      const concurrentRemoval = targetRemovals.find(a =>\n        a.payload.findItem(action.payload.type, Mappings.mapId(mappingsSnapshot, action.payload, a.payload.location)) ||\n        a.payload.findItem(ItemType.FOLDER, Mappings.mapParentId(mappingsSnapshot, action.payload, a.payload.location)))\n      if (concurrentRemoval) {\n        // Already deleted on target, do nothing.\n        return\n      }\n\n      targetPlan.UPDATE.commit(action)\n    })\n\n    await Parallel.each(sourceScanResult.REORDER.getActions(), async(action) => {\n      if (avoidTargetReorders[action.payload.id]) {\n        return\n      }\n\n      if (targetLocation === this.masterLocation) {\n        const concurrentReorder = targetReorders.find(a =>\n          action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload))\n        if (concurrentReorder) {\n          return\n        }\n      }\n\n      const concurrentRemoval = targetRemovals.find(a =>\n        a.payload.findItem('folder', action.payload.id))\n      if (concurrentRemoval) {\n        // Already deleted on target, do nothing.\n        return\n      }\n\n      targetPlan.REORDER.commit(action)\n    })\n\n    return targetPlan\n  }\n\n  async execute<L1 extends TItemLocation>(\n    resource:TResource<L1>,\n    planStage2:PlanStage2<TOppositeLocation<L1>, TItemLocation, L1>,\n    targetLocation:L1,\n    donePlan: PlanStage3<TOppositeLocation<L1>, TItemLocation, L1>,\n    reorders: Diff<TOppositeLocation<L1>, TItemLocation, ReorderAction<TOppositeLocation<L1>, TItemLocation>>): Promise<void> {\n    Logger.log('Executing ' + targetLocation + ' plan for ')\n\n    let createActions = planStage2.CREATE.getActions()\n    while (createActions.length > 0) {\n      Logger.log(targetLocation + ': executing CREATEs')\n      await Parallel.each(\n        createActions,\n        (action) => this.executeCreate(resource, action, targetLocation, planStage2.CREATE, reorders, donePlan),\n        ACTION_CONCURRENCY\n      )\n      createActions = planStage2.CREATE.getActions()\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing CREATEs')\n\n    await Parallel.each(\n      planStage2.UPDATE.getActions(),\n      (action) => this.executeUpdate(resource, action, targetLocation, planStage2.UPDATE, donePlan),\n      ACTION_CONCURRENCY\n    )\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const mappingsSnapshot = this.mappings.getSnapshot()\n    Logger.log(targetLocation + ': mapping MOVEs')\n\n    const planStage3: PlanStage3<TOppositeLocation<L1>, TItemLocation, typeof targetLocation> = {\n      CREATE: planStage2.CREATE,\n      UPDATE: planStage2.UPDATE,\n      MOVE: planStage2.MOVE.map(mappingsSnapshot, targetLocation),\n      REMOVE: planStage2.REMOVE,\n      REORDER: planStage2.REORDER,\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const batches = Diff.sortMoves(planStage3.MOVE.getActions(), this.getTargetTree(targetLocation))\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing MOVEs')\n    await Parallel.each(batches, batch => Parallel.each(batch, (action) => {\n      return this.executeUpdate(resource, action, targetLocation, planStage3.MOVE, donePlan)\n    }, ACTION_CONCURRENCY), 1)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing REMOVEs')\n    await Parallel.each(planStage3.REMOVE.getActions(), (action) => {\n      return this.executeRemove(resource, action, targetLocation, planStage3.REMOVE, donePlan)\n    }, ACTION_CONCURRENCY)\n  }\n\n  async executeCreate<L1 extends TItemLocation>(\n    resource: TResource<L1>,\n    action: CreateAction<L1, TOppositeLocation<L1>>,\n    targetLocation: L1,\n    diff: Diff<L1, TOppositeLocation<L1>, CreateAction<L1, TOppositeLocation<L1>>>,\n    reorders: Diff<TOppositeLocation<L1>, TItemLocation, ReorderAction<TOppositeLocation<L1>, TItemLocation>>,\n    donePlan: PlanStage3<TOppositeLocation<L1>, TItemLocation, L1>\n  ): Promise<void> {\n    // defer execution of actions to allow the this.canceled check below to work when cancelling in interrupt tests\n    await Promise.resolve()\n    Logger.log('Executing action ', action)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const done = () => {\n      diff.retract(action)\n      donePlan.CREATE.commit(action)\n      this.updateProgress()\n    }\n\n    const id = await action.payload.visitCreate(resource)\n    if (typeof id === 'undefined') {\n      // undefined means we couldn't create the item. we're ignoring it\n      done()\n      return\n    }\n\n    action.payload.id = id\n\n    if (action.oldItem) {\n      await this.addMapping(resource, action.oldItem, id)\n    }\n\n    if (action.payload instanceof Folder && !(action.oldItem instanceof Folder)) {\n      throw new Error('Assertion failed: action.oldItem should be set')\n    }\n\n    if (action.payload instanceof Folder && action.payload.children.length && action.oldItem instanceof Folder) {\n      // Fix for Unidirectional reverted REMOVEs, for all other strategies this should be a noop\n      action.payload.children.forEach((item) => {\n        item.parentId = id\n      })\n      // We *know* that oldItem exists here, because actions are mapped before being executed\n      if ('bulkImportFolder' in resource) {\n        if (action.payload.count() < 75 || this.server instanceof CachingAdapter) {\n          Logger.log('Attempting full bulk import')\n          try {\n            // Try bulk import with sub folders\n            const imported = await resource.bulkImportFolder(id, action.oldItem.cloneWithLocation(false, action.payload.location)) as Folder<typeof targetLocation>\n            const newMappings = []\n            const subScanner = new Scanner(\n              action.oldItem,\n              imported,\n              (oldItem, newItem) => {\n                if (oldItem.type === newItem.type && oldItem.canMergeWith(newItem)) {\n                  // if two items can be merged, we'll add mappings here directly\n                  newMappings.push([oldItem, newItem.id])\n                  return true\n                }\n                return false\n              },\n              this.preserveOrder,\n              false,\n            )\n            await subScanner.run()\n            await Parallel.each(newMappings, async([oldItem, newId]: [TItem<TItemLocation>, string|number]) => {\n              await this.addMapping(resource, oldItem, newId)\n            }, 10)\n\n            if ('orderFolder' in resource) {\n              const mappingsSnapshot = this.mappings.getSnapshot()\n              this.actionsPlanned++\n              reorders.commit({\n                type: ActionType.REORDER,\n                oldItem: imported,\n                payload: action.oldItem,\n                // payload children's IDs are not mapped\n                order: action.oldItem.children.map(i => ({ type: i.type, id: i.id }))\n              })\n              await action.oldItem.traverse((oldChildItem) => {\n                if (oldChildItem instanceof Folder && oldChildItem.children.length > 1) {\n                  // Correct the order after bulk import. Usually we expect bulk import to do the order correctly\n                  // on its own, but Nextcloud Bookmarks pre v14.2.0 does not\n                  const payload = imported.findFolder(Mappings.mapId(mappingsSnapshot, oldChildItem, targetLocation))\n                  // Order created items after the fact, as they've been created concurrently\n                  this.actionsPlanned++\n                  reorders.commit({\n                    type: ActionType.REORDER,\n                    oldItem: payload,\n                    payload: oldChildItem,\n                    order: oldChildItem.children.map(i => ({ type: i.type, id: i.id }))\n                  })\n                }\n              })\n            }\n\n            done()\n            return\n          } catch (e) {\n            Logger.log('Bulk import failed, continuing with normal creation', e)\n          }\n        } else {\n          try {\n            // Try bulk import without sub folders\n            const tempItem = action.oldItem.cloneWithLocation(false, action.payload.location)\n            const bookmarks = tempItem.children.filter(child => child instanceof Bookmark)\n            while (bookmarks.length > 0) {\n              Logger.log('Attempting chunked bulk import')\n              tempItem.children = bookmarks.splice(0, 70)\n              const imported = await resource.bulkImportFolder(action.payload.id, tempItem)\n              const newMappings = []\n              const subScanner = new Scanner(\n                tempItem,\n                imported,\n                (oldItem, newItem) => {\n                  if (oldItem.type === newItem.type && oldItem.canMergeWith(newItem)) {\n                    // if two items can be merged, we'll add mappings here directly\n                    newMappings.push([oldItem, newItem.id])\n                    return true\n                  }\n                  return false\n                },\n                this.preserveOrder,\n                false,\n              )\n              await subScanner.run()\n              await Parallel.each(newMappings, async([oldItem, newId]: [TItem<TItemLocation>, string|number]) => {\n                await this.addMapping(resource, oldItem, newId)\n              }, 10)\n            }\n\n            // create sub plan for the folders\n\n            const mappingsSnapshot = this.mappings.getSnapshot()\n\n            const folders = action.payload.children\n              .filter(item => item instanceof Folder)\n              .filter(item => item as Folder<L1>)\n\n            folders\n              .forEach((child) => {\n                // Necessary for Unidirectional reverted REMOVEs\n                const payload = child\n                payload.parentId = Mappings.mapParentId(mappingsSnapshot, child, targetLocation)\n                const oldItem = action.oldItem.findItem(child.type, child.id)\n                const newAction = { type: ActionType.CREATE, payload, oldItem }\n                this.actionsPlanned++\n                diff.commit(newAction)\n              })\n\n            if ('orderFolder' in resource) {\n              // Order created items after the fact, as they've been created concurrently\n              this.actionsPlanned++\n              reorders.commit({\n                type: ActionType.REORDER,\n                oldItem: action.payload,\n                payload: action.oldItem,\n                // payload children's IDs are not mapped\n                order: action.payload.children.map(i => ({ type: i.type, id: i.id }))\n              })\n            }\n\n            done()\n            return\n          } catch (e) {\n            Logger.log('Bulk import failed, continuing with normal creation', e)\n          }\n        }\n      }\n\n      // Create a sub plan and create each child individually (worst performance)\n      const mappingsSnapshot = this.mappings.getSnapshot()\n      action.payload.children\n        .forEach((child) => {\n          // Necessary for Unidirectional reverted REMOVEs\n          child.parentId = Mappings.mapParentId(mappingsSnapshot, child, targetLocation)\n          const oldItem = action.oldItem.findItem(child.type, child.id)\n          const newAction = { type: ActionType.CREATE, payload: child, oldItem }\n          this.actionsPlanned++\n          diff.commit(newAction)\n        })\n\n      if ('orderFolder' in resource) {\n        // Order created items after the fact, as they've been created concurrently\n        this.actionsPlanned++\n        reorders.commit({\n          type: ActionType.REORDER,\n          oldItem: action.payload,\n          payload: action.oldItem,\n          order: action.oldItem.children.map(i => ({ type: i.type, id: i.id }))\n        })\n      }\n    }\n\n    done()\n  }\n\n  async executeRemove<L1 extends TItemLocation>(\n    resource: TResource<L1>,\n    action: RemoveAction<L1, TItemLocation>,\n    targetLocation: L1,\n    diff: Diff<L1, TItemLocation, RemoveAction<L1, TItemLocation>>,\n    donePlan: PlanStage3<TOppositeLocation<L1>, TItemLocation, L1>\n  ): Promise<void> {\n    // defer execution of actions to allow the this.canceled check below to work when cancelling in interrupt tests\n    await Promise.resolve()\n    Logger.log('Executing action ', action)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    await action.payload.visitRemove(resource)\n    await this.removeMapping(resource, action.payload)\n    diff.retract(action)\n    donePlan.REMOVE.commit(action)\n    this.updateProgress()\n  }\n\n  async executeUpdate<L1 extends TItemLocation>(\n    resource: TResource<L1>,\n    action: UpdateAction<L1, TItemLocation> | MoveAction<L1, TItemLocation>,\n    targetLocation: L1,\n    diff: Diff<L1, TItemLocation, UpdateAction<L1, TItemLocation> | MoveAction<L1, TItemLocation>>,\n    donePlan: PlanStage3<TItemLocation, TItemLocation, L1>): Promise<void> {\n    // defer execution of actions to allow the this.canceled check below to work when cancelling in interrupt tests\n    await Promise.resolve()\n    Logger.log('Executing action ', action)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    await action.payload.visitUpdate(resource)\n    await this.addMapping(resource, action.oldItem, action.payload.id)\n    diff.retract(action)\n    if (action.type === ActionType.UPDATE) {\n      donePlan.UPDATE.commit(action)\n    } else {\n      donePlan.MOVE.commit(action)\n    }\n    this.updateProgress()\n  }\n\n  reconcileReorderings<L1 extends TItemLocation, L2 extends TItemLocation>(\n    targetReorders: Diff<L2, TItemLocation, ReorderAction<L2, TItemLocation>>,\n    sourceDonePlan: PlanStage3<L1, TItemLocation, L2>,\n    targetLocation: L1,\n    mappingSnapshot: MappingSnapshot\n  ) : Diff<L1, TItemLocation, ReorderAction<L1, TItemLocation>> {\n    Logger.log('Reconciling reorders to create a plan')\n\n    const sourceCreations = sourceDonePlan.CREATE.getActions()\n    const sourceRemovals = sourceDonePlan.REMOVE.getActions()\n    const sourceMoves = sourceDonePlan.MOVE.getActions()\n\n    const newReorders = new Diff<L2, TItemLocation, ReorderAction<L2, TItemLocation>>\n\n    targetReorders\n      .getActions()\n    // MOVEs have oldItem from cacheTree and payload now mapped to their corresponding target tree\n    // REORDERs have payload in source tree\n      .forEach(oldReorderAction => {\n        // clone action\n        const reorderAction = {...oldReorderAction, order: oldReorderAction.order.slice()}\n\n        const removed = sourceRemovals\n          .filter(removal => removal.payload.findItem(reorderAction.payload.type, removal.payload.id))\n        if (removed.length) {\n          return\n        }\n\n        // Find Away-moves\n        const childAwayMoves = sourceMoves\n          .filter(move =>\n            (String(reorderAction.payload.id) !== String(move.payload.parentId) && // reorder IDs are from localTree (source of this plan), move.oldItem IDs are from server tree (source of other plan)\n                reorderAction.order.find(item => String(item.id) === String(move.payload.id) && item.type === move.payload.type))// move.payload IDs are from localTree (target of the other plan\n          )\n\n        // Find removals\n        const concurrentRemovals = sourceRemovals\n          .filter(removal => reorderAction.order.find(item => String(item.id) === String(removal.payload.id) && item.type === removal.payload.type))\n\n        // Remove away-moves and removals\n        reorderAction.order = reorderAction.order.filter(item => {\n          let action\n          if (\n            // eslint-disable-next-line no-cond-assign\n            action = childAwayMoves.find(move =>\n              String(item.id) === String(move.payload.id) && move.payload.type === item.type)) {\n            Logger.log('ReconcileReorders: Removing moved item from order', {move: action, reorder: reorderAction})\n            return false\n          }\n\n          if (\n            // eslint-disable-next-line no-cond-assign\n            action = concurrentRemovals.find(removal =>\n              String(item.id) === String(removal.payload.id) && removal.payload.type === item.type)\n          ) {\n            Logger.log('ReconcileReorders: Removing removed item from order', {item, reorder: reorderAction, removal: action})\n            return false\n          }\n          return true\n        })\n\n        // Find and insert creations\n        const concurrentCreations = sourceCreations\n          .filter(creation => String(reorderAction.payload.id) === String(creation.payload.parentId))\n        concurrentCreations\n          .forEach(a => {\n            Logger.log('ReconcileReorders: Inserting created item into order', {creation: a, reorder: reorderAction})\n            reorderAction.order.splice(a.index, 0, { type: a.payload.type, id: a.payload.id })\n          })\n\n        // Find and insert moves at move target\n        const moves = sourceMoves\n          .filter(move =>\n            String(reorderAction.payload.id) === String(move.payload.parentId) &&\n                  !reorderAction.order.find(item => String(item.id) === String(move.payload.id) && item.type === move.payload.type)\n          )\n        moves.forEach(a => {\n          Logger.log('ReconcileReorders: Inserting moved item into order', {move: a, reorder: reorderAction})\n          reorderAction.order.splice(a.index, 0, { type: a.payload.type, id: a.payload.id })\n        })\n\n        newReorders.commit(reorderAction)\n      })\n\n    return newReorders.map(mappingSnapshot, targetLocation)\n  }\n\n  async executeReorderings(resource:OrderFolderResource<TItemLocation>, reorderings:Diff<TItemLocation, TItemLocation, ReorderAction<TItemLocation, TItemLocation>>):Promise<void> {\n    Logger.log('Executing reorderings')\n    Logger.log({ reorderings })\n\n    await Parallel.each(reorderings.getActions(), async(action) => {\n      Logger.log('Executing reorder action', `${action.type} Payload: #${action.payload.id}[${action.payload.title}]${'url' in action.payload ? `(${action.payload.url})` : ''} parentId: ${action.payload.parentId}`)\n      const item = action.payload\n\n      if (this.canceled) {\n        throw new CancelledSyncError()\n      }\n\n      if (action.order.length <= 1) {\n        return\n      }\n\n      const items = {}\n      try {\n        await resource.orderFolder(item.id, action.order\n          // in rare situations the diff generates a REMOVE for an item that is still in the tree,\n          // make sure to sort out those failed mapings (value: undefined)\n          // also make sure that items are unique\n          .filter(item => {\n            if (items[item.type + '' + item.id]) {\n              return false\n            }\n            items[item.type + '' + item.id] = true\n            return item.id\n          })\n        )\n      } catch (e) {\n        Logger.log('Failed to execute REORDER: ' + e.message + '\\nMoving on.')\n        Logger.log(e)\n      }\n      reorderings.retract(action)\n      this.updateProgress()\n    }, ACTION_CONCURRENCY)\n  }\n\n  async addMapping(resource:TResource<TItemLocation>, item:TItem<TItemLocation>, newId:string|number):Promise<void> {\n    await Promise.resolve()\n    let localId, remoteId\n    if (resource === this.server) {\n      localId = item.id\n      remoteId = newId\n    } else {\n      localId = newId\n      remoteId = item.id\n    }\n    if (item.type === 'folder') {\n      await this.mappings.addFolder({ localId, remoteId })\n    } else {\n      await this.mappings.addBookmark({ localId, remoteId })\n    }\n  }\n\n  async removeMapping(resource:TResource<TItemLocation>, item:TItem<TItemLocation>):Promise<void> {\n    let localId, remoteId\n    if (resource === this.server) {\n      remoteId = item.id\n    } else {\n      localId = item.id\n    }\n    if (item.type === 'folder') {\n      await this.mappings.removeFolder({ localId, remoteId })\n    } else {\n      await this.mappings.removeBookmark({ localId, remoteId })\n    }\n  }\n\n  async loadChildren(\n    serverItem:TItem<typeof ItemLocation.SERVER>,\n    mappingsSnapshot:MappingSnapshot,\n    isRoot = false\n  ):Promise<void> {\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n    if (!(serverItem instanceof Folder)) return\n    if (!('loadFolderChildren' in this.server)) return\n    let localItem, cacheItem\n    if (isRoot) {\n      localItem = this.localTreeRoot\n      cacheItem = this.cacheTreeRoot\n    } else {\n      const localId = mappingsSnapshot.ServerToLocal.folder[serverItem.id]\n      localItem = this.localTreeRoot.findFolder(localId)\n      cacheItem = this.cacheTreeRoot.findFolder(localId)\n    }\n    if (\n      localItem &&\n      !(await this.folderHasChanged(localItem, cacheItem, serverItem))\n    ) {\n      return\n    }\n    Logger.log('LOADCHILDREN', serverItem)\n    // If we don't know this folder, yet, load the whole subtree (!localItem)\n    const children = await this.server.loadFolderChildren(serverItem.id, !localItem)\n    if (!children) {\n      return\n    }\n    serverItem.children = children\n    serverItem.loaded = true\n\n    // recurse\n    await Parallel.each(\n      serverItem.children,\n      child => this.loadChildren(child, mappingsSnapshot),\n      10\n    )\n  }\n\n  async folderHasChanged(localItem: TItem<typeof ItemLocation.LOCAL>, cacheItem: TItem<typeof ItemLocation.LOCAL>, serverItem: TItem<typeof ItemLocation.SERVER>):Promise<boolean> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n    const localHash = localItem\n      ? await localItem.hash(this.preserveOrder)\n      : null\n    const cacheHash = cacheItem\n      ? await cacheItem.hash(this.preserveOrder)\n      : null\n    const serverHash = serverItem\n      ? await serverItem.hash(this.preserveOrder)\n      : null\n    const reconciled = !cacheItem\n    const changedLocally =\n      (localHash !== cacheHash) ||\n      (cacheItem && String(localItem.parentId) !== String(cacheItem.parentId))\n    const changedUpstream =\n      (cacheHash !== serverHash) ||\n      (cacheItem &&\n        String(cacheItem.parentId) !==\n        String(mappingsSnapshot.ServerToLocal.folder[serverItem.parentId]))\n    return changedLocally || changedUpstream || reconciled\n  }\n\n  filterOutUnmappedItems(tree: Folder<TItemLocation>, mapping: MappingSnapshot) {\n    tree.children = tree.children.filter(child => {\n      if (child instanceof Bookmark) {\n        return child.id in mapping.LocalToServer.bookmark\n      } else {\n        if (child.id in mapping.LocalToServer.folder) {\n          this.filterOutUnmappedItems(child, mapping)\n          return true\n        } else {\n          return false\n        }\n      }\n    })\n  }\n\n  static removeItemFromReorders(\n    mappingsSnapshot: MappingSnapshot,\n    sourceReorders:Diff<TItemLocation, TItemLocation, ReorderAction<TItemLocation, TItemLocation>>,\n    oldItem: TItem<TItemLocation>) {\n    const parentReorder = sourceReorders.getActions().find(action => Mappings.mapId(mappingsSnapshot, action.payload, oldItem.location) === oldItem.parentId)\n    if (!parentReorder) {\n      return\n    }\n    parentReorder.order = parentReorder.order.filter(item => !(item.type === oldItem.type && Mappings.mapId(mappingsSnapshot, oldItem, parentReorder.payload.location) === item.id))\n  }\n\n  toJSON(): ISerializedSyncProcess {\n    if (!this.staticContinuation) {\n      this.staticContinuation = {\n        localTreeRoot: this.localTreeRoot && this.localTreeRoot.clone(false),\n        cacheTreeRoot: this.cacheTreeRoot && this.cacheTreeRoot.clone(false),\n        serverTreeRoot: this.serverTreeRoot && this.serverTreeRoot.clone(false),\n      }\n    }\n    const membersToPersist = this.getMembersToPersist()\n    return {\n      strategy: 'default',\n      ...this.staticContinuation,\n      ...(Object.fromEntries(Object.entries(this)\n        .filter(([key]) => membersToPersist.includes(key)))\n      ),\n    }\n  }\n\n  static async fromJSON(mappings:Mappings,\n    localTree:TLocalTree,\n    server:TAdapter,\n    progressCb:(progress:number, actionsDone:number)=>void,\n    json: any) {\n    let strategy: SyncProcess\n    switch (json.strategy) {\n      case 'default':\n        strategy = new SyncProcess(mappings, localTree, server, progressCb)\n        break\n      case 'merge':\n        // eslint-disable-next-line no-case-declarations\n        const MergeSyncProcess = (await import('./Merge')).default\n        strategy = new MergeSyncProcess(mappings, localTree, server, progressCb)\n        break\n      case 'unidirectional':\n        // eslint-disable-next-line no-case-declarations\n        const UnidirectionalSyncProcess = (await import('./Unidirectional')).default\n        strategy = new UnidirectionalSyncProcess(mappings, localTree, server, progressCb)\n        break\n      default:\n        throw new Error('Unknown strategy: ' + json.strategy)\n    }\n    strategy.setProgress(json)\n    if (json.serverTreeRoot) {\n      strategy.serverTreeRoot = Folder.hydrate(json.serverTreeRoot)\n    }\n    if (json.localTreeRoot) {\n      strategy.localTreeRoot = Folder.hydrate(json.localTreeRoot)\n    }\n    if (json.cacheTreeRoot) {\n      strategy.cacheTreeRoot = Folder.hydrate(json.cacheTreeRoot)\n    }\n    strategy.getMembersToPersist().forEach((member) => {\n      if (member in json) {\n        if (member.toLowerCase().includes('scanresult') || member.toLowerCase().includes('plan')) {\n          this[member] = {\n            CREATE: Diff.fromJSON(json[member].CREATE),\n            UPDATE: Diff.fromJSON(json[member].UPDATE),\n            MOVE: Diff.fromJSON(json[member].MOVE),\n            REMOVE: Diff.fromJSON(json[member].REMOVE),\n            REORDER: Diff.fromJSON(json[member].REORDER),\n          }\n        } else if (member.toLowerCase().includes('reorders')) {\n          this[member] = Diff.fromJSON(json[member])\n        } else {\n          this[member] = json[member]\n        }\n      }\n    })\n\n    return strategy\n  }\n}\n\nexport interface ISerializedSyncProcess {\n  strategy: 'default' | 'merge' | 'unidirectional'\n  [k: string]: any\n}\n","import IController from './interfaces/Controller'\nimport { Capacitor } from '@capacitor/core'\n\ninterface FloccusWorker {\n  postMessage(data: any): void\n  addEventListener(fn: (data: any) => void): () => void\n}\n\nexport default class Controller implements IController {\n  public static singleton: IController\n  private worker: FloccusWorker|null\n  private key: string|null|undefined\n\n  static async getSingleton():Promise<IController> {\n    if (!this.singleton) {\n      if (Capacitor.getPlatform() === 'web') {\n        // otherwise load the proxy\n        this.singleton = new Controller\n      } else {\n        // If we're not on the web, laod the implementation directly\n        this.singleton = new (await import('./native/NativeController')).default\n      }\n    }\n    return this.singleton\n  }\n\n  constructor(worker?: FloccusWorker) {\n    this.worker = worker\n  }\n\n  async getWorker(): Promise<FloccusWorker> {\n    if (this.worker) {\n      return Promise.resolve(this.worker)\n    }\n    if (!navigator.userAgent.includes('Firefox') && navigator.serviceWorker?.controller) {\n      return navigator.serviceWorker.ready.then((registration) => ({\n        postMessage: (...args) => registration.active.postMessage(...args),\n        addEventListener: (fn) => {\n          const listener = (event) => fn(event.data)\n          navigator.serviceWorker.addEventListener('message', listener)\n          return () => navigator.serviceWorker.removeEventListener('message', listener)\n        },\n      }))\n    }\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../lib/browser-api')).default\n      return {\n        postMessage: (data) => {\n          try {\n            browser.runtime.sendMessage(data)\n          } catch (e) {\n            console.warn(e)\n          }\n        },\n        addEventListener: (fn) => {\n          try {\n            browser.runtime.onMessage.addListener(fn)\n          } catch (e) {\n            console.warn(e)\n          }\n          return () => {\n            try {\n              browser.runtime.onMessage.removeListener(fn)\n            } catch (e) {\n              console.warn(e)\n            }\n          }\n        },\n      }\n    }\n  }\n\n  async cancelSync(accountId, keepEnabled): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'cancelSync', params: [accountId, keepEnabled]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  onStatusChange(listener): () => void {\n    const eventListener = (data) => {\n      const {type} = data\n      if (type === 'status:update') {\n        listener()\n      }\n    }\n    let worker, removeListener\n    this.getWorker().then(w => {\n      worker = w\n      removeListener = worker.addEventListener(eventListener)\n    })\n    return () => {\n      removeListener && removeListener()\n    }\n  }\n\n  async scheduleSync(accountId, wait): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'scheduleSync', params: [accountId, wait]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async scheduleAll(): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'scheduleAll', params: []}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async setEnabled(enabled: boolean): Promise<void> {\n    const worker = await this.getWorker()\n    const message = {type: 'setEnabled', params: [enabled]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async syncAccount(accountId, strategy, forceSync = false): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'syncAccount', params: [accountId, strategy, forceSync]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async unlock(key): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'unlock', params: [key]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async getUnlocked(): Promise<boolean> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n\n    return new Promise((resolve) => {\n      const eventListener = (data) => {\n        if (data.type === 'getUnlockedResponse') {\n          resolve(data.params[0])\n          console.log('Message response received', data)\n          removeEventListener()\n        }\n      }\n      const removeEventListener = worker.addEventListener(eventListener)\n      const message = { type: 'getUnlocked', params: [] }\n      worker.postMessage(message)\n      console.log('Sending message to service worker: ', message)\n    })\n  }\n\n  async onLoad() {\n    // noop\n  }\n}\n","/* global chrome browser */\n\nconst ChromePromise = (function(root) {\n  'use strict'\n  var push = Array.prototype.push,\n    hasOwnProperty = Object.prototype.hasOwnProperty\n\n  function ChromePromise(chrome, Promise) {\n    chrome = chrome || root.chrome\n    Promise = Promise || root.Promise\n\n    var runtime = chrome.runtime\n\n    fillProperties(chrome, this)\n\n    /// /////////////\n\n    function setPromiseFunction(fn, thisArg) {\n      return function() {\n        var args = arguments\n\n        return new Promise(function(resolve, reject) {\n          function callback() {\n            var err = runtime.lastError\n            if (err) {\n              reject(err)\n            } else {\n              resolve.apply(null, arguments)\n            }\n          }\n\n          push.call(args, callback)\n\n          fn.apply(thisArg, args)\n        })\n      }\n    }\n\n    function fillProperties(source, target) {\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          var val = source[key]\n          var type = typeof val\n\n          if (type === 'object' && !(val instanceof ChromePromise) && key.indexOf('on') !== 0) {\n            target[key] = {}\n            fillProperties(val, target[key])\n          } else if (type === 'function') {\n            target[key] = setPromiseFunction(val, source)\n          } else {\n            target[key] = val\n          }\n        }\n      }\n    }\n  }\n\n  return ChromePromise\n})(typeof window !== 'undefined' ? window : self)\n\nlet b\nif (typeof browser === 'undefined' && typeof chrome !== 'undefined') {\n  b = new ChromePromise(chrome, Promise)\n  b.alarms = chrome.alarms // Don't promisify alarms -- don't make sense, yo!\n  b.browserAction = chrome.browserAction // apparently, they provide no callbacks for these\n  b.action = chrome.action // apparently, they provide no callbacks for these\n  b.i18n = chrome.i18n\n} else {\n  b = browser\n}\n\nexport default b\n","import { Folder, ItemLocation, TItem, TItemLocation, TOppositeLocation } from '../Tree'\nimport Diff, { CreateAction, MoveAction, PlanStage1, PlanStage3, ReorderAction } from '../Diff'\nimport Scanner, { ScanResult } from '../Scanner'\nimport * as Parallel from 'async-parallel'\nimport DefaultSyncProcess, { ISerializedSyncProcess } from './Default'\nimport Mappings, { MappingSnapshot } from '../Mappings'\nimport Logger from '../Logger'\n\nconst ACTION_CONCURRENCY = 12\n\nexport default class MergeSyncProcess extends DefaultSyncProcess {\n  async getDiffs():Promise<{localScanResult:ScanResult<typeof ItemLocation.LOCAL, TItemLocation>, serverScanResult:ScanResult<typeof ItemLocation.SERVER, TItemLocation>}> {\n    // If there's no cache, diff the two trees directly\n    const newMappings: TItem<TItemLocation>[][] = []\n    const localScanner = new Scanner(\n      this.serverTreeRoot,\n      this.localTreeRoot,\n      (serverItem, localItem) => {\n        if (localItem.type === serverItem.type && serverItem.canMergeWith(localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        return false\n      },\n      this.preserveOrder,\n      false,\n      false\n    )\n    const serverScanner = new Scanner(\n      this.localTreeRoot,\n      this.serverTreeRoot,\n      (localItem, serverItem) => {\n        if (serverItem.type === localItem.type && serverItem.canMergeWith(localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        return false\n      },\n      this.preserveOrder,\n      false,\n      false\n    )\n    const localScanResult = await localScanner.run()\n    const serverScanResult = await serverScanner.run()\n    await Parallel.map(newMappings, ([localItem, serverItem]) => {\n      return this.addMapping(this.server, localItem, serverItem.id)\n    }, 10)\n\n    return {localScanResult, serverScanResult}\n  }\n\n  async reconcileDiffs<L1 extends TItemLocation, L2 extends TItemLocation, L3 extends TItemLocation>(\n    sourceScanResult:ScanResult<L1, L2>,\n    targetScanResult:ScanResult<TOppositeLocation<L1>, L3>,\n    targetLocation: TOppositeLocation<L1>\n  ): Promise<PlanStage1<L1, L2>> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const targetCreations = targetScanResult.CREATE.getActions()\n    const targetMoves = targetScanResult.MOVE.getActions()\n\n    const sourceMoves = sourceScanResult.MOVE.getActions()\n    const sourceUpdates = sourceScanResult.UPDATE.getActions()\n\n    const targetTree = this.getTargetTree(targetLocation)\n    const sourceTree = this.getTargetTree(targetLocation === ItemLocation.LOCAL ? ItemLocation.SERVER : ItemLocation.LOCAL) as Folder<L1>\n\n    const allCreateAndMoveActions = (sourceScanResult.CREATE.getActions() as Array<CreateAction<L1, L2> | MoveAction<L1, L2> | CreateAction<TOppositeLocation<L1>, L3> | MoveAction<TOppositeLocation<L1>, L3>>)\n      .concat(sourceScanResult.MOVE.getActions())\n      .concat(targetScanResult.CREATE.getActions())\n      .concat(targetScanResult.MOVE.getActions())\n\n    // Prepare target plan\n    const targetPlan: PlanStage1<L1, L2> = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: new Diff(),\n    }\n\n    await Parallel.each(sourceScanResult.CREATE.getActions(), async(action) => {\n      const concurrentCreation = targetCreations.find(a =>\n        a.payload.parentId === Mappings.mapParentId(mappingsSnapshot, action.payload, a.payload.location) &&\n        action.payload.canMergeWith(a.payload))\n      if (concurrentCreation) {\n        // created on both the server and locally, try to reconcile\n        const newMappings = []\n        const subScanner = new Scanner(\n          concurrentCreation.payload, // server tree\n          action.payload, // local tree\n          (oldItem, newItem) => {\n            if (oldItem.type === newItem.type && oldItem.canMergeWith(newItem)) {\n              // if two items can be merged, we'll add mappings here directly\n              newMappings.push([oldItem, newItem.id])\n              return true\n            }\n            return false\n          },\n          this.preserveOrder,\n          false,\n          false\n        )\n        await subScanner.run()\n        newMappings.push([concurrentCreation.payload, action.payload.id])\n        await Parallel.each(newMappings, async([oldItem, newId]) => {\n          await this.addMapping(action.payload.location === ItemLocation.LOCAL ? this.localTree : this.server, oldItem, newId)\n        },1)\n        // TODO: subScanner may contain residual CREATE/REMOVE actions that need to be added to mappings\n        return\n      }\n\n      targetPlan.CREATE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(sourceScanResult.MOVE.getActions(), async(action) => {\n      if (targetLocation === ItemLocation.LOCAL) {\n        const concurrentMove = sourceMoves.find(a =>\n          (action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload)) ||\n          (action.payload.type === 'bookmark' && action.payload.canMergeWith(a.payload))\n        )\n        if (concurrentMove) {\n          // Moved both on server and locally, local has precedence: do nothing locally\n          return\n        }\n      }\n      // Find concurrent moves that form a hierarchy reversal together with this one\n      const concurrentHierarchyReversals = targetMoves.filter(targetMove => {\n        return Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, targetMove) &&\n          Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, targetMove.payload, action)\n      })\n      if (concurrentHierarchyReversals.length) {\n        if (targetLocation === ItemLocation.SERVER) {\n          concurrentHierarchyReversals.forEach(a => {\n            // moved locally but moved in reverse hierarchical order on server\n            const payload = a.oldItem.cloneWithLocation(false, action.payload.location) // we don't map here as we want this to look like a local action\n            const oldItem = a.payload.cloneWithLocation(false, action.oldItem.location)\n            oldItem.id = Mappings.mapId(mappingsSnapshot, oldItem, action.payload.location)\n            oldItem.parentId = Mappings.mapParentId(mappingsSnapshot, oldItem, action.payload.location)\n\n            if (\n              targetPlan.MOVE.getActions().find(move => String(move.payload.id) === String(payload.id)) ||\n              sourceMoves.find(move => String(move.payload.id) === String(payload.id))\n            ) {\n              // Don't create duplicates!\n              return\n            }\n\n            // revert server move\n            targetPlan.MOVE.commit({ ...a, payload, oldItem })\n          })\n          targetPlan.MOVE.commit(action)\n        }\n\n        // if target === LOCAL: Moved locally and in reverse hierarchical order on server. local has precedence: do nothing locally\n        return\n      }\n\n      targetPlan.MOVE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(sourceScanResult.UPDATE.getActions(), async(action) => {\n      const concurrentUpdate = sourceUpdates.find(a =>\n        action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload))\n      if (concurrentUpdate && targetLocation === ItemLocation.LOCAL) {\n        // Updated both on server and locally, local has precedence: do nothing locally\n        return\n      }\n\n      targetPlan.UPDATE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    return targetPlan\n  }\n\n  reconcileReorderings<L1 extends TItemLocation, L2 extends TItemLocation>(\n    targetReorders: Diff<L2, TItemLocation, ReorderAction<L2, TItemLocation>>,\n    sourceDonePlan: PlanStage3<L1, TItemLocation, L2>,\n    targetLocation: L1,\n    mappingSnapshot: MappingSnapshot\n  ) : Diff<L1, TItemLocation, ReorderAction<L1, TItemLocation>> {\n    return super.reconcileReorderings(targetReorders, sourceDonePlan, targetLocation, mappingSnapshot)\n  }\n\n  async loadChildren(serverTreeRoot: Folder<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('Merge strategy: Load complete tree from server')\n    serverTreeRoot.children = (await this.server.getBookmarksTree(true)).children\n  }\n\n  toJSON(): ISerializedSyncProcess {\n    return {\n      ...DefaultSyncProcess.prototype.toJSON.apply(this),\n      strategy: 'merge'\n    }\n  }\n}\n","import { TAdapter } from './interfaces/Adapter'\nimport { IAccountData } from './interfaces/AccountStorage'\n\nexport default {\n  registry: {},\n  register(type:string, adapter: any):void {\n    this.registry[type] = adapter\n  },\n  async factory(data: any): Promise<TAdapter> {\n    if ('type' in data) {\n      const adapter = await this.registry[data.type]()\n      return new adapter(data)\n    }\n  },\n  async getDefaultValues(type:string):Promise<IAccountData> {\n    const adapter = await this.registry[type]()\n    return {\n      ...adapter.getDefaultValues(),\n      enabled: true,\n    }\n  }\n}\n","import AdapterFactory from './AdapterFactory'\nimport Logger from './Logger'\nimport { ItemLocation, TItemLocation } from './Tree'\nimport UnidirectionalSyncProcess from './strategies/Unidirectional'\nimport MergeSyncProcess from './strategies/Merge'\nimport DefaultSyncProcess from './strategies/Default'\nimport IAccountStorage, { IAccountData, TAccountStrategy } from './interfaces/AccountStorage'\nimport { TAdapter } from './interfaces/Adapter'\nimport { OrderFolderResource, TLocalTree } from './interfaces/Resource'\nimport { Capacitor } from '@capacitor/core'\nimport IAccount from './interfaces/Account'\nimport Mappings from './Mappings'\nimport { isTest } from './isTest'\nimport CachingAdapter from './adapters/Caching'\nimport * as Sentry from '@sentry/vue'\nimport AsyncLock from 'async-lock'\n\ndeclare const DEBUG: boolean\n\n// register Adapters\nAdapterFactory.register('linkwarden', async() => (await import('./adapters/Linkwarden')).default)\nAdapterFactory.register('nextcloud-folders', async() => (await import('./adapters/NextcloudBookmarks')).default)\nAdapterFactory.register('nextcloud-bookmarks', async() => (await import('./adapters/NextcloudBookmarks')).default)\nAdapterFactory.register('webdav', async() => (await import('./adapters/WebDav')).default)\nAdapterFactory.register('git', async() => (await import('./adapters/Git')).default)\nAdapterFactory.register('google-drive', async() => (await import('./adapters/GoogleDrive')).default)\nAdapterFactory.register('fake', async() => (await import('./adapters/Fake')).default)\n\n// 2h\nconst LOCK_TIMEOUT = 1000 * 60 * 60 * 2\n\nconst dataLock = new AsyncLock()\n\nexport default class Account {\n  static cache = {}\n  static singleton : IAccount\n\n  static async getAccountClass(): Promise<IAccount> {\n    if (this.singleton) {\n      return this.singleton\n    }\n    if (Capacitor.getPlatform() === 'web') {\n      this.singleton = (await import('./browser/BrowserAccount')).default\n    } else {\n      this.singleton = (await import('./native/NativeAccount')).default\n    }\n    return this.singleton\n  }\n\n  static async get(id:string):Promise<Account> {\n    if (this.cache[id]) {\n      await this.cache[id].updateFromStorage()\n      return this.cache[id]\n    }\n    const account = await (await this.getAccountClass()).get(id)\n    this.cache[id] = account\n    return account\n  }\n\n  static async create(data: IAccountData):Promise<Account> {\n    return (await this.getAccountClass()).create(data)\n  }\n\n  static async import(accounts:IAccountData[]):Promise<void> {\n    for (const accountData of accounts) {\n      await this.create({...accountData, enabled: false})\n    }\n  }\n\n  static async export(accountIds:string[]):Promise<IAccountData[]> {\n    return (await Promise.all(\n      accountIds.map(id => Account.get(id))\n    )).map(a => a.getData())\n  }\n\n  public id: string\n  public syncing: boolean\n  protected syncProcess: DefaultSyncProcess\n  protected storage: IAccountStorage\n  protected server: TAdapter\n  protected localTree: TLocalTree\n  protected localTabs: TLocalTree\n  protected lockTimeout: number\n\n  constructor(id:string, storageAdapter:IAccountStorage, serverAdapter: TAdapter, treeAdapter:TLocalTree) {\n    this.server = serverAdapter\n    this.id = id\n    this.storage = storageAdapter\n    this.localTree = treeAdapter\n    this.lockTimeout = LOCK_TIMEOUT\n  }\n\n  async delete():Promise<void> {\n    await this.storage.deleteAccountData()\n  }\n\n  getLabel():string {\n    return this.server.getLabel()\n  }\n\n  getData():IAccountData {\n    const data = {\n      localRoot: null,\n      strategy: 'default' as TAccountStrategy,\n      syncInterval: 15,\n      nestedSync: false,\n      failsafe: true,\n      allowNetwork: false,\n      label: '',\n      errorCount: 0,\n      clickCountEnabled: false,\n      ...this.server.getData()\n    }\n    if ('type' in data && data.type === 'nextcloud-folders') {\n      data.type = 'nextcloud-bookmarks'\n    }\n    return data\n  }\n\n  async getResource():Promise<OrderFolderResource<typeof ItemLocation.LOCAL>> {\n    return this.localTree\n  }\n\n  async getServer():Promise<TAdapter> {\n    return this.server\n  }\n\n  async setData(data:Partial<IAccountData>):Promise<void> {\n    await dataLock.acquire(this.id, async() => {\n      const d = {...this.server.getData(), ...data}\n      await this.storage.setAccountData(d, null)\n      this.server.setData(d)\n    })\n  }\n\n  async updateFromStorage():Promise<void> {\n    throw new Error('Not implemented')\n  }\n\n  async tracksBookmark(localId:string):Promise<boolean> {\n    if (!(await this.isInitialized())) return false\n    const mappings = await this.storage.getMappings()\n    const snapshot = mappings.getSnapshot()\n    const foundBookmark = Object.keys(snapshot.LocalToServer.bookmark).some(\n      (id) => String(localId) === String(id)\n    )\n    const foundFolder = Object.keys(snapshot.LocalToServer.folder).some(\n      (id) => String(localId) === String(id)\n    )\n    return foundBookmark || foundFolder\n  }\n\n  async init():Promise<void> {\n    throw new Error('Not implemented')\n  }\n\n  async isInitialized():Promise<boolean> {\n    throw new Error('Not implemented')\n  }\n\n  async sync(strategy?:TAccountStrategy, forceSync = false):Promise<void> {\n    let mappings: Mappings\n    try {\n      if (this.getData().syncing || this.syncing) return\n\n      const localResource = await this.getResource()\n      if (!(await this.server.isAvailable()) || !(await localResource.isAvailable())) return\n\n      Logger.log('Starting sync process for account ' + this.getLabel())\n      Sentry.setUser({ id: this.id })\n      this.syncing = true\n      await this.setData({ syncing: 0.05, scheduled: false, error: null })\n\n      if (!(await this.isInitialized())) {\n        await this.init()\n      }\n\n      if (this.server.onSyncStart) {\n        const needLock = (strategy || this.getData().strategy) !== 'slave'\n        let status\n        try {\n          status = await this.server.onSyncStart(needLock, forceSync)\n        } catch (e) {\n          // Resource locked\n          if (e.code === 37) {\n            // We got a resource locked error\n            if (this.getData().lastSync < Date.now() - this.lockTimeout || forceSync) {\n              // but if we've been waiting for the lock for more than 2h\n              // start again without locking the resource\n              status = await this.server.onSyncStart(false, true)\n            } else {\n              await this.setData({\n                error: null,\n                syncing: false,\n                scheduled: strategy || this.getData().strategy\n              })\n              this.syncing = false\n              Logger.log(\n                'Resource is locked, trying again soon'\n              )\n              await Logger.persist()\n              return\n            }\n          } else {\n            throw e\n          }\n        }\n        if (status === false) {\n          await this.init()\n        }\n      }\n\n      // main sync steps:\n      mappings = await this.storage.getMappings()\n      const cacheTree = await this.storage.getCache()\n\n      let continuation = await this.storage.getCurrentContinuation()\n\n      if (typeof continuation !== 'undefined' && continuation !== null) {\n        try {\n          this.syncProcess = await DefaultSyncProcess.fromJSON(\n            mappings,\n            localResource,\n            this.server,\n            async(progress, actionDone) => {\n              await this.progressCallback(progress, actionDone)\n            },\n            continuation\n          )\n        } catch (e) {\n          continuation = null\n          Logger.log('Failed to load pending continuation. Continuing with normal sync')\n        }\n      }\n\n      if (typeof continuation === 'undefined' || continuation === null || (typeof strategy !== 'undefined' && continuation.strategy !== strategy) || Date.now() - continuation.createdAt > 1000 * 60 * 30) {\n        // If there is no pending continuation, we just sync normally\n        // Same if the pending continuation was overridden by a different strategy\n        // same if the continuation is older than half an hour. We don't want old zombie continuations\n\n        let strategyClass: typeof DefaultSyncProcess|typeof MergeSyncProcess|typeof UnidirectionalSyncProcess, direction: TItemLocation\n        switch (strategy || this.getData().strategy) {\n          case 'slave':\n            Logger.log('Using \"merge slave\" strategy (no cache available)')\n            strategyClass = UnidirectionalSyncProcess\n            direction = ItemLocation.LOCAL\n            break\n          case 'overwrite':\n            Logger.log('Using \"merge overwrite\" strategy (no cache available)')\n            strategyClass = UnidirectionalSyncProcess\n            direction = ItemLocation.SERVER\n            break\n          default:\n            if (!cacheTree.children.length) {\n              Logger.log('Using \"merge default\" strategy (no cache available)')\n              strategyClass = MergeSyncProcess\n            } else {\n              Logger.log('Using \"default\" strategy')\n              strategyClass = DefaultSyncProcess\n            }\n            break\n        }\n\n        this.syncProcess = new strategyClass(\n          mappings,\n          localResource,\n          this.server,\n          async(progress, actionsDone?) => {\n            await this.progressCallback(progress, actionsDone)\n          }\n        )\n        this.syncProcess.setCacheTree(cacheTree)\n        if (direction) {\n          this.syncProcess.setDirection(direction)\n        }\n        await this.syncProcess.sync()\n      } else {\n        // if there is a pending continuation, we resume it\n\n        Logger.log('Found existing persisted pending continuation. Resuming last sync')\n        await this.syncProcess.sync()\n      }\n\n      await this.setData({ scheduled: false, syncing: 1 })\n\n      // update cache\n      const cache = (await localResource.getBookmarksTree()).clone(false)\n      this.syncProcess.filterOutUnacceptedBookmarks(cache)\n      this.syncProcess.filterOutUnmappedItems(cache, await mappings.getSnapshot())\n      await this.storage.setCache(cache)\n\n      if (this.server.onSyncComplete) {\n        await this.server.onSyncComplete()\n      }\n\n      if (mappings) {\n        await mappings.persist()\n      }\n\n      this.syncing = false\n\n      await this.storage.setCurrentContinuation(null)\n      await this.setData({\n        error: null,\n        errorCount: 0,\n        syncing: false,\n        scheduled: false,\n        lastSync: Date.now(),\n      })\n\n      Logger.log(\n        'Successfully ended sync process for account ' + this.getLabel()\n      )\n    } catch (e) {\n      console.log(e)\n      const message = await Account.stringifyError(e)\n      console.error('Syncing failed with', message)\n      Logger.log('Syncing failed with', message)\n      Sentry.setContext('accountData', {\n        ...this.getData(),\n        username: 'SENSITIVEVALUEHIDDEN',\n        password: 'SENSITIVEVALUVALUEHIDDEN',\n        passphrase: 'SENSITIVEVALUVALUEHIDDEN'\n      })\n      if (e.list) {\n        Sentry.captureException(message)\n      } else {\n        Sentry.captureException(e)\n      }\n\n      await this.setData({\n        error: message,\n        errorCount: this.getData().errorCount + 1,\n        syncing: false,\n        scheduled: false,\n      })\n      if (matchAllErrors(e, e => e.code !== 27 && (!isTest || e.code !== 26))) {\n        await this.storage.setCurrentContinuation(null)\n      }\n      this.syncing = false\n      if (this.server.onSyncFail) {\n        await this.server.onSyncFail()\n      }\n\n      // reset cache and mappings after error\n      // (but not after interruption or NetworkError)\n      if (matchAllErrors(e, e => e.code !== 27 && e.code !== 17 && (!isTest || e.code !== 26))) {\n        await this.init()\n      }\n    }\n    await Logger.persist()\n  }\n\n  static async stringifyError(er:any):Promise<string> {\n    return (await this.getAccountClass()).stringifyError(er)\n  }\n\n  async cancelSync():Promise<void> {\n    if (!this.syncing) return\n    this.server.cancel()\n    if (this.syncProcess) {\n      await this.syncProcess.cancel()\n    }\n  }\n\n  private async progressCallback(progress: number, actionsDone: number) {\n    if (!this.syncing) {\n      return\n    }\n    await this.setData({ syncing: progress })\n    if (!this.syncProcess) {\n      return\n    }\n    if (actionsDone && (!(this.server instanceof CachingAdapter) || !('onSyncComplete' in this.server))) {\n      await this.storage.setCurrentContinuation(this.syncProcess.toJSON())\n      await this.syncProcess.getMappingsInstance().persist()\n    }\n  }\n\n  static async getAllAccounts():Promise<Account[]> {\n    return (await this.getAccountClass()).getAllAccounts()\n  }\n\n  static async getAccountsContainingLocalId(localId:string, ancestors:string[], allAccounts:Account[]):Promise<Account[]> {\n    return (await this.getAccountClass()).getAccountsContainingLocalId(localId, ancestors, allAccounts)\n  }\n}\n\nfunction matchAllErrors(e, fn:(e)=>boolean) {\n  return fn(e) && e.list && e.list.every(e => matchAllErrors(e, fn))\n}\n","export default class Crypto {\n  static async sha256(message) {\n    const msgBuffer = new TextEncoder('utf-8').encode(message) // encode as UTF-8\n    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer) // hash the message\n    const hashHex = this.bufferToHexstr(hashBuffer) // convert bytes to hex string\n    return hashHex\n  }\n\n  static bufferToHexstr(buffer) {\n    return Array.from(new Uint8Array(buffer))\n      .map(b => ('00' + b.toString(16)).slice(-2))\n      .join('') // convert bytes to hex string\n  }\n\n  static hexstrToBuffer(hex) {\n    for (\n      var bytes = new Uint8Array(hex.length / 2), c = 0;\n      c < hex.length;\n      c += 2\n    ) {\n      bytes[c / 2] = parseInt(hex.substr(c, 2), 16)\n    }\n    return bytes\n  }\n\n  static async prepareKey(key) {\n    const keyBuffer = await crypto.subtle.digest(\n      'SHA-256',\n      new TextEncoder('utf-8').encode(key)\n    ) // hash the key\n    let cryptoKey = await crypto.subtle.importKey(\n      'raw',\n      keyBuffer,\n      { name: 'AES-CBC' },\n      false,\n      ['decrypt', 'encrypt']\n    )\n    return cryptoKey\n  }\n\n  static async decryptAES(key, iv, ciphertext) {\n    return new TextDecoder().decode(\n      await crypto.subtle.decrypt(\n        { name: 'AES-CBC', iv: Uint8Array.from(Crypto.iv) },\n        await this.prepareKey(key),\n        this.hexstrToBuffer(ciphertext)\n      )\n    )\n  }\n\n  static async encryptAES(key, iv, message) {\n    return this.bufferToHexstr(\n      await crypto.subtle.encrypt(\n        { name: 'AES-CBC', iv: Uint8Array.from(Crypto.iv) },\n        await this.prepareKey(key),\n        new TextEncoder().encode(message)\n      )\n    )\n  }\n\n  static getRandomBytes(bytelength) {\n    let rand = new Int8Array(bytelength)\n    crypto.getRandomValues(rand)\n    return rand\n  }\n}\n\n// A default initialization vector for the key hash\nCrypto.iv = [\n  58,\n  14,\n  9,\n  204,\n  174,\n  93,\n  77,\n  98,\n  12,\n  248,\n  11,\n  160,\n  143,\n  24,\n  119,\n  20\n]\n","var map = {\n\t\"./cs/messages.json\": [\n\t\t25974,\n\t\t974\n\t],\n\t\"./de/messages.json\": [\n\t\t72805,\n\t\t805\n\t],\n\t\"./en/messages.json\": [\n\t\t18033\n\t],\n\t\"./es/messages.json\": [\n\t\t77772,\n\t\t772\n\t],\n\t\"./fi/messages.json\": [\n\t\t83283,\n\t\t283\n\t],\n\t\"./fr/messages.json\": [\n\t\t28488,\n\t\t488\n\t],\n\t\"./gl/messages.json\": [\n\t\t17925,\n\t\t925\n\t],\n\t\"./ja/messages.json\": [\n\t\t75591,\n\t\t591\n\t],\n\t\"./ko_KR/messages.json\": [\n\t\t89080,\n\t\t80\n\t],\n\t\"./nl_NL/messages.json\": [\n\t\t50165,\n\t\t165\n\t],\n\t\"./pl/messages.json\": [\n\t\t81024,\n\t\t24\n\t],\n\t\"./pt/messages.json\": [\n\t\t12120,\n\t\t120\n\t],\n\t\"./pt_BR/messages.json\": [\n\t\t88193,\n\t\t193\n\t],\n\t\"./ru/messages.json\": [\n\t\t18995,\n\t\t995\n\t],\n\t\"./sv/messages.json\": [\n\t\t50787,\n\t\t787\n\t],\n\t\"./tr/messages.json\": [\n\t\t1562,\n\t\t562\n\t],\n\t\"./tr_TR/messages.json\": [\n\t\t25457,\n\t\t457\n\t],\n\t\"./zh/messages.json\": [\n\t\t48214,\n\t\t214\n\t],\n\t\"./zh_CN/messages.json\": [\n\t\t52088,\n\t\t88\n\t],\n\t\"./zh_TW/messages.json\": [\n\t\t64624,\n\t\t624\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = 21509;\nmodule.exports = webpackAsyncContext;","import NativeAccountStorage from './NativeAccountStorage'\nimport NativeTree from './NativeTree'\nimport AdapterFactory from '../AdapterFactory'\nimport Account from '../Account'\nimport { IAccountData } from '../interfaces/AccountStorage'\nimport {\n  CreateBookmarkError,\n  FailsafeError, FloccusError,\n  HttpError,\n  InconsistentBookmarksExistenceError, LockFileError,\n  MissingItemOrderError,\n  ParseResponseError,\n  UnknownFolderItemOrderError, UpdateBookmarkError\n} from '../../errors/Error'\nimport Logger from '../Logger'\nimport { i18n } from './I18n'\n\nexport default class NativeAccount extends Account {\n  static async get(id:string):Promise<Account> {\n    const storage = new NativeAccountStorage(id)\n    const data = await storage.getAccountData(null)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const tree = new NativeTree(storage)\n    await tree.load()\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new NativeAccount(id, storage, await AdapterFactory.factory(data), tree)\n  }\n\n  static async create(data: IAccountData):Promise<Account> {\n    const id = '' + Date.now() + Math.random()\n    const adapter = await AdapterFactory.factory(data)\n    const storage = new NativeAccountStorage(id)\n\n    await storage.setAccountData(data, null)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const tree = new NativeTree(storage)\n    await tree.load()\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new NativeAccount(id, storage, adapter, tree)\n  }\n\n  async init():Promise<void> {\n    console.log('initializing account ' + this.id)\n    await this.storage.initMappings()\n    await this.storage.initCache()\n    const nativeTree = new NativeTree(this.storage)\n    await nativeTree.load()\n    this.localTree = nativeTree\n  }\n\n  async isInitialized():Promise<boolean> {\n    try {\n      return Boolean(NativeAccountStorage.getEntry(`bookmarks[${this.storage.accountId}].mappings`))\n    } catch (e) {\n      console.log('Apparently not initialized, because:', e)\n      return false\n    }\n  }\n\n  async updateFromStorage():Promise<void> {\n    // empty\n  }\n\n  static async stringifyError(er:any):Promise<string> {\n    if (er instanceof UnknownFolderItemOrderError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.item])\n    }\n    if (er instanceof MissingItemOrderError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.item])\n    }\n    if (er instanceof HttpError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.status, er.method])\n    }\n    if (er instanceof ParseResponseError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0')) + '\\n' + er.response\n    }\n    if (er instanceof InconsistentBookmarksExistenceError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.folder, er.bookmark])\n    }\n    if (er instanceof LockFileError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.status, er.lockFile])\n    }\n    if (er instanceof FailsafeError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.percent])\n    }\n    if (er instanceof CreateBookmarkError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.bookmark.inspect()])\n    }\n    if (er instanceof UpdateBookmarkError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.bookmark.inspect()])\n    }\n    if (er instanceof FloccusError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'))\n    }\n    if (er.list) {\n      return (await Promise.all(er.list\n        .map((e) => {\n          Logger.log(e)\n          return this.stringifyError(e)\n        })))\n        .join('\\n')\n    }\n    return er.message\n  }\n\n  static async getAllAccounts():Promise<Account[]> {\n    return Promise.all(\n      (await NativeAccountStorage.getAllAccounts()).map((accountId) =>\n        Account.get(accountId)\n      )\n    )\n  }\n}\n","import CachingAdapter from './Caching'\nimport XbelSerializer from '../serializers/Xbel'\nimport Logger from '../Logger'\nimport { Base64 } from 'js-base64'\n\nimport Crypto from '../Crypto'\nimport {\n  AuthenticationError,\n  DecryptionError, FileUnreadableError,\n  HttpError, CancelledSyncError,\n  LockFileError, MissingPermissionsError,\n  NetworkError, RedirectError, ResourceLockedError,\n  SlashError\n} from '../../errors/Error'\nimport { CapacitorHttp as Http } from '@capacitor/core'\nimport { Capacitor } from '@capacitor/core'\nimport Html from '../serializers/Html'\n\nconst LOCK_INTERVAL = 2 * 60 * 1000 // Lock every 2mins while syncing\nconst LOCK_TIMEOUT = 15 * 60 * 1000 // Override lock 0.25h after last time lock has been set\nexport default class WebDavAdapter extends CachingAdapter {\n  private lockingInterval: any\n  private lockingPromise: Promise<any>\n  private locked: boolean\n  private ended: boolean\n  private abortController: AbortController\n  private abortSignal: AbortSignal\n  private cancelCallback: () => void\n  private initialTreeHash: string\n  constructor(server) {\n    super(server)\n    this.server = server\n    this.locked = false\n    this.ended = true\n    this.lockingInterval = null\n  }\n\n  static getDefaultValues() {\n    return {\n      type: 'webdav',\n      url: 'https://example.org/',\n      username: 'bob',\n      password: 's3cret',\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      includeCredentials: false,\n      allowRedirects: false,\n      passphrase: '',\n      allowNetwork: false,\n    }\n  }\n\n  getData() {\n    return { ...WebDavAdapter.getDefaultValues(), ...this.server }\n  }\n\n  normalizeServerURL(input) {\n    const serverURL = new URL(input)\n    if (!serverURL.pathname) serverURL.pathname = ''\n    serverURL.search = ''\n    serverURL.hash = ''\n    const output = serverURL.toString()\n    return output + (output[output.length - 1] !== '/' ? '/' : '')\n  }\n\n  cancel() {\n    this.abortController.abort()\n    this.cancelCallback && this.cancelCallback()\n  }\n\n  getBookmarkURL() {\n    return this.normalizeServerURL(this.server.url) + this.server.bookmark_file\n  }\n\n  getBookmarkLockURL() {\n    return this.getBookmarkURL() + '.lock'\n  }\n\n  async checkLock() {\n    const fullURL = this.getBookmarkLockURL()\n    Logger.log(fullURL)\n\n    const response = await this.downloadFile(fullURL)\n    return response\n  }\n\n  timeout(ms) {\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, ms)\n      this.cancelCallback = () => reject(new CancelledSyncError())\n    })\n  }\n\n  async obtainLock() {\n    const res = await this.checkLock()\n    if (res.status === 200) {\n      if (res.headers['Last-Modified']) {\n        const date = new Date(res.headers['Last-Modified'])\n        const dateLocked = date.valueOf()\n        if (dateLocked + LOCK_TIMEOUT > Date.now()) {\n          throw new ResourceLockedError()\n        }\n      } else {\n        throw new ResourceLockedError()\n      }\n    }\n\n    if (res.status === 200) {\n      // continue anyway\n      this.locked = true\n    } else if (res.status === 404) {\n      await this.setLock()\n    } else {\n      throw new LockFileError(\n        res.status,\n        this.server.bookmark_file + '.lock'\n      )\n    }\n  }\n\n  async setLock() {\n    const fullURL = this.getBookmarkLockURL()\n    Logger.log('Setting lock: ' + fullURL)\n    this.lockingPromise = this.uploadFile(\n      fullURL,\n      'text/html',\n      '<html><body>I am a lock file</body></html>'\n    )\n    try {\n      await this.lockingPromise\n    } catch (e) {\n      if (e instanceof HttpError && (e.status === 423 || e.status === 409)) {\n        this.locked = false\n        throw new ResourceLockedError()\n      }\n      throw e\n    }\n    this.locked = true\n  }\n\n  async freeLock() {\n    if (this.lockingPromise) {\n      try {\n        await this.lockingPromise\n      } catch (e) {\n        console.warn(e)\n      }\n    }\n    if (!this.locked) {\n      return\n    }\n\n    const fullUrl = this.getBookmarkLockURL()\n\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n\n    let res, lockFreed, i = 0\n    try {\n      do {\n        Logger.log('Freeing lock: ' + fullUrl)\n        if (Capacitor.getPlatform() === 'web') {\n          res = await fetch(fullUrl, {\n            method: 'DELETE',\n            credentials: 'omit',\n            headers: {\n              Authorization: 'Basic ' + authString\n            },\n            signal: this.abortSignal,\n            ...(!this.server.allowRedirects && {redirect: 'manual'}),\n          })\n        } else {\n          res = await Http.request({\n            url: fullUrl,\n            method: 'DELETE',\n            headers: {\n              Authorization: 'Basic ' + authString\n            },\n            webFetchExtra: {\n              credentials: 'omit',\n            }\n          })\n        }\n        lockFreed = res.status === 200 || res.status === 204 || res.status === 404\n        if (!lockFreed) {\n          await this.timeout(1000)\n        }\n        i++\n      } while (!lockFreed && i < 10)\n      return lockFreed\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n    }\n  }\n\n  async pullFromServer() {\n    const fullUrl = this.getBookmarkURL()\n\n    const response = await this.downloadFile(fullUrl)\n\n    if (response.status === 401) {\n      throw new AuthenticationError()\n    }\n\n    if (response.status === 404) {\n      this.resetCache()\n      return response\n    }\n\n    if (response.status === 200) {\n      let xmlDocText = response.data\n\n      if (this.server.passphrase) {\n        try {\n          try {\n            const json = JSON.parse(xmlDocText)\n            xmlDocText = await Crypto.decryptAES(this.server.passphrase, json.ciphertext, json.salt)\n          } catch (e) {\n            xmlDocText = await Crypto.decryptAES(this.server.passphrase, xmlDocText, this.server.bookmark_file)\n          }\n        } catch (e) {\n          if (xmlDocText && (xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>') || xmlDocText.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>'))) {\n            // not encrypted, yet => noop\n          } else {\n            throw new DecryptionError()\n          }\n        }\n      }\n      if (!xmlDocText || (!xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>') && !xmlDocText.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>'))) {\n        throw new FileUnreadableError()\n      }\n\n      /* let's get the highestId */\n      const byNL = xmlDocText.split('\\n')\n      for (const line of byNL) {\n        if (line.indexOf('<!--- highestId :') >= 0) {\n          const idxStart = line.indexOf(':') + 1\n          const idxEnd = line.lastIndexOf(':')\n\n          this.highestId = parseInt(line.substring(idxStart, idxEnd))\n          break\n        }\n      }\n\n      switch (this.server.bookmark_file_type) {\n        case 'xbel':\n          if (!xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')) {\n            throw new FileUnreadableError()\n          }\n          this.bookmarksCache = XbelSerializer.deserialize(xmlDocText)\n          break\n        case 'html':\n          if (!xmlDocText.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>')) {\n            throw new FileUnreadableError()\n          }\n          this.bookmarksCache = Html.deserialize(xmlDocText)\n          break\n        default:\n          throw new Error('Invalid bookmark file type')\n      }\n    }\n\n    return response\n  }\n\n  async onSyncStart(needLock = true, forceLock = false) {\n    Logger.log('onSyncStart: begin')\n    this.ended = false\n\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../browser-api')).default\n      let hasPermissions, error = false\n      try {\n        hasPermissions = await browser.permissions.contains({ origins: [this.server.url + '/'] })\n      } catch (e) {\n        error = true\n        console.warn(e)\n      }\n      if (!error && !hasPermissions) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    if (this.server.bookmark_file[0] === '/') {\n      throw new SlashError()\n    }\n\n    this.abortController = new AbortController()\n    this.abortSignal = this.abortController.signal\n\n    if (forceLock) {\n      await this.setLock()\n    } else if (needLock) {\n      await this.obtainLock()\n    }\n\n    const resp = await this.pullFromServer()\n\n    if (resp.status !== 200) {\n      if (resp.status !== 404) {\n        throw new HttpError(resp.status, 'GET')\n      }\n    }\n\n    this.initialTreeHash = await this.bookmarksCache.hash(true)\n\n    Logger.log('onSyncStart: completed')\n\n    if (this.lockingInterval) {\n      clearInterval(this.lockingInterval)\n    }\n    if (needLock || forceLock) {\n      this.lockingInterval = setInterval(() => !this.ended && this.setLock(), LOCK_INTERVAL) // Set lock every minute\n    }\n\n    if (resp.status === 404) {\n      // Notify sync process that we need to reset cache\n      return false\n    }\n  }\n\n  async onSyncFail() {\n    Logger.log('onSyncFail')\n    this.ended = true\n    clearInterval(this.lockingInterval)\n    await this.freeLock()\n  }\n\n  async onSyncComplete() {\n    Logger.log('onSyncComplete')\n    this.ended = true\n    clearInterval(this.lockingInterval)\n\n    this.bookmarksCache = this.bookmarksCache.clone()\n    const newTreeHash = await this.bookmarksCache.hash(true)\n    if (newTreeHash !== this.initialTreeHash) {\n      const fullUrl = this.getBookmarkURL()\n      let xbel = this.server.bookmark_file_type === 'xbel' ? createXBEL(this.bookmarksCache, this.highestId) : createHTML(this.bookmarksCache, this.highestId)\n      if (this.server.passphrase) {\n        const salt = Crypto.bufferToHexstr(Crypto.getRandomBytes(64))\n        const ciphertext = await Crypto.encryptAES(this.server.passphrase, xbel, salt)\n        xbel = JSON.stringify({ciphertext, salt})\n      }\n      await this.uploadFile(fullUrl, this.server.bookmark_file_type === 'xbel' ? 'application/xml' : 'text/html', xbel)\n    } else {\n      Logger.log('No changes to the server version necessary')\n    }\n\n    await this.freeLock()\n  }\n\n  async uploadFile(url, content_type, data) {\n    if (Capacitor.getPlatform() === 'web') {\n      return this.uploadFileWeb(url, content_type, data)\n    } else {\n      return this.uploadFileNative(url, content_type, data)\n    }\n  }\n\n  async uploadFileWeb(url, content_type, data) {\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n    let res\n    try {\n      res = await fetch(url,{\n        method: 'PUT',\n        headers: {\n          'Content-Type': content_type,\n          Authorization: 'Basic ' + authString\n        },\n        credentials: 'omit',\n        signal: this.abortSignal,\n        ...(!this.server.allowRedirects && {redirect: 'manual'}),\n        body: data,\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      if (this.abortSignal.aborted) throw new CancelledSyncError()\n      throw new NetworkError()\n    }\n    if (res.status === 0 && !this.server.allowRedirects) {\n      throw new RedirectError()\n    }\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status >= 300) {\n      throw new HttpError(res.status, 'PUT')\n    }\n  }\n\n  async uploadFileNative(url, content_type, data) {\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n    let res\n    try {\n      res = await Http.request({\n        url,\n        method: 'PUT',\n        headers: {\n          'Content-Type': content_type,\n          Authorization: 'Basic ' + authString\n        },\n        data\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      throw new NetworkError()\n    }\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status >= 300) {\n      throw new HttpError(res.status, 'PUT')\n    }\n  }\n\n  async downloadFile(url) {\n    if (Capacitor.getPlatform() === 'web') {\n      return this.downloadFileWeb(url)\n    } else {\n      return this.downloadFileNative(url)\n    }\n  }\n\n  async downloadFileWeb(url) {\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n    let res\n    try {\n      res = await fetch(url,{\n        method: 'GET',\n        headers: {\n          Authorization: 'Basic ' + authString\n        },\n        cache: 'no-store',\n        credentials: 'omit',\n        signal: this.abortSignal,\n        ...(!this.server.allowRedirects && {redirect: 'manual'})\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      if (this.abortSignal.aborted) throw new CancelledSyncError()\n      throw new NetworkError()\n    }\n    if (res.status === 0 && !this.server.allowRedirects) {\n      throw new RedirectError()\n    }\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status >= 300 && res.status !== 404) {\n      throw new HttpError(res.status, 'GET')\n    }\n\n    return { status: res.status, data: await res.text(), headers: res.headers }\n  }\n\n  async downloadFileNative(fullURL) {\n    let res\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n\n    try {\n      res = await Http.request({\n        url: fullURL,\n        method: 'GET',\n        headers: {\n          Authorization: 'Basic ' + authString,\n          Pragma: 'no-cache',\n          'Cache-Control': 'no-cache'\n        },\n        responseType: 'text'\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      throw new NetworkError()\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status >= 300 && res.status !== 404) {\n      throw new HttpError(res.status, 'GET')\n    }\n\n    return res\n  }\n}\n\nfunction createXBEL(rootFolder, highestId) {\n  let output = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\" \"http://pyxml.sourceforge.net/topics/dtds/xbel.dtd\">\n<xbel version=\"1.0\">\n`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += XbelSerializer.serialize(rootFolder)\n\n  output += `\n</xbel>`\n\n  return output\n}\n\nfunction createHTML(rootFolder, highestId) {\n  let output = `<!DOCTYPE NETSCAPE-Bookmark-file-1>\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=UTF-8\">\n<TITLE>Bookmarks</TITLE>`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += Html.serialize(rootFolder)\n\n  output += '</html>'\n\n  return output\n}\n","import BrowserAccountStorage from './BrowserAccountStorage'\nimport BrowserTree from './BrowserTree'\nimport browser from '../browser-api'\nimport AdapterFactory from '../AdapterFactory'\nimport Account from '../Account'\nimport {\n  CreateBookmarkError,\n  FailsafeError, FloccusError,\n  HttpError,\n  InconsistentBookmarksExistenceError, LockFileError,\n  MissingItemOrderError,\n  ParseResponseError,\n  UnknownFolderItemOrderError, UpdateBookmarkError\n} from '../../errors/Error'\nimport {i18n} from '../native/I18n'\nimport { OrderFolderResource } from '../interfaces/Resource'\nimport { ItemLocation } from '../Tree'\n\nexport default class BrowserAccount extends Account {\n  static async get(id:string):Promise<Account> {\n    const storage = new BrowserAccountStorage(id)\n    const data = await storage.getAccountData(null)\n    const tree = new BrowserTree(storage, data.localRoot)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new BrowserAccount(id, storage, await AdapterFactory.factory(data), tree)\n  }\n\n  static async create(data):Promise<Account> {\n    const id = '' + Date.now() + Math.random()\n    const adapter = await AdapterFactory.factory(data)\n    const storage = new BrowserAccountStorage(id)\n\n    await storage.setAccountData(data, null)\n    const tree = new BrowserTree(storage, data.localRoot)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new BrowserAccount(id, storage, adapter, tree)\n  }\n\n  async init():Promise<void> {\n    console.log('initializing account ' + this.id)\n    const accData = this.getData()\n    if (!(await this.isInitialized()) && accData.localRoot !== 'tabs') {\n      const parentNode = await browser.bookmarks.getTree()\n      const bookmarksBar = parentNode[0].children[0]\n      const node = await browser.bookmarks.create({\n        title: 'Floccus (' + this.getLabel() + ')',\n        parentId: bookmarksBar.id,\n      })\n      accData.localRoot = node.id\n      accData.rootPath = await BrowserTree.getPathFromLocalId(node.id)\n      await this.setData(accData)\n    }\n    await this.storage.initMappings()\n    await this.storage.initCache()\n    this.localTree = new BrowserTree(this.storage, accData.localRoot)\n  }\n\n  async isInitialized():Promise<boolean> {\n    try {\n      const localRoot = this.getData().localRoot\n      if (localRoot === 'tabs') {\n        return true\n      }\n      await browser.bookmarks.getSubTree(localRoot)\n      return true\n    } catch (e) {\n      console.log('Apparently not initialized, because:', e)\n      return false\n    }\n  }\n\n  async getResource():Promise<OrderFolderResource<typeof ItemLocation.LOCAL>> {\n    if (this.getData().localRoot !== 'tabs') {\n      return this.localTree\n    } else {\n      const LocalTabs = (await import('../LocalTabs')).default\n      this.localTabs = new LocalTabs(this.storage)\n      return this.localTabs\n    }\n  }\n\n  async updateFromStorage():Promise<void> {\n    const data = await this.storage.getAccountData(null)\n    this.server.setData(data)\n    this.localTree = new BrowserTree(this.storage, data.localRoot)\n  }\n\n  static async stringifyError(er:any):Promise<string> {\n    if (er instanceof UnknownFolderItemOrderError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.item])\n    }\n    if (er instanceof MissingItemOrderError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.item])\n    }\n    if (er instanceof HttpError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.status, er.method])\n    }\n    if (er instanceof ParseResponseError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0')) + '\\n' + er.response\n    }\n    if (er instanceof InconsistentBookmarksExistenceError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.folder, er.bookmark])\n    }\n    if (er instanceof LockFileError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.status, er.lockFile])\n    }\n    if (er instanceof FailsafeError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.percent])\n    }\n    if (er instanceof CreateBookmarkError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.bookmark.inspect()])\n    }\n    if (er instanceof UpdateBookmarkError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.bookmark.inspect()])\n    }\n    if (er instanceof FloccusError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'))\n    }\n    if (er.list) {\n      if (er.list[0].code === 26) {\n        // Do not spam log with E026 (cancelled sync)\n        return this.stringifyError(er.list[0])\n      }\n      return (await Promise.all(er.list\n        .map((e) => {\n          return this.stringifyError(e)\n        })))\n        .join('\\n')\n    }\n    return er.message\n  }\n\n  static async getAllAccounts():Promise<Account[]> {\n    return Promise.all(\n      (await BrowserAccountStorage.getAllAccounts()).map((accountId) =>\n        Account.get(accountId)\n      )\n    )\n  }\n\n  static async getAccountsContainingLocalId(localId:string, ancestors:string[], allAccounts:Account[], withDisallowNested = false):Promise<Account[]> {\n    ancestors = ancestors || (await BrowserTree.getIdPathFromLocalId(localId))\n    allAccounts = allAccounts || (await this.getAllAccounts())\n\n    const accountsInvolved = allAccounts\n      .filter(acc => ancestors.includes(acc.getData().localRoot))\n      .sort((a, b) =>\n        ancestors.indexOf(a.getData().localRoot) - ancestors.indexOf(b.getData().localRoot)\n      )\n      .reverse()\n\n    if (!withDisallowNested) {\n      const lastNesterIdx = accountsInvolved.findIndex(acc => !acc.getData().nestedSync)\n      return accountsInvolved.slice(0, Math.max(1, lastNesterIdx))\n    } else {\n      return accountsInvolved\n    }\n  }\n}\n","/* global DEBUG */\nimport util from 'util'\nimport * as Parallel from 'async-parallel'\nimport packageJson from '../../package.json'\nimport Crypto from './Crypto'\nimport { Share } from '@capacitor/share'\nimport { Filesystem, Directory, Encoding } from '@capacitor/filesystem'\nimport { Capacitor } from '@capacitor/core'\n\nexport default class Logger {\n  static log() {\n    const logMsg = [new Date().toISOString(), ...arguments]\n\n    // log to console\n    DEBUG && console.log(util.format.apply(util, logMsg))\n    this.messages.push(util.format.apply(util, logMsg)) // TODO: Use a linked list here to get O(n)\n  }\n\n  static async persist() {\n    const Storage = (Capacitor.getPlatform() === 'web') ? await import('./browser/BrowserAccountStorage') : await import('./native/NativeAccountStorage')\n    await Storage.default.changeEntry(\n      'logs',\n      log => {\n        const messages = this.messages\n        this.messages = []\n        return messages // only save the last sync run\n      },\n      []\n    )\n  }\n\n  static async getLogs() {\n    const Storage = (Capacitor.getPlatform() === 'web') ? await import('./browser/BrowserAccountStorage') : await import('./native/NativeAccountStorage')\n    return Storage.default.getEntry('logs', [])\n  }\n\n  static async anonymizeLogs(logs) {\n    const regex = /\\[(.*?)\\]\\((.*?)\\)|\\[(.*?)\\]/g\n    const newLogs = await Parallel.map(logs, async(entry) => {\n      return Logger.replaceAsync(entry, regex, async(match, p1, p2, p3) => {\n        if (p1 && p2) {\n          const hash1 = await Crypto.sha256(p1)\n          const hash2 = await Crypto.sha256(p2)\n          return '[' + hash1 + ']' + '(' + hash2 + ')'\n        } else if (p3) {\n          const hash = await Crypto.sha256(p3)\n          return '[' + hash + ']'\n        }\n      })\n    }, 1)\n    const regex2 = /url=https?%3A%2F%2F.*$|url=https?%3A%2F%2F[^ ]*/\n    const regex3 = /https?:\\/\\/[^ /]*\\//\n    return newLogs\n      .map(line => line.replace(regex2, '###url###').replace(regex3, '###server###'))\n  }\n\n  static async replaceAsync(str, regex, asyncFn) {\n    // Stolen from https://stackoverflow.com/questions/33631041/javascript-async-await-in-replace\n    const promises = []\n    str.replace(regex, (match, ...args) => {\n      const promise = asyncFn(match, ...args)\n      promises.push(promise)\n    })\n    let data\n    try {\n      data = await Promise.all(promises)\n    } catch (e) {\n      console.error(e)\n    }\n    return str.replace(regex, () => data.shift())\n  }\n\n  static async downloadLogs(anonymous = false) {\n    let logs = await this.getLogs()\n    if (anonymous) {\n      logs = await Logger.anonymizeLogs(logs)\n    }\n    let blob = new Blob([logs.join('\\n')], {\n      type: 'text/plain',\n      endings: 'native'\n    })\n    this.download(\n      'floccus-' +\n        packageJson.version +\n        '-' +\n        new Date().toISOString().slice(0, 10) +\n        '-' +\n        (anonymous ? 'redacted' : 'full') +\n        '.log',\n      blob\n    )\n  }\n\n  static async download(filename, blob) {\n    if (Capacitor.getPlatform() === 'web') {\n      const element = document.createElement('a')\n\n      let objectUrl = URL.createObjectURL(blob)\n      element.setAttribute('href', objectUrl)\n      element.setAttribute('download', filename)\n\n      element.style.display = 'none'\n      document.body.appendChild(element)\n\n      element.click()\n\n      URL.revokeObjectURL(objectUrl)\n      document.body.removeChild(element)\n    } else {\n      const {uri: fileURI} = await Filesystem.writeFile({\n        path: 'Downloads/' + filename,\n        data: await blob.text(),\n        encoding: Encoding.UTF8,\n        directory: Directory.External,\n        recursive: true\n      })\n      await Share.share({\n        title: filename,\n        files: [fileURI],\n      })\n    }\n  }\n}\nLogger.messages = []\n","export const isVivaldi = async() => {\n  const {default: browser} = await import('../browser-api.js')\n  const tabs = await browser.tabs.query({ active: true, currentWindow: true })\n  return Boolean(tabs?.[0]?.['vivExtData'])\n}\n","import { Preferences as Storage } from '@capacitor/preferences'\nimport { Bookmark, Folder, ItemLocation, TItemLocation } from '../Tree'\nimport Ordering from '../interfaces/Ordering'\nimport CachingAdapter from '../adapters/Caching'\nimport IAccountStorage from '../interfaces/AccountStorage'\nimport { BulkImportResource } from '../interfaces/Resource'\n\nexport default class NativeTree extends CachingAdapter implements BulkImportResource<typeof ItemLocation.LOCAL> {\n  protected location: TItemLocation = ItemLocation.LOCAL\n\n  private storage: IAccountStorage\n  private readonly accountId: string\n  private saveTimeout: any\n\n  constructor(storage:IAccountStorage) {\n    super({})\n    this.storage = storage\n    this.accountId = this.storage.accountId\n  }\n\n  async load():Promise<boolean> {\n    const {value: tree} = await Storage.get({key: `bookmarks[${this.accountId}].tree`})\n    const {value: highestId} = await Storage.get({key: `bookmarks[${this.accountId}].highestId`})\n    if (tree) {\n      const oldHash = this.bookmarksCache && await this.bookmarksCache.cloneWithLocation(false, this.location).hash(true)\n      this.bookmarksCache = Folder.hydrate(JSON.parse(tree)).clone(false)\n      const newHash = await this.bookmarksCache.hash(true)\n      this.highestId = parseInt(highestId)\n      return oldHash && oldHash !== newHash\n    } else {\n      await this.save()\n      return false\n    }\n  }\n\n  async save():Promise<void> {\n    await Storage.set({key: `bookmarks[${this.accountId}].tree`, value: JSON.stringify(this.bookmarksCache.cloneWithLocation(true, ItemLocation.LOCAL))})\n    await Storage.set({key: `bookmarks[${this.accountId}].highestId`, value: this.highestId + ''})\n  }\n\n  triggerSave():void {\n    clearTimeout(this.saveTimeout)\n    this.saveTimeout = setTimeout(() => {\n      this.save()\n    }, 500)\n  }\n\n  async getBookmarksTree(): Promise<Folder<typeof ItemLocation.LOCAL>> {\n    const tree = await super.getBookmarksTree()\n    tree.createIndex()\n    return tree as Folder<typeof ItemLocation.LOCAL>\n  }\n\n  async createBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<string|number> {\n    this.triggerSave()\n    return super.createBookmark(bookmark)\n  }\n\n  async updateBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>):Promise<void> {\n    this.triggerSave()\n    return super.updateBookmark(bookmark)\n  }\n\n  async removeBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<void> {\n    this.triggerSave()\n    return super.removeBookmark(bookmark)\n  }\n\n  async createFolder(folder:Folder<typeof ItemLocation.LOCAL>): Promise<string|number> {\n    this.triggerSave()\n    return super.createFolder(folder)\n  }\n\n  async orderFolder(id:string|number, order:Ordering<typeof ItemLocation.LOCAL>) :Promise<void> {\n    this.triggerSave()\n    return super.orderFolder(id, order)\n  }\n\n  async updateFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    this.triggerSave()\n    return super.updateFolder(folder)\n  }\n\n  async removeFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    this.triggerSave()\n    return super.removeFolder(folder)\n  }\n\n  async bulkImportFolder(id: number|string, folder:Folder<typeof ItemLocation.LOCAL>):Promise<Folder<typeof ItemLocation.LOCAL>> {\n    await Promise.all(folder.children.map(async child => {\n      child.parentId = id\n      if (child instanceof Bookmark) {\n        await super.createBookmark(child)\n      }\n      if (child instanceof Folder) {\n        const folderId = await super.createFolder(child)\n        await this.bulkImportFolder(folderId, child)\n      }\n    }))\n    return this.bookmarksCache.findFolder(id) as Folder<typeof ItemLocation.LOCAL>\n  }\n\n  isAvailable(): Promise<boolean> {\n    return Promise.resolve(true)\n  }\n}\n","import CachingAdapter from './Caching'\nimport Logger from '../Logger'\nimport XbelSerializer from '../serializers/Xbel'\nimport Crypto from '../Crypto'\nimport Credentials from '../../../google-api.credentials.json'\nimport {\n  AuthenticationError,\n  DecryptionError, FileUnreadableError,\n  GoogleDriveAuthenticationError, HttpError, CancelledSyncError, MissingPermissionsError,\n  NetworkError,\n  OAuthTokenError, ResourceLockedError, GoogleDriveSearchError\n} from '../../errors/Error'\nimport { OAuth2Client } from '@byteowls/capacitor-oauth2'\nimport { Capacitor, CapacitorHttp as Http } from '@capacitor/core'\n\nconst OAuthConfig = {\n  authorizationBaseUrl: 'https://accounts.google.com/o/oauth2/auth',\n  accessTokenEndpoint: 'https://oauth2.googleapis.com/token',\n  scope: 'https://www.googleapis.com/auth/drive.file',\n  resourceUrl: 'https://www.googleapis.com/drive/v3/about?fields=user/displayName',\n  logsEnabled: true,\n  android: {\n    appId: Credentials.android.client_id,\n    responseType: 'code', // if you configured a android app in google dev console the value must be \"code\"\n    redirectUrl: 'org.handmadeideas.floccus:/' // package name from google dev console\n  },\n  ios: {\n    appId: Credentials.ios.client_id,\n    responseType: 'code',\n    redirectUrl: 'org.handmadeideas.floccus:/'\n  }\n}\n\ninterface CustomResponse {\n  status: number,\n  json(): Promise<any>,\n  text(): Promise<string>,\n}\n\ndeclare const chrome: any\n\nconst LOCK_INTERVAL = 2 * 60 * 1000 // Lock every two minutes while syncing\nconst LOCK_TIMEOUT = 15 * 60 * 1000 // Override lock 15min after last time it was set\nexport default class GoogleDriveAdapter extends CachingAdapter {\n  static SCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly']\n\n  private initialTreeHash: string\n  private fileId: string\n  private accessToken: string\n  private cancelCallback: () => void = null\n  private alwaysUpload = false\n  private lockingInterval: any\n  private locked = false\n  private lockingPromise: Promise<CustomResponse>\n\n  constructor(server) {\n    super(server)\n    this.server = server\n  }\n\n  static async authorize(interactive = true) {\n    const platform = Capacitor.getPlatform()\n\n    if (platform !== 'web') {\n      const result = await OAuth2Client.authenticate(OAuthConfig)\n      const refresh_token = result.access_token_response.refresh_token\n      const username = result.user.displayName\n      return { refresh_token, username }\n    }\n\n    if (platform === 'web') {\n      const browser = (await import('../browser-api')).default\n      const origins = ['https://oauth2.googleapis.com/', 'https://www.googleapis.com/']\n      if (!(await browser.permissions.contains({ origins }))) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    // see https://developers.google.com/identity/protocols/oauth2/native-app\n    const challenge = Crypto.bufferToHexstr(await Crypto.getRandomBytes(128)).substr(0, 128)\n    const state = Crypto.bufferToHexstr(await Crypto.getRandomBytes(128)).substr(0, 64)\n    const redirectURL = chrome.identity.getRedirectURL()\n    const scopes = ['https://www.googleapis.com/auth/drive.file']\n    let authURL = 'https://accounts.google.com/o/oauth2/auth'\n    authURL += `?client_id=${Credentials.web.client_id}`\n    authURL += `&response_type=code`\n    authURL += `&redirect_uri=${encodeURIComponent(redirectURL)}`\n    authURL += `&scope=${encodeURIComponent(scopes.join(' '))}`\n    authURL += `&approval_prompt=force&access_type=offline`\n    authURL += `&code_challenge=${challenge}`\n    authURL += `&state=${state}`\n\n    const browser = (await import('../browser-api')).default\n\n    const redirectResult = await browser.identity.launchWebAuthFlow({\n      interactive,\n      url: authURL\n    })\n\n    const m = redirectResult.match(/[#?](.*)/)\n    if (!m || m.length < 1)\n      return null\n    const params = new URLSearchParams(m[1].split('#')[0])\n    const code = params.get('code')\n    const resState = params.get('state')\n\n    if (!code) {\n      throw new Error('Authorization failure')\n    }\n    if (resState !== state) {\n      throw new Error('Authorization failure: State param does not match')\n    }\n    const response = await fetch('https://oauth2.googleapis.com/token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body: `code=${code}` +\n        `&client_id=${Credentials.web.client_id}` +\n        `&client_secret=${Credentials.web.client_secret}` +\n        `&redirect_uri=${encodeURIComponent(chrome.identity.getRedirectURL())}` +\n        `&code_verifier=${challenge}` +\n        '&grant_type=authorization_code'\n    })\n\n    if (response.status !== 200) {\n      Logger.log('Failed to retrieve refresh token from Google API: ' + await response.text())\n      throw new OAuthTokenError()\n    }\n    const json = await response.json()\n    if (!json.access_token || !json.refresh_token) {\n      Logger.log('Failed to retrieve refresh token from Google API: ' + JSON.stringify(json))\n      throw new OAuthTokenError()\n    }\n\n    const res = await fetch('https://www.googleapis.com/drive/v3/about?fields=user/displayName', {\n      headers: {\n        Authorization: 'Bearer ' + json.access_token\n      }\n    })\n    const about = await res.json()\n\n    return { refresh_token: json.refresh_token, username: about.user.displayName }\n  }\n\n  async getAccessToken(refreshToken:string) {\n    const platform = Capacitor.getPlatform()\n\n    const response = await this.request('POST', 'https://oauth2.googleapis.com/token',\n      {\n        refresh_token: refreshToken,\n        client_id: Credentials[platform].client_id,\n        ...(platform === 'web' && {client_secret: Credentials.web.client_secret}),\n        grant_type: 'refresh_token',\n      },\n      'application/x-www-form-urlencoded'\n    )\n\n    if (response.status !== 200) {\n      Logger.log('Failed to retrieve access token from Google API: ' + await response.text())\n      throw new GoogleDriveAuthenticationError()\n    }\n\n    const json = await response.json()\n    if (json.access_token) {\n      return json.access_token\n    } else {\n      throw new OAuthTokenError()\n    }\n  }\n\n  getLabel():string {\n    return this.server.label || 'Google Drive: ' + this.server.bookmark_file\n  }\n\n  static getDefaultValues() {\n    return {\n      type: 'google-drive',\n      username: '',\n      password: '',\n      refreshToken: null,\n      bookmark_file: 'bookmarks.xbel',\n      allowNetwork: false,\n    }\n  }\n\n  getUrl() :string {\n    return 'https://www.googleapis.com/drive/v3'\n  }\n\n  timeout(ms) {\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, ms)\n      this.cancelCallback = () => reject(new CancelledSyncError())\n    })\n  }\n\n  async onSyncStart(needLock = true, forceLock = false) {\n    Logger.log('onSyncStart: begin')\n\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../browser-api')).default\n      const origins = ['https://oauth2.googleapis.com/', 'https://www.googleapis.com/']\n      let hasPermissions, error = false\n      try {\n        hasPermissions = await browser.permissions.contains({ origins })\n      } catch (e) {\n        error = true\n        console.warn(e)\n      }\n      if (!error && !hasPermissions) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    this.accessToken = await this.getAccessToken(this.server.refreshToken)\n\n    const fileList = await this.listFiles(`name = '${this.server.bookmark_file}'`, 100)\n    if (!fileList.files) {\n      throw new GoogleDriveSearchError()\n    }\n\n    const file = fileList.files.filter(file => !file.trashed)[0]\n\n    const filesToDelete = fileList.files.filter(file => !file.trashed).slice(1)\n    for (const fileToDelete of filesToDelete) {\n      try {\n        await this.deleteFile(fileToDelete.id)\n      } catch (e) {\n        Logger.log('Failed to delete superfluous file: ' + e.message)\n      }\n    }\n\n    if (file) {\n      this.fileId = file.id\n      if (forceLock) {\n        this.locked = await this.setLock(this.fileId)\n      } else if (needLock) {\n        const data = await this.getFileMetadata(file.id, 'appProperties')\n        if (data.appProperties && data.appProperties.locked && (data.appProperties.locked === true || JSON.parse(data.appProperties.locked))) {\n          const lockedDate = JSON.parse(data.appProperties.locked)\n          if (!Number.isInteger(lockedDate)) {\n            throw new ResourceLockedError()\n          }\n          if (Date.now() - lockedDate < LOCK_TIMEOUT) {\n            throw new ResourceLockedError()\n          }\n        }\n        this.locked = await this.setLock(this.fileId)\n      }\n\n      let xmlDocText = await this.downloadFile(this.fileId)\n\n      if (this.server.password) {\n        try {\n          try {\n            const json = JSON.parse(xmlDocText)\n            xmlDocText = await Crypto.decryptAES(this.server.password, json.ciphertext, json.salt)\n          } catch (e) {\n            xmlDocText = await Crypto.decryptAES(this.server.password, xmlDocText, this.server.bookmark_file)\n          }\n        } catch (e) {\n          if (xmlDocText && xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')) {\n            // not encrypted, yet => noop\n            this.alwaysUpload = true\n          } else {\n            throw new DecryptionError()\n          }\n        }\n      }\n      if (!xmlDocText || !xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')) {\n        throw new FileUnreadableError()\n      }\n\n      /* let's get the highestId */\n      const byNL = xmlDocText.split('\\n')\n      for (const line of byNL) {\n        if (line.indexOf('<!--- highestId :') >= 0) {\n          const idxStart = line.indexOf(':') + 1\n          const idxEnd = line.lastIndexOf(':')\n\n          this.highestId = parseInt(line.substring(idxStart, idxEnd))\n          break\n        }\n      }\n\n      this.bookmarksCache = XbelSerializer.deserialize(xmlDocText)\n      if (this.lockingInterval) {\n        clearInterval(this.lockingInterval)\n      }\n      if (needLock || forceLock) {\n        this.lockingInterval = setInterval(() => this.setLock(this.fileId), LOCK_INTERVAL) // Set lock every minute\n      }\n    } else {\n      this.resetCache()\n      this.alwaysUpload = true\n    }\n\n    this.initialTreeHash = await this.bookmarksCache.hash(true)\n\n    Logger.log('onSyncStart: completed')\n\n    if (!this.fileId) {\n      // notify sync process that we should reset cache\n      return false\n    }\n  }\n\n  async onSyncFail() {\n    Logger.log('onSyncFail')\n    if (this.fileId) {\n      clearInterval(this.lockingInterval)\n      if (this.locked) {\n        await this.freeLock(this.fileId)\n      }\n    }\n    this.fileId = null\n  }\n\n  async onSyncComplete() {\n    Logger.log('onSyncComplete')\n    clearInterval(this.lockingInterval)\n\n    this.bookmarksCache = this.bookmarksCache.clone()\n    const newTreeHash = await this.bookmarksCache.hash(true)\n    let xbel = createXBEL(this.bookmarksCache, this.highestId)\n\n    if (this.server.password) {\n      const salt = Crypto.bufferToHexstr(Crypto.getRandomBytes(64))\n      const ciphertext = await Crypto.encryptAES(this.server.password, xbel, salt)\n      xbel = JSON.stringify({ciphertext, salt})\n    }\n\n    if (!this.fileId) {\n      await this.createFile(xbel)\n      this.fileId = null\n      return\n    }\n\n    if (newTreeHash !== this.initialTreeHash || this.alwaysUpload) {\n      await this.uploadFile(this.fileId, xbel)\n      this.alwaysUpload = false // reset flag\n    } else {\n      Logger.log('No changes to the server version necessary')\n    }\n    await this.freeLock(this.fileId)\n    this.fileId = null\n  }\n\n  cancel() {\n    this.cancelCallback && this.cancelCallback()\n  }\n\n  async request(method: string, url: string, body: any = null, contentType: string = null) : Promise<CustomResponse> {\n    return this.requestNative(method, url, body, contentType)\n  }\n\n  async requestWeb(method: string, url: string, body: any = null, contentType: string = null) : Promise<CustomResponse> {\n    let resp\n    try {\n      resp = await fetch(url, {\n        method,\n        credentials: 'omit',\n        headers: {\n          ...(this.accessToken && {Authorization: 'Bearer ' + this.accessToken}),\n          ...(contentType && {'Content-type': contentType})\n        },\n        ...(body && {body}),\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      throw new NetworkError()\n    }\n    if (resp.status === 401 || resp.status === 403) {\n      Logger.log('Failed to authenticate to Google API: ' + await resp.text())\n      throw new AuthenticationError()\n    }\n    return resp\n  }\n\n  async requestNative(method: string, url: string, body: any = null, contentType: string = null) : Promise<CustomResponse> {\n    let res\n\n    if (contentType === 'application/x-www-form-urlencoded') {\n      const params = new URLSearchParams()\n      for (const [key, value] of Object.entries(body || {})) {\n        params.set(key, value as string)\n      }\n      body = params.toString()\n    }\n\n    try {\n      res = await Http.request({\n        url,\n        method,\n        headers: {\n          ...(this.accessToken && {Authorization: 'Bearer ' + this.accessToken}),\n          ...(contentType && {'Content-type': contentType}),\n        },\n        responseType: 'text',\n        ...(body && {data: body})\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      throw new NetworkError()\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      Logger.log('Failed to authenticate to Google API: ' + res.data)\n      throw new AuthenticationError()\n    }\n\n    if (res.status >= 500) {\n      throw new HttpError(res.status, method)\n    }\n\n    return {\n      status: res.status,\n      json: () => Promise.resolve(res.data),\n      text: () => Promise.resolve(res.data),\n    }\n  }\n\n  async listFiles(query: string, limit = 1) : Promise<any> {\n    const res = await this.request('GET', this.getUrl() + `/files?corpora=user&q=${encodeURIComponent(query)}&orderBy=modifiedTime%20desc&fields=files(id%2Cname%2Ctrashed)&pageSize=${limit}`)\n    return res.json()\n  }\n\n  async getFileMetadata(id: string, fields?:string): Promise<any> {\n    const res = await this.request('GET', this.getUrl() + '/files/' + id + (fields ? `?fields=${encodeURIComponent(fields)}` : ''))\n    return res.json()\n  }\n\n  async downloadFile(id: string): Promise<string> {\n    const res = await this.request('GET', this.getUrl() + '/files/' + id + '?alt=media')\n    return res.text()\n  }\n\n  async deleteFile(id: string): Promise<void> {\n    await this.request('DELETE', this.getUrl() + '/files/' + id)\n  }\n\n  async freeLock(id:string) {\n    if (this.lockingPromise) {\n      await this.lockingPromise\n    }\n    let lockFreed, i = 0\n    do {\n      const res = await this.request('PATCH', this.getUrl() + '/files/' + id,\n        JSON.stringify({\n          appProperties: {\n            locked: JSON.stringify(false)\n          }\n        }),\n        'application/json'\n      )\n      lockFreed = res.status === 200 || res.status === 204\n      if (!lockFreed) {\n        await this.timeout(1000)\n      }\n      i++\n    } while (!lockFreed && i < 10)\n    return lockFreed\n  }\n\n  async setLock(id:string) {\n    this.lockingPromise = this.request('PATCH', this.getUrl() + '/files/' + id,\n      JSON.stringify({\n        appProperties: {\n          locked: JSON.stringify(Date.now())\n        }\n      }),\n      'application/json'\n    )\n    const res = await this.lockingPromise\n    return res.status === 200\n  }\n\n  async createFile(xbel: string) {\n    let res = await this.request('POST', 'https://www.googleapis.com/upload/drive/v3/files?uploadType=media', xbel, 'application/xml')\n    if (res.status !== 200 && res.status !== 201) {\n      return false\n    }\n    const file = await res.json()\n    this.fileId = file.id\n\n    res = await this.request('PATCH', this.getUrl() + '/files/' + this.fileId,\n      JSON.stringify({name: this.server.bookmark_file}),\n      'application/json'\n    )\n    return res.status === 200\n  }\n\n  async uploadFile(id:string, xbel: string) {\n    const resp = await this.request('PATCH', 'https://www.googleapis.com/upload/drive/v3/files/' + id, xbel, 'application/xml')\n    return resp.status === 200\n  }\n}\n\nfunction createXBEL(rootFolder, highestId) {\n  let output = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\" \"http://pyxml.sourceforge.net/topics/dtds/xbel.dtd\">\n<xbel version=\"1.0\">\n`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += XbelSerializer.serialize(rootFolder)\n\n  output += `\n</xbel>`\n\n  return output\n}\n","import * as Tree from '../Tree'\nimport { Bookmark, Folder, ItemLocation, TItemLocation } from '../Tree'\nimport Logger from '../Logger'\nimport Adapter from '../interfaces/Adapter'\nimport difference from 'lodash/difference'\n\nimport Ordering from '../interfaces/Ordering'\nimport {\n  MissingItemOrderError,\n  UnknownBookmarkUpdateError,\n  UnknownCreateTargetError, UnknownFolderItemOrderError, UnknownFolderOrderError, UnknownFolderUpdateError,\n  UnknownMoveOriginError,\n  UnknownMoveTargetError\n} from '../../errors/Error'\nimport { BulkImportResource } from '../interfaces/Resource'\n\nexport default class CachingAdapter implements Adapter, BulkImportResource<TItemLocation> {\n  protected highestId: number\n  protected bookmarksCache: Folder<TItemLocation>\n  protected server: any\n  protected location: TItemLocation = ItemLocation.SERVER\n\n  constructor(server: any) {\n    this.resetCache()\n  }\n\n  resetCache() {\n    this.highestId = 0\n    this.bookmarksCache = new Folder({ id: 0, title: 'root', location: this.location })\n  }\n\n  getLabel():string {\n    const data = this.getData()\n    return data.label || data.username + '@' + new URL(data.url).hostname\n  }\n\n  async getBookmarksTree(): Promise<Folder<TItemLocation>> {\n    return this.bookmarksCache.clone()\n  }\n\n  acceptsBookmark(bm:Bookmark<TItemLocation>):boolean {\n    if (bm.url === 'data:') {\n      return false\n    }\n    try {\n      return Boolean(['https:', 'http:', 'ftp:', 'data:', 'javascript:', 'file:', 'chrome:', 'edge:'].includes(\n        new URL(bm.url).protocol\n      ))\n    } catch (e) {\n      return false\n    }\n  }\n\n  async createBookmark(bm:Bookmark<TItemLocation>):Promise<string|number> {\n    Logger.log('CREATE', bm)\n    bm.id = ++this.highestId\n    const foundFolder = this.bookmarksCache.findFolder(bm.parentId)\n    if (!foundFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    foundFolder.children.push(bm)\n    this.bookmarksCache.createIndex()\n    return bm.id\n  }\n\n  async updateBookmark(newBm: Bookmark<TItemLocation>): Promise<void> {\n    Logger.log('UPDATE', newBm)\n    const foundBookmark = this.bookmarksCache.findBookmark(newBm.id)\n    if (!foundBookmark) {\n      throw new UnknownBookmarkUpdateError()\n    }\n    foundBookmark.url = newBm.url\n    foundBookmark.title = newBm.title\n    if (String(foundBookmark.parentId) === String(newBm.parentId)) {\n      return\n    }\n    const foundOldFolder = this.bookmarksCache.findFolder(\n      foundBookmark.parentId\n    )\n    if (!foundOldFolder) {\n      throw new UnknownMoveOriginError()\n    }\n    const foundNewFolder = this.bookmarksCache.findFolder(newBm.parentId)\n    if (!foundNewFolder) {\n      throw new UnknownMoveTargetError()\n    }\n    foundOldFolder.children.splice(\n      foundOldFolder.children.indexOf(foundBookmark),\n      1\n    )\n    foundNewFolder.children.push(foundBookmark)\n    foundBookmark.parentId = newBm.parentId\n    this.bookmarksCache.createIndex()\n  }\n\n  async removeBookmark(bookmark:Bookmark<TItemLocation>): Promise<void> {\n    Logger.log('REMOVE', { bookmark })\n    const id = bookmark.id\n    const foundBookmark = this.bookmarksCache.findBookmark(id)\n    if (!foundBookmark) {\n      return\n    }\n    const foundOldFolder = this.bookmarksCache.findFolder(\n      foundBookmark.parentId\n    )\n    if (!foundOldFolder) {\n      return\n    }\n    foundOldFolder.children.splice(\n      foundOldFolder.children.indexOf(foundBookmark),\n      1\n    )\n    this.bookmarksCache.createIndex()\n  }\n\n  async createFolder(folder:Folder<TItemLocation>): Promise<string|number> {\n    Logger.log('CREATEFOLDER', { folder })\n    const newFolder = new Tree.Folder({ id: ++this.highestId, parentId: folder.parentId, title: folder.title, location: this.location })\n    const foundParentFolder = this.bookmarksCache.findFolder(newFolder.parentId)\n    if (!foundParentFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    foundParentFolder.children.push(newFolder)\n    this.bookmarksCache.createIndex()\n    return newFolder.id\n  }\n\n  async updateFolder(folder:Folder<TItemLocation>): Promise<void> {\n    Logger.log('UPDATEFOLDER', { folder })\n    const id = folder.id\n    const oldFolder = this.bookmarksCache.findFolder(id)\n    if (!oldFolder) {\n      throw new UnknownFolderUpdateError()\n    }\n\n    const foundOldParentFolder = this.bookmarksCache.findFolder(oldFolder.parentId)\n    if (!foundOldParentFolder) {\n      throw new UnknownMoveOriginError()\n    }\n    const foundNewParentFolder = this.bookmarksCache.findFolder(folder.parentId)\n    if (!foundNewParentFolder) {\n      throw new UnknownMoveTargetError()\n    }\n    if (oldFolder.findFolder(foundNewParentFolder.id)) {\n      throw new Error('Detected creation of folder loop: Moving ' + id + ' to ' + folder.parentId + ', but it already contains the new parent node')\n    }\n    foundOldParentFolder.children.splice(foundOldParentFolder.children.indexOf(oldFolder), 1)\n    foundNewParentFolder.children.push(oldFolder)\n    oldFolder.title = folder.title\n    oldFolder.parentId = folder.parentId\n    this.bookmarksCache.createIndex()\n  }\n\n  async orderFolder(id:string|number, order:Ordering<TItemLocation>):Promise<void> {\n    Logger.log('ORDERFOLDER', { id, order })\n\n    const folder = this.bookmarksCache.findFolder(id)\n    if (!folder) {\n      throw new UnknownFolderOrderError()\n    }\n    order.forEach(item => {\n      const child = folder.findItem(item.type, item.id)\n      if (!child || String(child.parentId) !== String(folder.id)) {\n        throw new UnknownFolderItemOrderError(id + ':' + JSON.stringify(item))\n      }\n    })\n    folder.children.forEach(child => {\n      const item = order.find((item) => item.type === child.type && String(item.id) === String(child.id))\n      if (!item) {\n        throw new MissingItemOrderError(\n          id + ':' + child.inspect()\n        )\n      }\n    })\n    if (order.length !== folder.children.length) {\n      const diff = difference(folder.children.map(i => i.id), order.map(i => i.id))\n      throw new MissingItemOrderError(id + ':' + JSON.stringify(diff))\n    }\n    const newChildren = []\n    order.forEach(item => {\n      const child = folder.findItem(item.type, item.id)\n      newChildren.push(child)\n    })\n    folder.children = newChildren\n  }\n\n  async removeFolder(folder:Folder<TItemLocation>):Promise<void> {\n    Logger.log('REMOVEFOLDER', { folder })\n    const id = folder.id\n    const oldFolder = this.bookmarksCache.findFolder(id)\n    if (!oldFolder) {\n      return\n    }\n    // root folder doesn't have a parent, yo!\n    const foundOldFolder = this.bookmarksCache.findFolder(oldFolder.parentId)\n    if (!foundOldFolder) {\n      return\n    }\n    foundOldFolder.children.splice(foundOldFolder.children.indexOf(oldFolder), 1)\n    this.bookmarksCache.createIndex()\n  }\n\n  async bulkImportFolder(id:string|number, folder:Folder<TItemLocation>):Promise<Folder<TItemLocation>> {\n    Logger.log('BULKIMPORT', { id, folder })\n    const foundFolder = this.bookmarksCache.findFolder(id)\n    if (!foundFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    // clone and adjust ids\n    const imported = folder.clone()\n    imported.id = id\n    await imported.traverse(async(item, parentFolder) => {\n      item.id = ++this.highestId\n      item.parentId = parentFolder.id\n    })\n    // insert into tree\n    foundFolder.children = imported.children\n    // good as new\n    this.bookmarksCache.createIndex()\n    return imported\n  }\n\n  setData(data:any):void {\n    this.server = { ...data }\n  }\n\n  getData():any {\n    return { ...this.server }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars\n  async onSyncStart(needLock = true):Promise<void|boolean> { }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async onSyncFail():Promise<void> { }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async onSyncComplete():Promise<void> { }\n\n  cancel() {\n    // noop\n  }\n\n  isAvailable(): Promise<boolean> {\n    return Promise.resolve(true)\n  }\n}\n","import Serializer from '../interfaces/Serializer'\nimport { Bookmark, Folder, ItemLocation } from '../Tree'\nimport { XMLParser, XMLBuilder } from 'fast-xml-parser'\n\nclass XbelSerializer implements Serializer {\n  serialize(folder: Folder<typeof ItemLocation.SERVER>) {\n    const xbelObj = this._serializeFolder(folder)\n    const xmlBuilder = new XMLBuilder({format: true, preserveOrder: true, ignoreAttributes: false})\n    return xmlBuilder.build(xbelObj)\n  }\n\n  deserialize(xbel: string) {\n    const parser = new XMLParser({\n      preserveOrder: true,\n      ignorePiTags: true,\n      ignoreAttributes: false,\n      parseTagValue: false,\n    })\n    const xmlObj = parser.parse(xbel)\n\n    if (!Array.isArray(xmlObj[0].xbel)) {\n      throw new Error(\n        'Parse Error: ' + xbel\n      )\n    }\n\n    const rootFolder = new Folder({ id: 0, title: 'root', location: ItemLocation.SERVER })\n    try {\n      this._parseFolder(xmlObj[0].xbel, rootFolder)\n    } catch (e) {\n      throw new Error(\n        'Parse Error: ' + e.message\n      )\n    }\n    return rootFolder\n  }\n\n  _parseFolder(xbelObj, folder: Folder<typeof ItemLocation.SERVER>) {\n    /* parse depth first */\n\n    xbelObj\n      .forEach(node => {\n        let item\n        if (typeof node.bookmark !== 'undefined') {\n          item = new Bookmark({\n            id: parseInt(node[':@']['@_id']),\n            parentId: folder.id,\n            url: node[':@']['@_href'],\n            title: '' + (typeof node.bookmark?.[0]?.title?.[0]?.['#text'] !== 'undefined' ? node.bookmark?.[0]?.title?.[0]?.['#text'] : ''), // cast to string\n            location: ItemLocation.SERVER,\n          })\n        } else if (typeof node.folder !== 'undefined') {\n          item = new Folder({\n            id: parseInt(node[':@']?.['@_id']),\n            title: '' + (typeof node.folder?.[0]?.title?.[0]?.['#text'] !== 'undefined' ? node.folder?.[0]?.title?.[0]?.['#text'] : ''), // cast to string\n            parentId: folder.id,\n            location: ItemLocation.SERVER,\n          })\n          this._parseFolder(node.folder, item)\n        } else {\n          return\n        }\n\n        folder.children.push(item)\n      })\n  }\n\n  _serializeFolder(folder: Folder<typeof ItemLocation.SERVER>) {\n    return folder.children\n      .map(child => {\n        if (child instanceof Bookmark) {\n          return {\n            bookmark: [\n              {title: [{'#text': child.title}]}\n            ],\n            ':@': {\n              '@_href': child.url,\n              '@_id': String(child.id)\n            }\n          }\n        }\n\n        if (child instanceof Folder) {\n          return {\n            folder: [\n              {title: [{'#text': child.title}]},\n              ...this._serializeFolder(child)\n            ],\n            ':@': {\n              ...('id' in child && {'@_id': String(child.id)}),\n            }\n          }\n        }\n      })\n  }\n}\n\nexport default new XbelSerializer()\n","export const isTest = typeof window !== 'undefined' && (new URL(window.location.href)).pathname.includes('test')\n","import { TItem, TItemLocation, TItemType } from './Tree'\n\ntype InternalItemTypeMapping = { LocalToServer: Record<string, string>, ServerToLocal: Record<string, string> }\n\nexport type Mapping = Record<TItemType,Record<string,number|string>>\n\nexport type MappingSnapshot = {\n  ServerToLocal: Mapping,\n  LocalToServer: Mapping\n}\n\nexport default class Mappings {\n  private folders: InternalItemTypeMapping\n  private bookmarks: InternalItemTypeMapping\n  private storage: any\n\n  constructor(storageAdapter:any, mappingsData:any) {\n    this.storage = storageAdapter\n    this.folders = mappingsData.folders\n    this.bookmarks = mappingsData.bookmarks\n  }\n\n  getSnapshot():MappingSnapshot {\n    return {\n      ServerToLocal: {\n        bookmark: {...this.bookmarks.ServerToLocal},\n        folder: {...this.folders.ServerToLocal}\n      },\n      LocalToServer: {\n        bookmark: {...this.bookmarks.LocalToServer},\n        folder: {...this.folders.LocalToServer}\n      }\n    }\n  }\n\n  async addFolder({ localId, remoteId }: { localId?:string|number, remoteId?:string|number }):Promise<void> {\n    Mappings.add(this.folders, { localId, remoteId })\n  }\n\n  async removeFolder({ localId, remoteId }: { localId?:string|number, remoteId?:string|number }):Promise<void> {\n    Mappings.remove(this.folders, { localId, remoteId })\n  }\n\n  async addBookmark({ localId, remoteId }: { localId?:string|number, remoteId?:string|number }):Promise<void> {\n    Mappings.add(this.bookmarks, { localId, remoteId })\n  }\n\n  async removeBookmark({ localId, remoteId }: { localId?:string|number, remoteId?:string|number }):Promise<void> {\n    Mappings.remove(this.bookmarks, { localId, remoteId })\n  }\n\n  async persist():Promise<void> {\n    await this.storage.setMappings({\n      folders: this.folders,\n      bookmarks: this.bookmarks\n    })\n  }\n\n  private static add(mappings, { localId, remoteId }: { localId?:string|number, remoteId?:string|number }) {\n    if (typeof localId === 'undefined' || typeof remoteId === 'undefined') {\n      throw new Error('Cannot add empty mapping')\n    }\n    mappings.LocalToServer[localId] = remoteId\n    mappings.ServerToLocal[remoteId] = localId\n  }\n\n  private static remove(mappings, { localId, remoteId }: { localId?:string|number, remoteId?:string|number }):InternalItemTypeMapping {\n    if (localId && remoteId && mappings.LocalToServer[localId] !== remoteId) {\n      mappings = this.remove(mappings, { localId })\n      return this.remove(mappings, { remoteId })\n    }\n\n    if (typeof localId !== 'undefined') {\n      delete mappings.ServerToLocal[mappings.LocalToServer[localId]]\n      delete mappings.LocalToServer[localId]\n    } else {\n      delete mappings.LocalToServer[mappings.ServerToLocal[remoteId]]\n      delete mappings.ServerToLocal[remoteId]\n    }\n  }\n\n  static mapId(mappingsSnapshot:MappingSnapshot, item: TItem<TItemLocation>, target: TItemLocation) : string|number {\n    if (item.location === target) {\n      return item.id\n    }\n    return mappingsSnapshot[item.location + 'To' + target][item.type][item.id]\n  }\n\n  static mapParentId(mappingsSnapshot:MappingSnapshot, item: TItem<TItemLocation>, target: TItemLocation) : string|number {\n    if (item.location === target) {\n      return item.parentId\n    }\n    return mappingsSnapshot[item.location + 'To' + target].folder[item.parentId]\n  }\n\n  static mappable(mappingsSnapshot: MappingSnapshot, item1: TItem<TItemLocation>, item2: TItem<TItemLocation>) : boolean {\n    if (Mappings.mapId(mappingsSnapshot, item1, item2.location) === item2.id) {\n      return true\n    }\n    if (Mappings.mapId(mappingsSnapshot, item2, item1.location) === item1.id) {\n      return true\n    }\n    return false\n  }\n}\n","import CachingAdapter from './Caching'\nimport XbelSerializer from '../serializers/Xbel'\nimport Logger from '../Logger'\nimport { Capacitor } from '@capacitor/core'\nimport * as git from 'isomorphic-git'\nimport http from 'isomorphic-git/http/web'\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport FS from '@isomorphic-git/lightning-fs'\nimport Html from '../serializers/Html'\nimport {\n  FileUnreadableError,\n  MissingPermissionsError,\n  ResourceLockedError,\n  SlashError\n} from '../../errors/Error'\nimport Crypto from '../Crypto'\n\nconst LOCK_INTERVAL = 2 * 60 * 1000 // Lock every 2mins while syncing\nconst LOCK_TIMEOUT = 15 * 60 * 1000 // Override lock 0.25h after last time lock has been set\nexport default class GitAdapter extends CachingAdapter {\n  private lockingInterval: any\n  private lockingPromise: Promise<void>\n  private locked: string[]\n  private cancelCallback: () => void\n  private initialTreeHash: string\n  private dir: string\n  private hash: string\n  private fs: FS|null\n\n  constructor(server) {\n    super(server)\n    this.server = server\n    this.locked = []\n    this.lockingInterval = null\n  }\n\n  static getDefaultValues() {\n    return {\n      type: 'git',\n      url: 'https://example.org/repo.git',\n      username: 'bob',\n      password: 's3cret',\n      branch: 'main',\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      includeCredentials: false,\n      allowRedirects: false,\n      allowNetwork: false,\n    }\n  }\n\n  getLabel():string {\n    const data = this.getData()\n    const url = new URL(data.url)\n    url.protocol = ''\n    return data.label || data.username + '@' + url.hostname + ':' + data.bookmark_file\n  }\n\n  getData() {\n    return { ...GitAdapter.getDefaultValues(), ...this.server }\n  }\n\n  cancel() {\n    this.cancelCallback && this.cancelCallback()\n  }\n\n  async onSyncStart(needLock = true, forceLock = false) {\n    Logger.log('onSyncStart: begin')\n\n    this.hash = await Crypto.sha256(JSON.stringify(this.server)) + Date.now()\n    this.dir = '/' + this.hash + '/'\n\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../browser-api')).default\n      let hasPermissions, error = false\n      try {\n        hasPermissions = await browser.permissions.contains({ origins: [this.server.url + '/'] })\n      } catch (e) {\n        error = true\n        console.warn(e)\n      }\n      if (!error && !hasPermissions) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.fs = new FS(this.hash, {wipe: true})\n\n    Logger.log('(git) init')\n    await git.init({ fs: this.fs, dir: this.dir })\n    await git.addRemote({\n      fs: this.fs,\n      dir: this.dir,\n      url: this.server.url,\n      remote: 'origin',\n      force: true\n    })\n\n    try {\n      Logger.log('(git) fetch from remote')\n      await git.fetch({\n        http,\n        fs: this.fs,\n        dir: this.dir,\n        tags: true,\n        pruneTags: true,\n        remote: 'origin',\n        depth: 10,\n        onAuth: () => this.onAuth()\n      })\n      Logger.log('(git) checkout branch ' + (this.server.branch))\n      await git.checkout({ fs: this.fs, dir: this.dir, ref: this.server.branch })\n    } catch (e) {\n      if (e && e.code === git.Errors.NotFoundError.code && (e.data.what === 'HEAD' || e.data.what === this.server.branch || e.data.what === 'origin/' + this.server.branch)) {\n        Logger.log('(git) writeFile ' + this.dir + '/README.md')\n        await this.fs.promises.writeFile(this.dir + '/README.md', 'This repository is used to synchronize bookmarks via [floccus](https://floccus.org).', {mode: 0o777, encoding: 'utf8'})\n        Logger.log('(git) add .')\n        await git.add({fs: this.fs, dir: this.dir, filepath: '.'})\n        Logger.log('(git) commit')\n        await git.commit({\n          fs: this.fs,\n          dir: this.dir,\n          message: 'Floccus bookmarks update',\n          author: {\n            name: 'Floccus bookmarks sync',\n          }\n        })\n        const currentBranch = await git.currentBranch({fs: this.fs, dir: this.dir})\n        if (currentBranch && currentBranch !== this.server.branch) {\n          await git.renameBranch({ fs: this.fs, dir: this.dir, ref: this.server.branch, oldref: currentBranch })\n        }\n        Logger.log('(git) push')\n        await git.push({\n          fs: this.fs,\n          http,\n          dir: this.dir,\n          ref: this.server.branch,\n          remoteRef: this.server.branch,\n          remote: 'origin',\n          onAuth: () => this.onAuth()\n        })\n      } else {\n        throw e\n      }\n    }\n\n    if (this.server.bookmark_file[0] === '/') {\n      throw new SlashError()\n    }\n\n    if (this.lockingInterval) {\n      clearInterval(this.lockingInterval)\n    }\n    if (forceLock) {\n      await this.clearAllLocks()\n      await this.setLock()\n    } else if (needLock) {\n      await this.obtainLock()\n    }\n    if (needLock || forceLock) {\n      this.lockingInterval = setInterval(() => this.setLock(), LOCK_INTERVAL) // Set lock every minute\n    }\n\n    const status = await this.pullFromServer()\n\n    this.initialTreeHash = await this.bookmarksCache.hash(true)\n\n    Logger.log('onSyncStart: completed')\n\n    return status\n  }\n\n  async onSyncFail() {\n    Logger.log('onSyncFail')\n    clearInterval(this.lockingInterval)\n    await this.freeLock()\n    indexedDB.deleteDatabase(this.hash)\n  }\n\n  async onSyncComplete() {\n    Logger.log('onSyncComplete')\n    clearInterval(this.lockingInterval)\n\n    this.bookmarksCache = this.bookmarksCache.clone()\n    const newTreeHash = await this.bookmarksCache.hash(true)\n    if (newTreeHash !== this.initialTreeHash) {\n      const fileContents = this.server.bookmark_file_type === 'xbel' ? createXBEL(this.bookmarksCache, this.highestId) : createHTML(this.bookmarksCache, this.highestId)\n      Logger.log('(git) writeFile ' + this.dir + '/' + this.server.bookmark_file)\n      await this.fs.promises.writeFile(this.dir + '/' + this.server.bookmark_file, fileContents, {mode: 0o777, encoding: 'utf8'})\n      Logger.log('(git) add .')\n      await git.add({fs: this.fs, dir: this.dir, filepath: '.'})\n      Logger.log('(git) commit')\n      await git.commit({\n        fs: this.fs,\n        dir: this.dir,\n        message: `Floccus update: ${this.getLabel()}`,\n        author: {\n          name: 'Floccus bookmarks sync',\n        }\n      })\n      try {\n        Logger.log('(git) push')\n        await git.push({\n          fs: this.fs,\n          http,\n          dir: this.dir,\n          remote: 'origin',\n          force: true,\n          onAuth: () => this.onAuth()\n        })\n      } catch (e) {\n        if (e.code && e.code === git.Errors.PushRejectedError.code) {\n          await this.freeLock() // Only clears the locks set in the current adapter instance\n          throw new ResourceLockedError\n        }\n      }\n    } else {\n      Logger.log('No changes to the server version necessary')\n    }\n\n    await this.freeLock()\n    indexedDB.deleteDatabase(this.hash)\n  }\n\n  async obtainLock() {\n    const tags = await git.listTags({ fs: this.fs, dir: this.dir })\n    const lockTag = tags.sort().reverse().find((tag) => tag.startsWith('floccus-lock-'))\n    if (lockTag) {\n      const dateLocked = Number(lockTag.slice('floccus-lock-'.length))\n      if (Date.now() - dateLocked < LOCK_TIMEOUT) {\n        throw new ResourceLockedError()\n      }\n    }\n\n    await this.setLock()\n  }\n\n  async setLock() {\n    this.lockingPromise = (async() => {\n      const tag = 'floccus-lock-' + Date.now()\n      Logger.log('(git) tag ' + tag)\n      await git.tag({ fs: this.fs, dir: this.dir, ref: tag })\n      Logger.log('(git) push tag ' + tag)\n      await git.push({ fs: this.fs, http, dir: this.dir, ref: tag, onAuth: () => this.onAuth() })\n      this.locked.push(tag)\n    })()\n    await this.lockingPromise\n  }\n\n  async onAuth() {\n    return { username: this.server.username, password: this.server.password }\n  }\n\n  async freeLock() {\n    if (this.lockingPromise) {\n      await this.lockingPromise\n    }\n    if (!this.locked.length) {\n      return\n    }\n\n    try {\n      for (const tag of this.locked) {\n        Logger.log('(git) push: delete tag ' + tag)\n        await git.push({ fs: this.fs, http, dir: this.dir, ref: tag, delete: true, onAuth: () => this.onAuth() })\n      }\n      this.locked = []\n      return true\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      return false\n    }\n  }\n\n  async clearAllLocks(fs:FS = null): Promise<void> {\n    fs = fs || this.fs\n    const tags = await git.listTags({ fs, dir: this.dir })\n    const lockTags = tags.filter(tag => tag.startsWith('floccus-lock-'))\n    for (const tag of lockTags) {\n      await git.push({ fs, http, dir: this.dir, ref: tag, delete: true, onAuth: () => this.onAuth() })\n    }\n  }\n\n  async pullFromServer() {\n    let fileContents\n    try {\n      Logger.log('(git) readFile')\n      fileContents = await this.fs.promises.readFile(this.dir + '/' + this.server.bookmark_file, { encoding: 'utf8' })\n    } catch (e) {\n      this.resetCache()\n      // Could not find file\n      return false\n    }\n\n    if (!fileContents || (!fileContents.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>') && !fileContents.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>'))) {\n      throw new FileUnreadableError()\n    }\n\n    /* let's get the highestId */\n    for (const line of fileContents.split('\\n')) {\n      if (line.indexOf('<!--- highestId :') >= 0) {\n        const idxStart = line.indexOf(':') + 1\n        const idxEnd = line.lastIndexOf(':')\n\n        this.highestId = parseInt(line.substring(idxStart, idxEnd))\n        break\n      }\n    }\n\n    switch (this.server.bookmark_file_type) {\n      case 'xbel':\n        Logger.log('(git) parse XBEL')\n        this.bookmarksCache = XbelSerializer.deserialize(fileContents)\n        break\n      case 'html':\n        Logger.log('(git) parse HTML')\n        this.bookmarksCache = Html.deserialize(fileContents)\n        break\n      default:\n        throw new Error('Invalid bookmark file type')\n    }\n\n    // Found file, we can keep the cache from the previous run\n    return true\n  }\n\n  async clearServer() {\n    const hash = await Crypto.sha256(JSON.stringify(this.server)) + Date.now()\n    this.dir = '/' + hash + '/'\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const fs = new FS(hash, {wipe: true})\n\n    Logger.log('(git) init')\n    await git.init({ fs, dir: this.dir, defaultBranch: this.server.branch })\n    await git.addRemote({\n      fs,\n      dir: this.dir,\n      url: this.server.url,\n      remote: 'origin',\n      force: true\n    })\n    await fs.promises.writeFile(this.dir + '/README.md', 'This repository is used to synchronize bookmarks via [floccus](https://floccus.org).', {mode: 0o777, encoding: 'utf8'})\n    await git.add({fs, dir: this.dir, filepath: '.'})\n    await git.commit({\n      fs,\n      dir: this.dir,\n      message: 'Floccus bookmarks update',\n      author: {\n        name: 'Floccus bookmarks sync',\n      }\n    })\n    const currentBranch = await git.currentBranch({fs, dir: this.dir})\n    if (currentBranch && currentBranch !== this.server.branch) {\n      await git.renameBranch({ fs, dir: this.dir, ref: this.server.branch, oldref: currentBranch })\n    }\n    await git.push({\n      fs,\n      http,\n      dir: this.dir,\n      ref: this.server.branch,\n      remoteRef: this.server.branch,\n      remote: 'origin',\n      force: true,\n      onAuth: () => this.onAuth()\n    })\n    await git.fetch({\n      http,\n      fs,\n      dir: this.dir,\n      tags: true,\n      pruneTags: true,\n      remote: 'origin',\n      depth: 10,\n      onAuth: () => this.onAuth()\n    })\n    await this.clearAllLocks(fs)\n  }\n}\n\nfunction createXBEL(rootFolder, highestId) {\n  let output = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\" \"http://pyxml.sourceforge.net/topics/dtds/xbel.dtd\">\n<xbel version=\"1.0\">\n`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += XbelSerializer.serialize(rootFolder)\n\n  output += `\n</xbel>`\n\n  return output\n}\n\nfunction createHTML(rootFolder, highestId) {\n  let output = `<!DOCTYPE NETSCAPE-Bookmark-file-1>\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=UTF-8\">\n<TITLE>Bookmarks</TITLE>`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += Html.serialize(rootFolder)\n\n  output += '</html>'\n\n  return output\n}\n","import Adapter from '../interfaces/Adapter'\nimport { Bookmark, Folder, ItemLocation } from '../Tree'\nimport PQueue from 'p-queue'\nimport { IResource } from '../interfaces/Resource'\nimport Logger from '../Logger'\nimport {\n  AuthenticationError,\n  CancelledSyncError, HttpError,\n  NetworkError, ParseResponseError,\n  RedirectError,\n  RequestTimeoutError\n} from '../../errors/Error'\nimport { Capacitor, CapacitorHttp as Http } from '@capacitor/core'\n\nexport interface LinkwardenConfig {\n  type: 'linkwarden'\n  url: string\n  username: string\n  password: string\n  serverFolder: string,\n  includeCredentials?: boolean\n  allowRedirects?: boolean\n  allowNetwork?: boolean\n  label?: string\n}\n\nconst TIMEOUT = 300000\n\nexport default class LinkwardenAdapter implements Adapter, IResource<typeof ItemLocation.SERVER> {\n  private server: LinkwardenConfig\n  private fetchQueue: PQueue\n  private abortController: AbortController\n  private abortSignal: AbortSignal\n  private canceled: boolean\n\n  constructor(server: LinkwardenConfig) {\n    this.server = server\n    this.fetchQueue = new PQueue({ concurrency: 12 })\n    this.abortController = new AbortController()\n    this.abortSignal = this.abortController.signal\n  }\n\n  static getDefaultValues(): LinkwardenConfig {\n    return {\n      type: 'linkwarden',\n      url: 'https://example.org',\n      username: 'bob',\n      password: 's3cret',\n      serverFolder: 'Floccus',\n      includeCredentials: false,\n      allowRedirects: false,\n      allowNetwork: false,\n    }\n  }\n\n  acceptsBookmark(bm: Bookmark<typeof ItemLocation.SERVER>):boolean {\n    try {\n      return ['https:', 'http:', 'ftp:', 'javascript:'].includes(new URL(bm.url).protocol)\n    } catch (e) {\n      return false\n    }\n  }\n\n  cancel(): void {\n    this.canceled = true\n    this.abortController.abort()\n  }\n\n  setData(data:LinkwardenConfig):void {\n    this.server = { ...data }\n  }\n\n  getData(): LinkwardenConfig {\n    return { ...LinkwardenAdapter.getDefaultValues(), ...this.server }\n  }\n\n  getLabel(): string {\n    const data = this.getData()\n    return data.label || (data.username.includes('@') ? data.username + ' on ' + new URL(data.url).hostname : data.username + '@' + new URL(data.url).hostname)\n  }\n\n  onSyncComplete(): Promise<void> {\n    return Promise.resolve(undefined)\n  }\n\n  onSyncFail(): Promise<void> {\n    return Promise.resolve(undefined)\n  }\n\n  onSyncStart(needLock?: boolean, forceLock?: boolean): Promise<void | boolean> {\n    this.canceled = false\n    return Promise.resolve(undefined)\n  }\n\n  async createBookmark(bookmark: Bookmark<typeof ItemLocation.SERVER>): Promise<string | number> {\n    Logger.log('(linkwarden)CREATE', {bookmark})\n    const {response} = await this.sendRequest(\n      'POST', '/api/v1/links',\n      'application/json',\n      {\n        url: bookmark.url,\n        name: bookmark.title,\n        collection: {\n          id: bookmark.parentId,\n        },\n      })\n    return response.id\n  }\n\n  async updateBookmark(bookmark: Bookmark<typeof ItemLocation.SERVER>): Promise<void> {\n    Logger.log('(linkwarden)UPDATE', {bookmark})\n    const {response: collection} = await this.sendRequest('GET', `/api/v1/collections/${bookmark.parentId}`)\n    await this.sendRequest(\n      'PUT', `/api/v1/links/${bookmark.id}`,\n      'application/json',\n      {\n        id: bookmark.id,\n        url: bookmark.url,\n        name: bookmark.title,\n        tags: [],\n        collection: {\n          id: bookmark.parentId,\n          name: collection.name,\n          ownerId: collection.ownerId,\n        },\n      })\n  }\n\n  async removeBookmark(bookmark: Bookmark<typeof ItemLocation.SERVER>): Promise<void> {\n    Logger.log('(linkwarden)DELETE', {bookmark})\n    await this.sendRequest('DELETE', `/api/v1/links/${bookmark.id}`)\n  }\n\n  async createFolder(folder: Folder<typeof ItemLocation.SERVER>): Promise<string | number> {\n    Logger.log('(linkwarden)CREATEFOLDER', {folder})\n    const {response} = await this.sendRequest(\n      'POST', '/api/v1/collections',\n      'application/json',\n      {\n        name: folder.title,\n        parentId: folder.parentId,\n      })\n    return response.id\n  }\n\n  async updateFolder(folder: Folder<typeof ItemLocation.SERVER>): Promise<void> {\n    Logger.log('(linkwarden)UPDATEFOLDER', {folder})\n    const {response: collection} = await this.sendRequest('GET', `/api/v1/collections/${folder.id}`)\n    await this.sendRequest(\n      'PUT', `/api/v1/collections/${folder.id}`,\n      'application/json',\n      {\n        ...collection,\n        name: folder.title,\n        parentId: folder.parentId,\n      })\n  }\n\n  async removeFolder(folder: Folder<typeof ItemLocation.SERVER>): Promise<void> {\n    Logger.log('(linkwarden)DELETEFOLDER', {folder})\n    let success = false\n    let count = 0\n    do {\n      try {\n        count++\n        await this.sendRequest('DELETE', `/api/v1/collections/${folder.id}`)\n        success = true\n      } catch (e) {\n        if (e instanceof HttpError && e.status === 401) {\n          success = true\n        } else if (count > 3) {\n          throw e\n        }\n        // noop\n      }\n    } while (!success)\n  }\n\n  async getBookmarksTree(loadAll?: boolean): Promise<Folder<typeof ItemLocation.SERVER>> {\n    const links = []\n    let response\n    do {\n      ({ response } = await this.sendRequest('GET', `/api/v1/links?cursor=${links.length ? links[links.length - 1].id : ''}`))\n      links.push(...response)\n    } while (response.length !== 0)\n\n    const { response: collections } = await this.sendRequest('GET', `/api/v1/collections`)\n\n    let rootCollection = collections.find(collection => collection.name === this.server.serverFolder && collection.parentId === null)\n    if (!rootCollection) {\n      ({response: rootCollection} = await this.sendRequest(\n        'POST', '/api/v1/collections',\n        'application/json',\n        {\n          name: this.server.serverFolder,\n        }))\n    }\n\n    const buildTree = (collection, isRoot = false) => {\n      return new Folder({\n        id: collection.id,\n        title: collection.name,\n        parentId: collection.parentId,\n        location: ItemLocation.SERVER,\n        isRoot,\n        children: collections\n          .filter(col => col.parentId === collection.id)\n          .map(buildTree).concat(\n            links\n              .filter(link => link.collectionId === collection.id)\n              .map(link => new Bookmark({\n                id: link.id,\n                title: link.name,\n                parentId: link.collectionId,\n                url: link.url,\n                location: ItemLocation.SERVER,\n              }))\n          ),\n      })\n    }\n\n    return buildTree(rootCollection, true)\n  }\n\n  async isAvailable(): Promise<boolean> {\n    return true\n  }\n\n  async sendRequest(verb:string, relUrl:string, type:string = null, body:any = null, returnRawResponse = false):Promise<any> {\n    const url = this.server.url + relUrl\n    let res\n    let timedOut = false\n\n    if (type && type.includes('application/json')) {\n      body = JSON.stringify(body)\n    } else if (type && type.includes('application/x-www-form-urlencoded')) {\n      const params = new URLSearchParams()\n      for (const [key, value] of Object.entries(body || {})) {\n        params.set(key, value as any)\n      }\n      body = params.toString()\n    }\n\n    Logger.log(`QUEUING ${verb} ${url}`)\n\n    if (Capacitor.getPlatform() !== 'web') {\n      return this.sendRequestNative(verb, url, type, body, returnRawResponse)\n    }\n\n    try {\n      res = await this.fetchQueue.add(() => {\n        Logger.log(`FETCHING ${verb} ${url}`)\n        return Promise.race([\n          fetch(url, {\n            method: verb,\n            credentials: this.server.includeCredentials ? 'include' : 'omit',\n            headers: {\n              ...(type && type !== 'multipart/form-data' && { 'Content-type': type }),\n              Authorization: 'Bearer ' + this.server.password,\n            },\n            signal: this.abortSignal,\n            ...(body && !['get', 'head'].includes(verb.toLowerCase()) && { body }),\n          }),\n          new Promise((resolve, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(new RequestTimeoutError())\n            }, TIMEOUT)\n          ),\n        ])\n      })\n    } catch (e) {\n      if (timedOut) throw e\n      if (this.canceled) throw new CancelledSyncError()\n      console.log(e)\n      throw new NetworkError()\n    }\n\n    Logger.log(`Receiving response for ${verb} ${url}`)\n\n    if (res.redirected && !this.server.allowRedirects) {\n      throw new RedirectError()\n    }\n\n    if (returnRawResponse) {\n      return res\n    }\n\n    if (res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status === 503 || res.status >= 400) {\n      throw new HttpError(res.status, verb)\n    }\n    let json\n    try {\n      json = await res.json()\n    } catch (e) {\n      throw new ParseResponseError(e.message)\n    }\n\n    return json\n  }\n\n  private async sendRequestNative(verb: string, url: string, type: string, body: any, returnRawResponse: boolean) {\n    let res\n    let timedOut = false\n    try {\n      res = await this.fetchQueue.add(() => {\n        Logger.log(`FETCHING ${verb} ${url}`)\n        return Promise.race([\n          Http.request({\n            url,\n            method: verb,\n            disableRedirects: !this.server.allowRedirects,\n            headers: {\n              ...(type && type !== 'multipart/form-data' && { 'Content-type': type }),\n              Authorization: 'Bearer ' + this.server.password,\n            },\n            responseType: 'json',\n            ...(body && !['get', 'head'].includes(verb.toLowerCase()) && { data: body }),\n          }),\n          new Promise((resolve, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(new RequestTimeoutError())\n            }, TIMEOUT)\n          ),\n        ])\n      })\n    } catch (e) {\n      if (timedOut) throw e\n      console.log(e)\n      throw new NetworkError()\n    }\n\n    Logger.log(`Receiving response for ${verb} ${url}`)\n\n    if (res.status < 400 && res.status >= 300) {\n      throw new RedirectError()\n    }\n\n    if (returnRawResponse) {\n      return res\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status === 503 || res.status >= 400) {\n      throw new HttpError(res.status, verb)\n    }\n    const json = res.data\n\n    return json\n  }\n}\n","import { Preferences as Storage } from '@capacitor/preferences'\nimport Cryptography from '../Crypto'\nimport DefunctCryptography from '../DefunctCrypto'\nimport Mappings from '../Mappings'\nimport { Folder, ItemLocation } from '../Tree'\nimport AsyncLock from 'async-lock'\nimport Logger from '../Logger'\n\nconst storageLock = new AsyncLock()\n\nexport default class NativeAccountStorage {\n  constructor(id) {\n    this.accountId = id\n  }\n\n  static async changeEntry(entryName, fn, defaultVal) {\n    await storageLock.acquire(entryName, async() => {\n      let entry = await NativeAccountStorage.getEntry(entryName, defaultVal)\n      entry = fn(entry)\n\n      await Storage.set({ key: entryName, value: JSON.stringify(entry) })\n    })\n  }\n\n  static async getEntry(entryName, defaultVal) {\n    let entry = await Storage.get({key: entryName })\n    try {\n      if (entry.value) {\n        while (typeof entry.value === 'string') {\n          entry.value = JSON.parse(entry.value)\n        }\n        return entry.value\n      } else {\n        return defaultVal\n      }\n    } catch (e) {\n      Logger.log('Error while parsing NativeAccountStorage entry value ' + e.message)\n      console.error(e)\n      return defaultVal\n    }\n  }\n\n  static deleteEntry(entryName) {\n    return Storage.remove({key: entryName})\n  }\n\n  static async getAllAccounts() {\n    let accounts = await NativeAccountStorage.getEntry(`accounts`, {})\n    return Object.keys(accounts)\n  }\n\n  async getAccountData(key) {\n    let accounts = await NativeAccountStorage.getEntry(`accounts`, {})\n    let data = accounts[this.accountId]\n    if (key) {\n      if (data.iv) {\n        data.password = await DefunctCryptography.decryptAES(key, data.iv, data.password)\n        delete data.iv\n      } else {\n        data.password = await Cryptography.decryptAES(key, data.password, data.username)\n        if (data.passphrase) {\n          data.passphrase = await Cryptography.decryptAES(key, data.passphrase, data.username)\n        }\n      }\n    }\n    return data\n  }\n\n  async setAccountData(data, key) {\n    let encData = data\n    if (key) {\n      if (data.iv) {\n        delete data.iv\n      }\n      encData = {\n        ...data,\n        password: await Cryptography.encryptAES(key, data.password, data.username),\n        ...(data.passphrase && {passphrase: await Cryptography.encryptAES(key, data.passphrase, data.username)})\n      }\n    }\n    return NativeAccountStorage.changeEntry(\n      `accounts`,\n      accounts => {\n        accounts[this.accountId] = encData\n        return accounts\n      },\n      {}\n    )\n  }\n\n  async deleteAccountData() {\n    await NativeAccountStorage.changeEntry(`accounts`, accounts => {\n      delete accounts[this.accountId]\n      return accounts\n    })\n    await this.deleteCache()\n    await this.deleteMappings()\n  }\n\n  async initCache() {\n    await NativeAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].cache`,\n      () => ({})\n    )\n  }\n\n  async getCache() {\n    const data = await NativeAccountStorage.getEntry(\n      `bookmarks[${this.accountId}].cache`\n    )\n    return Folder.hydrate(data && Object.keys(data).length ? data : {location: ItemLocation.LOCAL})\n  }\n\n  async setCache(data) {\n    await NativeAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].cache`,\n      () => data\n    )\n  }\n\n  async deleteCache() {\n    await NativeAccountStorage.deleteEntry(`bookmarks[${this.accountId}].cache`)\n  }\n\n  async initMappings() {\n    await NativeAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].mappings`,\n      () => ({})\n    )\n  }\n\n  async getMappings() {\n    const data = await NativeAccountStorage.getEntry(\n      `bookmarks[${this.accountId}].mappings`\n    )\n    return new Mappings(\n      this,\n      data && Object.keys(data).length\n        ? data\n        : {\n          bookmarks: {\n            ServerToLocal: {},\n            LocalToServer: {}\n          },\n          folders: {\n            ServerToLocal: {},\n            LocalToServer: {}\n          }\n        }\n    )\n  }\n\n  async setMappings(data) {\n    await NativeAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].mappings`,\n      () => data\n    )\n  }\n\n  async deleteMappings() {\n    await NativeAccountStorage.deleteEntry(`bookmarks[${this.accountId}].mappings`)\n  }\n\n  async getCurrentContinuation() {\n    return NativeAccountStorage.getEntry(`bookmarks[${this.accountId}].continuation`)\n  }\n\n  async setCurrentContinuation(continuation) {\n    await NativeAccountStorage.changeEntry(`bookmarks[${this.accountId}].continuation`, (_) => continuation, null)\n  }\n}\n","import { Folder, TItem, ItemType, TItemLocation, ItemLocation, hydrate } from './Tree'\nimport Mappings, { MappingSnapshot } from './Mappings'\nimport Ordering from './interfaces/Ordering'\nimport batchingToposort from 'batching-toposort'\nimport Logger from './Logger'\n\nexport const ActionType = {\n  CREATE: 'CREATE',\n  UPDATE: 'UPDATE',\n  MOVE: 'MOVE',\n  REMOVE: 'REMOVE',\n  REORDER: 'REORDER',\n} as const\n\nexport type TActionType = (typeof ActionType)[keyof typeof ActionType];\n\nexport interface CreateAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'CREATE',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n  index?: number,\n  oldIndex?: number,\n}\n\nexport interface UpdateAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'UPDATE',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n}\n\nexport interface RemoveAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'REMOVE',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n  index?: number,\n  oldIndex?: number,\n}\n\nexport interface ReorderAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'REORDER',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n  order: Ordering<L1>,\n  oldOrder?: Ordering<L2>,\n}\n\nexport interface MoveAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'MOVE',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n  index?: number,\n  oldIndex?: number,\n}\n\nexport type Action<L1 extends TItemLocation, L2 extends TItemLocation> = CreateAction<L1, L2>|UpdateAction<L1, L2>|RemoveAction<L1, L2>|ReorderAction<L1,L2>|MoveAction<L1,L2>\n\nexport type LocationOfAction<A> = A extends Action<infer L, TItemLocation> ? L : never\nexport type OldLocationOfAction<A> = A extends Action<TItemLocation, infer L> ? L : never\n\nexport type MapLocation<A extends Action<TItemLocation, TItemLocation>, NewLocation extends TItemLocation> =\n// eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n  A extends CreateAction<infer O, infer P> ?\n    CreateAction<NewLocation, O>\n    // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n    : A extends UpdateAction<infer O, infer P> ?\n      UpdateAction<NewLocation, O>\n      // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n      : A extends MoveAction<infer O, infer P> ?\n        MoveAction<NewLocation, O>\n        // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n        : A extends RemoveAction<infer O, infer P> ?\n          RemoveAction<NewLocation, O>\n          // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n          : A extends ReorderAction<infer O, infer P> ?\n            ReorderAction<NewLocation, O>\n            : never\n\nexport default class Diff<L1 extends TItemLocation, L2 extends TItemLocation, A extends Action<L1, L2>> {\n  private readonly actions: A[]\n\n  constructor() {\n    this.actions = []\n  }\n\n  clone(filter: (action:A)=>boolean = () => true): Diff<L1, L2, A> {\n    const newDiff : Diff<L1, L2, A> = new Diff\n    this.getActions().forEach((action: A) => {\n      if (filter(action)) {\n        newDiff.commit(action)\n      }\n    })\n\n    return newDiff\n  }\n\n  commit(action: A):void {\n    this.actions.push({ ...action })\n  }\n\n  retract(action: A):void {\n    this.actions.splice(this.actions.indexOf(action), 1)\n  }\n\n  getActions():A[] {\n    return [].concat(\n      this.actions\n    )\n  }\n\n  static findChain(\n    mappingsSnapshot: MappingSnapshot,\n    actions: Action<TItemLocation, TItemLocation>[], itemTree: Folder<TItemLocation>,\n    currentItem: TItem<TItemLocation>,\n    targetAction: Action<TItemLocation, TItemLocation>,\n    chain: Action<TItemLocation, TItemLocation>[] = []\n  ): boolean {\n    const targetItemInTree = itemTree.findFolder(Mappings.mapId(mappingsSnapshot, targetAction.payload, itemTree.location))\n    if (\n      targetAction.payload.findItem(ItemType.FOLDER,\n        Mappings.mapParentId(mappingsSnapshot, currentItem, targetAction.payload.location)) ||\n      (targetItemInTree && targetItemInTree.findFolder(Mappings.mapParentId(mappingsSnapshot, currentItem, itemTree.location)))\n    ) {\n      return true\n    }\n    const newCurrentActions = actions.filter(targetAction =>\n      !chain.includes(targetAction) && (\n        targetAction.payload.findItem(ItemType.FOLDER, Mappings.mapParentId(mappingsSnapshot, currentItem, targetAction.payload.location)) ||\n        (\n          itemTree.findFolder(Mappings.mapId(mappingsSnapshot, targetAction.payload, itemTree.location)) &&\n          itemTree.findFolder(Mappings.mapId(mappingsSnapshot, targetAction.payload, itemTree.location)).findFolder(Mappings.mapParentId(mappingsSnapshot, currentItem, itemTree.location)))\n      )\n    )\n    if (newCurrentActions.length) {\n      for (const newCurrentAction of newCurrentActions) {\n        if (Diff.findChain(mappingsSnapshot, actions, itemTree, newCurrentAction.payload, targetAction, [...chain, newCurrentAction])) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  static sortMoves<L1 extends TItemLocation, L2 extends TItemLocation>(actions: MoveAction<L1, L2>[], tree: Folder<L1>) :MoveAction<L1, L2>[][] {\n    const bookmarks = actions.filter(a => a.payload.type === ItemType.BOOKMARK)\n    const folderMoves = actions.filter(a => a.payload.type === ItemType.FOLDER)\n    const DAG = folderMoves\n      .reduce((DAG, action1) => {\n        DAG[action1.payload.id] = folderMoves.filter(action2 => {\n          if (action1 === action2 || String(action1.payload.id) === String(action2.payload.id)) {\n            return false\n          }\n          return (\n            (tree.findItem(action1.payload.type, action1.payload.id) && tree.findItem(action1.payload.type, action1.payload.id).findItem(action2.payload.type, action2.payload.id))\n          )\n        })\n          .map(a => a.payload.id)\n        return DAG\n      }, {})\n    let batches\n    try {\n      batches = batchingToposort(DAG).map(batch => batch.map(id => folderMoves.find(a => String(a.payload.id) === String(id))))\n    } catch (e) {\n      console.log({DAG, tree, actions})\n      throw e\n    }\n    batches.push(bookmarks)\n    batches.reverse()\n    return batches\n  }\n\n  /**\n   * on ServerToLocal: don't map removals\n   * on LocalToServer:\n   * @param mappingsSnapshot\n   * @param targetLocation\n   * @param filter\n   * @param skipErroneousActions\n   */\n  map<L3 extends TItemLocation>(mappingsSnapshot:MappingSnapshot, targetLocation: L3, filter: (action: A)=>boolean = () => true, skipErroneousActions = false): Diff<L3, L1, MapLocation<A, L3>> {\n    const newDiff : Diff<L3, L1, MapLocation<A, L3>> = new Diff\n\n    // Map payloads\n    this.getActions()\n      .map(a => a as A)\n      .forEach(action => {\n        let newAction\n\n        if (!filter(action)) {\n          return\n        }\n\n        // needed because we set oldItem in the first section, so we wouldn't know anymore if it was set before\n        const oldItem = action.oldItem\n\n        // We have two sections here, because we want to be able to take IDs from oldItem even for moves\n        // but not parentIds (which do change during moves, obviously)\n\n        if (oldItem && targetLocation !== ItemLocation.SERVER) {\n          const oldId = action.oldItem.id\n          const newId = action.payload.id\n          newAction = {\n            ...action,\n            payload: action.payload.cloneWithLocation(false, targetLocation),\n            oldItem: action.oldItem.cloneWithLocation(false, action.payload.location)\n          }\n          newAction.payload.id = oldId\n          newAction.oldItem.id = newId\n        } else {\n          newAction = {\n            ...action,\n            payload: action.payload.cloneWithLocation(false, targetLocation),\n            oldItem: action.payload.clone(false)\n          }\n          newAction.payload.id = Mappings.mapId(mappingsSnapshot, action.payload, targetLocation)\n        }\n\n        if (oldItem && targetLocation !== ItemLocation.SERVER && action.type !== ActionType.MOVE) {\n          newAction.oldItem.parentId = action.payload.parentId\n          newAction.payload.parentId = Mappings.mapParentId(mappingsSnapshot, action.oldItem, targetLocation)\n        } else {\n          newAction.oldItem.parentId = action.payload.parentId\n          newAction.payload.parentId = Mappings.mapParentId(mappingsSnapshot, action.payload, targetLocation)\n          if (typeof newAction.payload.parentId === 'undefined' && typeof action.payload.parentId !== 'undefined') {\n            if (skipErroneousActions) {\n              // simply ignore this action as it appears to be no longer valid\n              Logger.log('Failed to map parentId: ' + action.payload.parentId)\n              Logger.log('Removing MOVE action from plan:', action)\n              return\n            } else {\n              Logger.log('payload.location = ' + action.payload.location + ' | targetLocation = ' + targetLocation)\n              const diff = new Diff()\n              diff.commit(action)\n              Logger.log('Failed to map parentId of action ' + diff.inspect())\n              Logger.log(JSON.stringify(mappingsSnapshot, null,'\\t'))\n              throw new Error('Failed to map parentId to ' + targetLocation + ': ' + action.payload.parentId)\n            }\n          }\n        }\n\n        if (action.type === ActionType.REORDER) {\n          newAction.oldOrder = action.order\n          newAction.order = action.order.map(item => {\n            return {...item, id: mappingsSnapshot[(targetLocation === ItemLocation.LOCAL ? ItemLocation.SERVER : ItemLocation.LOCAL) + 'To' + targetLocation][item.type][item.id]}\n          })\n        }\n\n        newDiff.commit(newAction)\n      })\n    return newDiff\n  }\n\n  toJSON() {\n    return this.getActions().map((action: A) => {\n      return {\n        ...action,\n        payload: action.payload.clone(false),\n        oldItem: action.oldItem && action.oldItem.clone(false),\n      }\n    })\n  }\n\n  inspect(depth = 0):string {\n    return 'Diff\\n' + this.getActions().map((action: A) => {\n      return `\\nAction: ${action.type}\\nPayload: #${action.payload.id}[${action.payload.title}]${'url' in action.payload ? `(${action.payload.url})` : ''} parentId: ${action.payload.parentId} ${'index' in action ? `Index: ${action.index}\\n` : ''}${'order' in action ? `Order: ${JSON.stringify(action.order, null, '\\t')}` : ''}`\n    }).join('\\n')\n  }\n\n  static fromJSON<L1 extends TItemLocation, L2 extends TItemLocation, A2 extends Action<L1, L2>>(json) {\n    const diff: Diff<L1, L2, A2> = new Diff\n    json.forEach((action: A2): void => {\n      action.payload = hydrate<L1>(action.payload)\n      action.oldItem = action.oldItem && hydrate<L2>(action.oldItem)\n      diff.commit(action)\n    })\n    return diff\n  }\n}\n\nexport interface PlanStage1<L1 extends TItemLocation, L2 extends TItemLocation> {\n  CREATE: Diff<L1, L2, CreateAction<L1, L2>>\n  UPDATE: Diff<L1, L2, UpdateAction<L1, L2>>\n  MOVE: Diff<L1, L2, MoveAction<L1, L2>>\n  REMOVE: Diff<L2, L1, RemoveAction<L2, L1>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n\nexport interface PlanStage2<L1 extends TItemLocation, L2 extends TItemLocation, L3 extends TItemLocation> {\n  CREATE: Diff<L3, L1, CreateAction<L3, L1>>\n  UPDATE: Diff<L3, L1, UpdateAction<L3, L1>>\n  MOVE: Diff<L1, L2, MoveAction<L1, L2>>\n  REMOVE: Diff<L3, L2, RemoveAction<L3, L2>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n\nexport interface PlanStage3<L1 extends TItemLocation, L2 extends TItemLocation, L3 extends TItemLocation> {\n  CREATE: Diff<L3, L1, CreateAction<L3, L1>>\n  UPDATE: Diff<L3, L1, UpdateAction<L3, L1>>\n  MOVE: Diff<L3, L1, MoveAction<L3, L1>>\n  REMOVE: Diff<L3, L2, RemoveAction<L3, L2>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n\nexport interface PlanRevert<L1 extends TItemLocation, L2 extends TItemLocation> {\n  CREATE: Diff<L1, L2, CreateAction<L1, L2>>\n  UPDATE: Diff<L1, L2, UpdateAction<L1, L2>>\n  MOVE: Diff<L2, L1, MoveAction<L2, L1>>\n  REMOVE: Diff<L1, L2, RemoveAction<L1, L2>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n","import browser from '../browser-api'\nimport Logger from '../Logger'\nimport * as Tree from '../Tree'\nimport { IResource } from '../interfaces/Resource'\nimport PQueue from 'p-queue'\nimport Account from '../Account'\nimport { Bookmark, Folder, ItemLocation, ItemType } from '../Tree'\nimport Ordering from '../interfaces/Ordering'\nimport random from 'random'\nimport seedrandom from 'seedrandom'\nimport { isVivaldi } from './BrowserDetection'\nimport { LocalFolderNotFoundError } from '../../errors/Error'\n\nlet absoluteRoot: {id: string}\n\nexport default class BrowserTree implements IResource<typeof ItemLocation.LOCAL> {\n  private readonly rootId: string\n  private queue: PQueue<{ concurrency: 10 }>\n  private storage: unknown\n  private absoluteRoot: { id: string }\n  private absoluteRootPromise: Promise<void>\n\n  static readonly TITLE_BOOKMARKS_BAR: string = 'Bookmarks Bar'\n  static readonly TITLE_OTHER_BOOKMARKS: string = 'Other Bookmarks'\n  static readonly TITLE_BOOKMARKS_MENU: string = 'Bookmarks Menu'\n  static readonly TITLE_MOBILE_BOOKMARKS: string = 'Mobile Bookmarks'\n  static readonly TITLE_SEPARATOR_HORZ: string = ''\n  static readonly TITLE_SEPARATOR_VERT: string = ''\n\n  constructor(storage:unknown, rootId:string) {\n    this.rootId = rootId\n    this.storage = storage\n    this.queue = new PQueue({ concurrency: 10 })\n    this.absoluteRootPromise = BrowserTree.getAbsoluteRootFolder().then(root => {\n      this.absoluteRoot = root\n    })\n  }\n\n  async getBookmarksTree():Promise<Folder<typeof ItemLocation.LOCAL>> {\n    const isVivaldiBrowser = await isVivaldi()\n    let tree\n    try {\n      [tree] = await browser.bookmarks.getSubTree(this.rootId)\n    } catch (e) {\n      throw new LocalFolderNotFoundError()\n    }\n    await this.absoluteRootPromise\n    const allAccounts = await (await Account.getAccountClass()).getAllAccounts()\n\n    const recurse = (node, parentId?, isOnToolbar?, rng?) => {\n      \n      if (\n        allAccounts.some(\n          acc => acc.getData().localRoot === node.id && String(node.id) !== String(this.rootId) && !acc.getData().nestedSync\n        )\n      ) {\n        // This is the root folder of a different account and the user doesn't want nested sync\n        return\n      }\n      let overrideTitle, isRoot, isToolbar\n      if (node.parentId === this.absoluteRoot.id && !isVivaldiBrowser) {\n        switch (node.id) {\n          case '1': // Chrome\n          case 'toolbar_____': // Firefox\n            overrideTitle = BrowserTree.TITLE_BOOKMARKS_BAR\n            isToolbar = true\n            break\n          case '2': // Chrome\n          case 'unfiled_____': // Firefox\n            overrideTitle = BrowserTree.TITLE_OTHER_BOOKMARKS\n            break\n          case 'menu________': // Firefox\n            overrideTitle = BrowserTree.TITLE_BOOKMARKS_MENU\n            break\n          case 'mobile______': // Firefox\n            overrideTitle = BrowserTree.TITLE_MOBILE_BOOKMARKS\n        }\n        if (overrideTitle) {\n          Logger.log(\n            'Overriding title of built-in node',\n            node.id,\n            node.title,\n            '=>',\n            overrideTitle\n          )\n        }\n      }\n      if (node.id === this.absoluteRoot.id) {\n        isRoot = true\n      }\n      if (node.children) {\n        // seeded pseudo random number generator for separator IDs\n        // We use this because we want IDs that are (largely) collision-free even\n        // between folders and still consistent across browsers\n        const rng = random.clone(seedrandom(node.title))\n        const folder = new Tree.Folder({\n          location: ItemLocation.LOCAL,\n          id: node.id,\n          parentId,\n          title: parentId ? overrideTitle || node.title : undefined,\n          children: node.children\n            .map((child) => {\n              return recurse(child, node.id, isToolbar, rng)\n            })\n            .filter(child => !!child) // filter out `undefined` from nested accounts\n        })\n        folder.isRoot = isRoot\n        return folder\n      } else if (self.location.protocol === 'moz-extension:' && node.type === 'separator') {\n        // Translate mozilla separators to floccus separators\n        return new Tree.Bookmark({\n          location: ItemLocation.LOCAL,\n          id: node.id,\n          parentId,\n          title: isOnToolbar ? BrowserTree.TITLE_SEPARATOR_VERT : BrowserTree.TITLE_SEPARATOR_HORZ,\n          // If you have more than a quarter million separators in one folder, call me\n          // Floccus breaks down much earlier atm\n          url: 'https://separator.floccus.org/' +\n               (isOnToolbar ? 'vertical.html' : '') +\n               `?id=${rng.int(0,1000000)}`,\n        })\n      } else {\n        return new Tree.Bookmark({\n          location: ItemLocation.LOCAL,\n          id: node.id,\n          parentId,\n          title: node.title,\n          url: node.url\n        })\n      }\n    }\n    return recurse(tree) as Folder<typeof ItemLocation.LOCAL>\n  }\n\n  async createBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<string|number> {\n    Logger.log('(local)CREATE', bookmark)\n    if (bookmark.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    try {\n      if (self.location.protocol === 'moz-extension:' && new URL(bookmark.url).hostname === 'separator.floccus.org') {\n        const node = await this.queue.add(async() => {\n          Logger.log('(local)CREATE: executing create ', bookmark)\n          return browser.bookmarks.create({\n            parentId: bookmark.parentId.toString(),\n            type: 'separator'\n          })\n        })\n        return node.id\n      }\n      const node = await this.queue.add(async() => {\n        Logger.log('(local)CREATE: executing create ', bookmark)\n        return browser.bookmarks.create({\n          parentId: bookmark.parentId.toString(),\n          title: bookmark.title,\n          url: bookmark.url\n        })\n      })\n      return node.id\n    } catch (e) {\n      throw new Error('Could not create ' + bookmark.inspect() + ': ' + e.message)\n    }\n  }\n\n  async updateBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>):Promise<void> {\n    Logger.log('(local)UPDATE', bookmark)\n    if (bookmark.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    try {\n      if (self.location.protocol === 'moz-extension:' && new URL(bookmark.url).hostname === 'separator.floccus.org') {\n        // noop\n      } else {\n        await this.queue.add(async() => {\n          Logger.log('(local)UPDATE: executing update ', bookmark)\n          return browser.bookmarks.update(bookmark.id, {\n            title: bookmark.title,\n            url: bookmark.url\n          })\n        })\n      }\n      await this.queue.add(async() => {\n        Logger.log('(local)UPDATE: executing move ', bookmark)\n        return browser.bookmarks.move(bookmark.id, {\n          parentId: bookmark.parentId.toString()\n        })\n      })\n    } catch (e) {\n      throw new Error('Could not update ' + bookmark.inspect() + ': ' + e.message)\n    }\n  }\n\n  async removeBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<void> {\n    if (bookmark.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    const bookmarkId = bookmark.id\n    Logger.log('(local)REMOVE', bookmark)\n    try {\n      await this.queue.add(async() => {\n        Logger.log('(local)REMOVE: executing remove ', bookmark)\n        return browser.bookmarks.remove(bookmarkId)\n      })\n    } catch (e) {\n      Logger.log('Could not remove ' + bookmark.inspect() + ': ' + e.message + '\\n Moving on')\n    }\n  }\n\n  async createFolder(folder:Folder<typeof ItemLocation.LOCAL>): Promise<string> {\n    const {parentId, title} = folder\n    Logger.log('(local)CREATEFOLDER', folder)\n    if (folder.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    try {\n      const node = await this.queue.add(async() => {\n        Logger.log('(local)CREATEFOLDER: executing create ', folder)\n        return browser.bookmarks.create({\n          parentId: parentId.toString(),\n          title\n        })\n      })\n      return node.id\n    } catch (e) {\n      throw new Error('Could not create ' + folder.inspect() + ': ' + e.message)\n    }\n  }\n\n  async orderFolder(id:string|number, order:Ordering<typeof ItemLocation.LOCAL>) :Promise<void> {\n    Logger.log('(local)ORDERFOLDER', { id, order })\n    if (id === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    const [realTree] = await browser.bookmarks.getSubTree(id)\n    try {\n      for (let index = 0; index < order.length; index++) {\n        await browser.bookmarks.move(order[index].id, { parentId: id.toString(), index })\n      }\n    } catch (e) {\n      throw new Error('Failed to reorder folder ' + id + ': ' + e.message)\n    }\n    // Move items not touched by sync back to where they were\n    // Not perfect but good enough (Problem: [a,X,c] => insert(b,0) => [b, X, a, c])\n    if (realTree.children.length !== order.length) {\n      const untouchedChildren = realTree.children.map((child,i) => [i, child]).filter(([, child]) =>\n        child.url\n          ? !order.some(item => item.type === ItemType.BOOKMARK && String(item.id) === String(child.id))\n          : !order.some(item => item.type === ItemType.FOLDER && String(item.id) === String(child.id))\n      )\n      try {\n        Logger.log('Move untouched children back into place', {untouchedChildren: untouchedChildren.map(([i, item]) => [i, item.id])})\n        for (const [index, child] of untouchedChildren) {\n          await browser.bookmarks.move(child.id, { parentId: id.toString(), index})\n        }\n      } catch (e) {\n        throw new Error('Failed to reorder folder ' + id + ': ' + e.message)\n      }\n    }\n  }\n\n  async updateFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    const {id, title, parentId} = folder\n    Logger.log('(local)UPDATEFOLDER', folder)\n    if (folder.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects a root folder. Skipping.')\n      return\n    }\n    if (folder.isRoot) {\n      Logger.log('This is the absolute root folder. Skip.')\n      return\n    }\n    try {\n      await this.queue.add(async() => {\n        Logger.log('(local)UPDATEFOLDER: executing update ', folder)\n        return browser.bookmarks.update(id.toString(), {\n          title\n        })\n      })\n    } catch (e) {\n      throw new Error('Failed to rename folder ' + id + ': ' + e.message)\n    }\n    const oldFolder = (await browser.bookmarks.getSubTree(id))[0]\n    if (Folder.hydrate(oldFolder).findFolder(parentId)) {\n      throw new Error('Detected creation of folder loop. Moving ' + id + ' into its descendant ' + parentId)\n    }\n    try {\n      await this.queue.add(async() => {\n        Logger.log('(local)CREATEFOLDER: executing move ', folder)\n        return browser.bookmarks.move(id.toString(), { parentId })\n      })\n    } catch (e) {\n      throw new Error('Failed to move folder ' + id + ': ' + e.message)\n    }\n  }\n\n  async removeFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    const id = folder.id\n    Logger.log('(local)REMOVEFOLDER', id)\n    if (folder.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects a root folder. Skipping.')\n      return\n    }\n    if (folder.isRoot) {\n      Logger.log('This is the root folder. Skip.')\n      return\n    }\n    try {\n      await this.queue.add(async() => {\n        Logger.log('(local)REMOVEFOLDER: executing remove ', folder)\n        return browser.bookmarks.removeTree(id.toString())\n      })\n    } catch (e) {\n      Logger.log('Could not remove ' + folder.inspect() + ': ' + e.message + '\\n Moving on.')\n    }\n  }\n\n  static async getPathFromLocalId(localId:string, ancestors?:string[], relativeToRoot?:string):Promise<string> {\n    if (localId === 'tabs') {\n      return browser.i18n.getMessage('LabelTabs')\n    }\n    try {\n      ancestors = ancestors || (await BrowserTree.getIdPathFromLocalId(localId))\n\n      if (relativeToRoot) {\n        ancestors = ancestors.slice(ancestors.indexOf(relativeToRoot) + 1)\n      }\n\n      return (\n        await Promise.all(\n          ancestors.map(async ancestor => {\n            try {\n              const bms = await browser.bookmarks.get(ancestor)\n              const bm = bms[0]\n              return bm.title.replace(/[/]/g, '\\\\/')\n            } catch (e) {\n              return 'Error!'\n            }\n          })\n        )\n      ).join('/')\n    } catch (e) {\n      return browser.i18n.getMessage('LabelFolderNotFound')\n    }\n  }\n\n  static async getIdPathFromLocalId(localId:string|null, path:string[] = []):Promise<string[]> {\n    if (typeof localId === 'undefined') {\n      return path\n    }\n    path.unshift(localId)\n    const bms = await browser.bookmarks.get(localId)\n    const bm = bms[0]\n    if (bm.parentId === localId) {\n      return path // might be that the root is circular\n    }\n    return this.getIdPathFromLocalId(bm.parentId, path)\n  }\n\n  static async getAbsoluteRootFolder() {\n    if (!absoluteRoot) {\n      try {\n        // chromium\n        absoluteRoot = (await browser.bookmarks.get('0'))[0]\n      } catch (e) {\n        try {\n          // firefox\n          absoluteRoot = (await browser.bookmarks.get('root________'))[0]\n        } catch (e) {\n          // any other browser\n          absoluteRoot = (await browser.bookmarks.getTree())[0]\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          delete absoluteRoot.children\n        }\n      }\n    }\n    return absoluteRoot\n  }\n\n  isAvailable(): Promise<boolean> {\n    return Promise.resolve(true)\n  }\n}\n","import browser from './browser-api'\nimport Logger from './Logger'\nimport { OrderFolderResource } from './interfaces/Resource'\nimport PQueue from 'p-queue'\nimport { Bookmark, Folder, ItemLocation } from './Tree'\nimport Ordering from './interfaces/Ordering'\nimport uniq from 'lodash/uniq'\n\nexport default class LocalTabs implements OrderFolderResource<typeof ItemLocation.LOCAL> {\n  private queue: PQueue<{ concurrency: 10 }>\n  private storage: unknown\n\n  constructor(storage:unknown) {\n    this.storage = storage\n    this.queue = new PQueue({ concurrency: 10 })\n  }\n\n  async getBookmarksTree():Promise<Folder<typeof ItemLocation.LOCAL>> {\n    let tabs = await browser.tabs.query({\n      windowType: 'normal' // no devtools or panels or popups\n    })\n    tabs = tabs.filter(tab => !tab.incognito)\n\n    return new Folder({\n      title: '',\n      id: 'tabs',\n      location: ItemLocation.LOCAL,\n      children: uniq(tabs.map(t => t.windowId)).map((windowId, i) => {\n        return new Folder({\n          title: 'Window ' + i,\n          id: windowId,\n          parentId: 'tabs',\n          location: ItemLocation.LOCAL,\n          children: tabs\n            .filter(t => t.windowId === windowId)\n            .sort((t1,t2) => t1.index - t2.index)\n            .map(t => new Bookmark({\n              id: t.id,\n              title: t.title,\n              url: t.url,\n              parentId: windowId,\n              location: ItemLocation.LOCAL,\n            }))\n        })\n      })\n    })\n  }\n\n  async createBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<string|number> {\n    Logger.log('(tabs)CREATE', bookmark)\n    if (bookmark.parentId === 'tabs') {\n      Logger.log('Parent is \"tabs\", ignoring this one.')\n      return\n    }\n    if (self.location.protocol === 'moz-extension:' && new URL(bookmark.url).protocol === 'file:') {\n      Logger.log('URL is a file URL and we are on firefox, ignoring this one.')\n      return\n    }\n    const node = await this.queue.add(() =>\n      browser.tabs.create({\n        windowId: typeof bookmark.parentId === 'string' ? parseInt(bookmark.parentId) : bookmark.parentId,\n        url: bookmark.url,\n        // Only firefox allows discarded prop\n        ...(typeof browser.BookmarkTreeNodeType !== 'undefined' && { discarded: true }),\n        active: false,\n      })\n    )\n    await awaitTabsUpdated()\n    return node.id\n  }\n\n  async updateBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>):Promise<void> {\n    Logger.log('(tabs)UPDATE', bookmark)\n    if (bookmark.parentId === 'tabs') {\n      Logger.log('Parent is \"tabs\", ignoring this one.')\n      return\n    }\n    await this.queue.add(() =>\n      browser.tabs.update(bookmark.id, {\n        url: bookmark.url\n      })\n    )\n    await this.queue.add(() =>\n      browser.tabs.move(bookmark.id, {\n        windowId: bookmark.parentId,\n        index: -1 // last\n      })\n    )\n    await awaitTabsUpdated()\n  }\n\n  async removeBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<void> {\n    const bookmarkId = bookmark.id\n    Logger.log('(tabs)REMOVE', bookmark)\n    if (bookmark.parentId === 'tabs') {\n      Logger.log('Parent is \"tabs\", ignoring this one.')\n      return\n    }\n    await this.queue.add(() => browser.tabs.remove(bookmarkId))\n    await awaitTabsUpdated()\n  }\n\n  async createFolder(folder:Folder<typeof ItemLocation.LOCAL>): Promise<number> {\n    Logger.log('(tabs)CREATEFOLDER', folder)\n    const node = await this.queue.add(() =>\n      browser.windows.create()\n    )\n    return node.id\n  }\n\n  async orderFolder(id:string|number, order:Ordering<typeof ItemLocation.LOCAL>):Promise<void> {\n    Logger.log('(tabs)ORDERFOLDER', { id, order })\n    const originalTabs = await browser.tabs.query({\n      windowId: id\n    })\n    try {\n      for (let index = 0; index < order.length; index++) {\n        await browser.tabs.move(order[index].id, { index })\n      }\n    } catch (e) {\n      throw new Error('Failed to reorder folder ' + id + ': ' + e.message)\n    }\n    // Move items not touched by sync back to where they were\n    // Not perfect but good enough (Problem: [a,X,c] => insert(b,0) => [b, X, a, c])\n    if (originalTabs.length !== order.length) {\n      const untouchedChildren = originalTabs.map((tab, i) => [i, tab]).filter(([, tab]) =>\n        !order.some(item => String(tab.id) === String(item.id))\n      )\n      try {\n        for (const [index, child] of untouchedChildren) {\n          await browser.tabs.move(child.id, {index})\n        }\n      } catch (e) {\n        throw new Error('Failed to reorder folder ' + id + ': ' + e.message)\n      }\n    }\n    await awaitTabsUpdated()\n  }\n\n  async updateFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    Logger.log('(tabs)UPDATEFOLDER (noop)', folder)\n  }\n\n  async removeFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    const id = folder.id\n    Logger.log('(tabs)REMOVEFOLDER', id)\n    await this.queue.add(() => browser.window.remove(id))\n  }\n\n  async isAvailable(): Promise<boolean> {\n    const tabs = await browser.tabs.query({\n      windowType: 'normal' // no devtools or panels or popups\n    })\n    return Boolean(tabs.length)\n  }\n}\n\nfunction awaitTabsUpdated() {\n  return Promise.race([\n    new Promise<void>(resolve => {\n      browser.tabs.onUpdated.addListener(function listener() {\n        browser.tabs.onUpdated.removeListener(listener)\n        setTimeout(() => resolve(), 100)\n      })\n    }),\n    new Promise(resolve => setTimeout(resolve, 300))\n  ])\n}\n","import * as Parallel from 'async-parallel'\nimport Diff, { ActionType, CreateAction, MoveAction, RemoveAction, ReorderAction, UpdateAction } from './Diff'\nimport { Bookmark, Folder, ItemLocation, ItemType, TItem, TItemLocation } from './Tree'\nimport Logger from './Logger'\n\nexport interface ScanResult<L1 extends TItemLocation, L2 extends TItemLocation> {\n  CREATE: Diff<L1, L2, CreateAction<L1, L2>>\n  UPDATE: Diff<L1, L2, UpdateAction<L1, L2>>\n  MOVE: Diff<L1, L2, MoveAction<L1, L2>>\n  REMOVE: Diff<L2, L1, RemoveAction<L2, L1>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n\nexport default class Scanner<L1 extends TItemLocation, L2 extends TItemLocation> {\n  private oldTree: TItem<L1>\n  private newTree: TItem<L2>\n  private mergeable: (i1: TItem<TItemLocation>, i2: TItem<TItemLocation>) => boolean\n  private preserveOrder: boolean\n  private checkHashes: boolean\n  private hasCache: boolean\n\n  private result: ScanResult<L2, L1>\n\n  constructor(oldTree:TItem<L1>, newTree:TItem<L2>, mergeable:(i1:TItem<TItemLocation>, i2:TItem<TItemLocation>)=>boolean, preserveOrder:boolean, checkHashes = true, hasCache = true) {\n    this.oldTree = oldTree\n    this.newTree = newTree\n    this.mergeable = mergeable\n    this.preserveOrder = preserveOrder\n    this.checkHashes = typeof checkHashes === 'undefined' ? true : checkHashes\n    this.hasCache = hasCache\n    this.result = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: new Diff(),\n    }\n  }\n\n  getDiffs(): ScanResult<L2, L1> {\n    return this.result\n  }\n\n  async run():Promise<ScanResult<L2, L1>> {\n    await this.diffItem(this.oldTree, this.newTree)\n    await this.findMoves()\n    await this.addReorders()\n    return this.result\n  }\n\n  async diffItem(oldItem:TItem<L1>, newItem:TItem<L2>):Promise<void> {\n    // give the browser time to breathe\n    await Promise.resolve()\n    Logger.log('Calculating diff for ', oldItem, newItem)\n    if (oldItem.type === 'folder' && newItem.type === 'folder') {\n      return this.diffFolder(oldItem, newItem)\n    } else if (oldItem.type === 'bookmark' && newItem.type === 'bookmark') {\n      return this.diffBookmark(oldItem, newItem)\n    } else {\n      throw new Error('Mismatched diff items: ' + oldItem.type + ', ' + newItem.type)\n    }\n  }\n\n  async diffFolder(oldFolder:Folder<L1>, newFolder:Folder<L2>):Promise<void> {\n    if (this.checkHashes) {\n      const hasChanged = await this.folderHasChanged(oldFolder, newFolder)\n      if (!hasChanged) {\n        return\n      }\n    }\n\n    if (oldFolder.title !== newFolder.title && typeof oldFolder.parentId !== 'undefined' && typeof newFolder.parentId !== 'undefined') {\n      // folder title changed and it's not the root folder\n      this.result.UPDATE.commit({type: ActionType.UPDATE, payload: newFolder, oldItem: oldFolder})\n    }\n\n    // Preserved Items and removed Items\n    // (using map here, because 'each' doesn't provide indices)\n    const unmatchedChildren = newFolder.children.slice(0)\n    await Parallel.map(oldFolder.children, async(old, index) => {\n      const newItem = unmatchedChildren.find((child) => old.type === child.type && this.mergeable(old, child))\n      // we found an item in the new folder that matches the one in the old folder\n      if (newItem) {\n        await this.diffItem(old, newItem)\n        unmatchedChildren.splice(unmatchedChildren.indexOf(newItem), 1)\n        return\n      }\n\n      if (newFolder.isRoot && newFolder.location === ItemLocation.LOCAL) {\n        // We can't remove root folders locally\n        return\n      }\n\n      this.result.REMOVE.commit({type: ActionType.REMOVE, payload: old, index})\n    }, 1)\n\n    // created Items\n    // (using map here, because 'each' doesn't provide indices)\n    await Parallel.map(unmatchedChildren, async(newChild, index) => {\n      if (oldFolder.isRoot && oldFolder.location === ItemLocation.LOCAL) {\n        // We can't create root folders locally\n        return\n      }\n      this.result.CREATE.commit({type: ActionType.CREATE, payload: newChild, index})\n    }, 1)\n\n    if (newFolder.children.length > 1) {\n      this.result.REORDER.commit({\n        type: ActionType.REORDER,\n        payload: newFolder,\n        order: newFolder.children.map(i => ({ type: i.type, id: i.id })),\n      })\n    }\n  }\n\n  async diffBookmark(oldBookmark:Bookmark<L1>, newBookmark:Bookmark<L2>):Promise<void> {\n    let hasChanged\n    if (this.checkHashes) {\n      hasChanged = await this.bookmarkHasChanged(oldBookmark, newBookmark)\n    } else {\n      hasChanged = oldBookmark.title !== newBookmark.title || oldBookmark.url !== newBookmark.url\n    }\n    if (hasChanged) {\n      this.result.UPDATE.commit({ type: ActionType.UPDATE, payload: newBookmark, oldItem: oldBookmark })\n    }\n  }\n\n  async bookmarkHasChanged(oldBookmark:Bookmark<L1>, newBookmark:Bookmark<L2>):Promise<boolean> {\n    const oldHash = await oldBookmark.hash()\n    const newHash = await newBookmark.hash()\n    return oldHash !== newHash\n  }\n\n  async folderHasChanged(oldFolder:Folder<L1>, newFolder:Folder<L2>):Promise<boolean> {\n    const oldHash = await oldFolder.hash(this.preserveOrder)\n    const newHash = await newFolder.hash(this.preserveOrder)\n    return oldHash !== newHash\n  }\n\n  async findMoves():Promise<void> {\n    Logger.log('Scanner: Finding moves')\n    let createActions\n    let removeActions\n    let reconciled = true\n\n    // As soon as one match is found, action list is updated and search is started with the new list\n    // repeat until no rewrites happen anymore\n    while (reconciled) {\n      reconciled = false\n      let createAction: CreateAction<L2, L1>, removeAction: RemoveAction<L1,L2>\n\n      // First find direct matches (avoids glitches when folders and their contents have been moved)\n      createActions = this.result.CREATE.getActions()\n      while (!reconciled && (createAction = createActions.shift())) {\n        // give the browser time to breathe\n        await Promise.resolve()\n        const createdItem = createAction.payload\n        removeActions = this.result.REMOVE.getActions()\n        while (!reconciled && (removeAction = removeActions.shift())) {\n          // give the browser time to breathe\n          await Promise.resolve()\n          const removedItem = removeAction.payload\n\n          if (this.mergeable(removedItem, createdItem) &&\n            (removedItem.type !== 'folder' ||\n              (!this.hasCache && removedItem.childrenSimilarity(createdItem) > 0.8))) {\n            this.result.CREATE.retract(createAction)\n            this.result.REMOVE.retract(removeAction)\n            this.result.MOVE.commit({\n              type: ActionType.MOVE,\n              payload: createdItem,\n              oldItem: removedItem,\n              index: createAction.index,\n              oldIndex: removeAction.index\n            })\n            reconciled = true\n            // Don't use the items from the action, but the ones in the actual tree to avoid using tree parts mutated by this algorithm (see below)\n            await this.diffItem(removedItem, createdItem)\n          }\n        }\n      }\n\n      // Then find descendant matches\n      createActions = this.result.CREATE.getActions()\n      while (!reconciled && (createAction = createActions.shift())) {\n        // give the browser time to breathe\n        await Promise.resolve()\n        const createdItem = createAction.payload\n        removeActions = this.result.REMOVE.getActions()\n        while (!reconciled && (removeAction = removeActions.shift())) {\n          // give the browser time to breathe\n          await Promise.resolve()\n          const removedItem = removeAction.payload\n          const oldItem = removedItem.findItemFilter(\n            createdItem.type,\n            item => this.mergeable(item, createdItem),\n            item => item.childrenSimilarity(createdItem)\n          )\n          if (oldItem) {\n            let oldIndex\n            this.result.CREATE.retract(createAction)\n            if (oldItem === removedItem) {\n              this.result.REMOVE.retract(removeAction)\n            } else {\n              // We clone the item here, because we don't want to mutate all copies of this tree (item)\n              const removedItemClone = removedItem.clone(true)\n              const oldParentClone = removedItemClone.findItem(ItemType.FOLDER, oldItem.parentId) as Folder<L1>\n              const oldItemClone = removedItemClone.findItem(oldItem.type, oldItem.id)\n              oldIndex = oldParentClone.children.indexOf(oldItemClone)\n              oldParentClone.children.splice(oldIndex, 1)\n              removeAction.payload = removedItemClone\n              removeAction.payload.createIndex()\n            }\n            this.result.MOVE.commit({\n              type: ActionType.MOVE,\n              payload: createdItem,\n              oldItem,\n              index: createAction.index,\n              oldIndex: oldIndex || removeAction.index\n            })\n            reconciled = true\n            if (oldItem.type === ItemType.FOLDER) { // TODO: Is this necessary?\n              await this.diffItem(oldItem, createdItem)\n            }\n          } else {\n            const newItem = createdItem.findItemFilter(\n              removedItem.type,\n              item => this.mergeable(removedItem, item),\n              item => item.childrenSimilarity(removedItem)\n            )\n            let index\n            if (newItem) {\n              this.result.REMOVE.retract(removeAction)\n              if (newItem === createdItem) {\n                this.result.CREATE.retract(createAction)\n              } else {\n                // We clone the item here, because we don't want to mutate all copies of this tree (item)\n                const createdItemClone = createdItem.clone(true)\n                const newParentClone = createdItemClone.findItem(ItemType.FOLDER, newItem.parentId) as Folder<L2>\n                const newClonedItem = createdItemClone.findItem(newItem.type, newItem.id)\n                index = newParentClone.children.indexOf(newClonedItem)\n                newParentClone.children.splice(index, 1)\n                createAction.payload = createdItemClone\n                createAction.payload.createIndex()\n              }\n              this.result.MOVE.commit({\n                type: ActionType.MOVE,\n                payload: newItem,\n                oldItem: removedItem,\n                index: index || createAction.index,\n                oldIndex: removeAction.index\n              })\n              reconciled = true\n              if (removedItem.type === ItemType.FOLDER) {\n                await this.diffItem(removedItem, newItem)\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Remove all UPDATEs that have already been handled by a MOVE\n    const moves = this.result.MOVE.getActions()\n    const updates = this.result.UPDATE.getActions()\n    updates.forEach(update => {\n      if (moves.find(move => String(move.payload.id) === String(update.payload.id))) {\n        this.result.UPDATE.retract(update)\n      }\n    })\n  }\n\n  async addReorders(): Promise<void> {\n    Logger.log('Scanner: Generate reorders')\n    const targets = {}\n    const sources = {}\n\n    // Collect folders to reorder\n    this.result.CREATE.getActions()\n      .forEach(action => {\n        targets[action.payload.parentId] = true\n      })\n    this.result.REMOVE.getActions()\n      .forEach(action => {\n        sources[action.payload.parentId] = true\n      })\n    this.result.MOVE.getActions()\n      .forEach(action => {\n        targets[action.payload.parentId] = true\n        sources[action.oldItem.parentId] = true\n      })\n\n    for (const folderId in sources) {\n      const oldFolder = this.oldTree.findItem(ItemType.FOLDER, folderId) as Folder<L1>\n      if (!oldFolder) {\n        // In case a MOVE's old parent was removed\n        continue\n      }\n      const newFolder = this.newTree.findItemFilter(ItemType.FOLDER, (item) => this.mergeable(oldFolder, item)) as Folder<L2>\n      if (newFolder) {\n        targets[newFolder.id] = true\n      }\n    }\n\n    for (const folderId in targets) {\n      const newFolder = this.newTree.findItem(ItemType.FOLDER, folderId) as Folder<L2>\n      const duplicate = this.result.REORDER.getActions().find(a => String(a.payload.id) === String(newFolder.id))\n      if (duplicate) {\n        this.result.REORDER.retract(duplicate)\n      }\n      this.result.REORDER.commit({\n        type: ActionType.REORDER,\n        payload: newFolder,\n        order: newFolder.children.map(i => ({ type: i.type, id: i.id })),\n      })\n    }\n  }\n}\n","import { Preferences as Storage } from '@capacitor/preferences'\nimport { Network } from '@capacitor/network'\nimport Cryptography from '../Crypto'\nimport NativeAccountStorage from './NativeAccountStorage'\nimport Account from '../Account'\nimport { STATUS_ALLGOOD, STATUS_DISABLED, STATUS_ERROR, STATUS_SYNCING } from '../interfaces/Controller'\n\nconst INACTIVITY_TIMEOUT = 1000 * 7\nconst MAX_BACKOFF_INTERVAL = 1000 * 60 * 60 // 1 hour\nconst DEFAULT_SYNC_INTERVAL = 15\n\nclass AlarmManager {\n  constructor(ctl) {\n    this.ctl = ctl\n    this.backgroundSyncEnabled = true\n    setInterval(() => this.checkSync(), 25 * 1000)\n\n    Network.addListener('networkStatusChange', status => {\n      if (status.connected) {\n        this.backgroundSyncEnabled = true\n      } else {\n        this.backgroundSyncEnabled = false\n      }\n    })\n  }\n\n  async checkSync() {\n    if (!this.backgroundSyncEnabled) {\n      return\n    }\n    const accounts = await NativeAccountStorage.getAllAccounts()\n    for (let accountId of accounts) {\n      const account = await Account.get(accountId)\n      const data = account.getData()\n      const lastSync = data.lastSync || 0\n      const interval = data.syncInterval || DEFAULT_SYNC_INTERVAL\n      if (data.scheduled) {\n        this.ctl.scheduleSync(accountId)\n        continue\n      }\n      if (data.error && data.errorCount > 1) {\n        if (Date.now() > this.getBackoffInterval(interval, data.errorCount, lastSync) + lastSync) {\n          this.ctl.scheduleSync(accountId)\n          continue\n        }\n        continue\n      }\n      if (\n        Date.now() >\n        interval * 1000 * 60 + data.lastSync\n      ) {\n        this.ctl.scheduleSync(accountId)\n      }\n    }\n  }\n\n  /**\n   * Calculates the backoff interval based on the synchronization interval and the error count.\n   *\n   * This method determines the delay before retrying a synchronization\n   * after one or more errors have occurred. It uses an exponential\n   * backoff algorithm with a cap at the maximum backoff interval.\n   *\n   * @param {number} interval - The synchronization interval in minutes.\n   * @param {number} errorCount - The number of consecutive errors encountered.\n   * @param {number} lastSync - The timestamp of when the last successful sync happened.\n   * @returns {number} - The calculated backoff interval in milliseconds.\n   */\n  getBackoffInterval(interval, errorCount, lastSync) {\n    const maxErrorCount = Math.log2(MAX_BACKOFF_INTERVAL / (interval * 1000 * 60))\n    if (errorCount < maxErrorCount || lastSync + MAX_BACKOFF_INTERVAL > Date.now()) {\n      return Math.min(MAX_BACKOFF_INTERVAL, interval * 1000 * 60 * Math.pow(2, errorCount))\n    } else {\n      return MAX_BACKOFF_INTERVAL + MAX_BACKOFF_INTERVAL * (errorCount - maxErrorCount)\n    }\n  }\n}\n\nexport default class NativeController {\n  constructor() {\n    this.schedule = {}\n    this.listeners = []\n\n    this.alarms = new AlarmManager(this)\n\n    // lock accounts when locking is enabled\n\n    Storage.get({key: 'accountsLocked' }).then(async({value: accountsLocked}) => {\n      this.setEnabled(!accountsLocked)\n      this.unlocked = !accountsLocked\n      if (accountsLocked) {\n        this.key = null\n      }\n    })\n  }\n\n  setEnabled(enabled) {\n    this.enabled = enabled\n  }\n\n  async unlock(key) {\n    let accountsLocked = await Storage.get({ key: 'accountsLocked' })\n    if (accountsLocked) {\n      let hashedKey = await Cryptography.sha256(key)\n      let decryptedHash = await Cryptography.decryptAES(\n        key,\n        accountsLocked,\n        'FLOCCUS'\n      )\n\n      if (decryptedHash !== hashedKey) {\n        throw new Error('The provided key was wrong')\n      }\n      this.key = key\n    }\n    this.unlocked = true\n    this.setEnabled(true)\n  }\n\n  getUnlocked() {\n    return Promise.resolve(this.unlocked)\n  }\n\n  async scheduleAll() {\n    const accounts = await Account.getAllAccounts()\n    for (const account of accounts) {\n      this.scheduleSync(account.id)\n    }\n  }\n\n  async scheduleSync(accountId, wait) {\n    if (wait) {\n      if (this.schedule[accountId]) {\n        clearTimeout(this.schedule[accountId])\n      }\n      this.schedule[accountId] = setTimeout(\n        () => this.scheduleSync(accountId),\n        INACTIVITY_TIMEOUT\n      )\n      return\n    }\n\n    let account = await Account.get(accountId)\n    if (account.getData().syncing) {\n      return\n    }\n    // if the account is already scheduled, don't prevent it, to avoid getting stuck\n    if (!account.getData().enabled && !account.getData().scheduled) {\n      return\n    }\n\n    const status = await this.getStatus()\n    if (status === STATUS_SYNCING) {\n      await account.setData({ scheduled: account.getData().scheduled || true })\n      return\n    }\n\n    if (account.getData().scheduled === true) {\n      await this.syncAccount(accountId)\n    } else {\n      await this.syncAccount(accountId, account.getData().scheduled)\n    }\n  }\n\n  async cancelSync(accountId, keepEnabled) {\n    let account = await Account.get(accountId)\n    // Avoid starting it again automatically\n    if (!keepEnabled) {\n      await account.setData({ enabled: false })\n    }\n    await account.cancelSync()\n  }\n\n  async syncAccount(accountId, strategy, forceSync = false) {\n    if (!this.enabled) {\n      return\n    }\n    let account = await Account.get(accountId)\n    if (account.getData().syncing) {\n      return\n    }\n    setTimeout(() => this.updateStatus(), 500)\n    try {\n      await account.sync(strategy, forceSync)\n    } catch (error) {\n      console.error(error)\n    }\n    this.updateStatus()\n  }\n\n  async updateStatus() {\n    this.listeners.forEach(fn => fn())\n  }\n\n  async getStatus() {\n    if (!this.unlocked) {\n      return STATUS_ERROR\n    }\n    const accounts = await Account.getAllAccounts()\n    let overallStatus = accounts.reduce((status, account) => {\n      const accData = account.getData()\n      if (status === STATUS_SYNCING || accData.syncing) {\n        return STATUS_SYNCING\n      } else if (status === STATUS_ERROR || (accData.error && !accData.syncing)) {\n        return STATUS_ERROR\n      } else {\n        return STATUS_ALLGOOD\n      }\n    }, STATUS_ALLGOOD)\n\n    if (overallStatus === STATUS_ALLGOOD) {\n      if (accounts.every(account => !account.getData().enabled)) {\n        overallStatus = STATUS_DISABLED\n      }\n    }\n\n    return overallStatus\n  }\n\n  onStatusChange(listener) {\n    this.listeners.push(listener)\n    let unregistered = false\n    return () => {\n      if (unregistered) return\n      this.listeners.splice(this.listeners.indexOf(listener), 1)\n      unregistered = true\n    }\n  }\n\n  async onLoad() {\n    const accounts = await Account.getAllAccounts()\n    await Promise.all(\n      accounts.map(async acc => {\n        if (acc.getData().syncing) {\n          await acc.setData({\n            syncing: false,\n            scheduled: false,\n          })\n        }\n      })\n    )\n  }\n}\n\nlet singleton\nNativeController.getSingleton = function() {\n  if (!singleton) {\n    singleton = new NativeController()\n  }\n  return singleton\n}\n","// Nextcloud ADAPTER\n// All owncloud specifc stuff goes in here\nimport { Capacitor, CapacitorHttp as Http } from '@capacitor/core'\nimport Adapter from '../interfaces/Adapter'\nimport HtmlSerializer from '../serializers/Html'\nimport Logger from '../Logger'\nimport { Bookmark, Folder, ItemLocation, TItem } from '../Tree'\nimport { Base64 } from 'js-base64'\nimport AsyncLock from 'async-lock'\nimport * as Parallel from 'async-parallel'\nimport PQueue from 'p-queue'\nimport flatten from 'lodash/flatten'\nimport {\n  BulkImportResource,\n  ClickCountResource,\n  LoadFolderChildrenResource,\n  OrderFolderResource\n} from '../interfaces/Resource'\nimport Ordering from '../interfaces/Ordering'\nimport {\n  AuthenticationError, CreateBookmarkError,\n  HttpError, CancelledSyncError,\n  MissingPermissionsError,\n  NetworkError,\n  ParseResponseError,\n  RedirectError,\n  RequestTimeoutError, ResourceLockedError,\n  UnexpectedServerResponseError,\n  UnknownCreateTargetError,\n  UnknownFolderParentUpdateError,\n  UnknownFolderUpdateError,\n  UnknownMoveTargetError, UpdateBookmarkError\n} from '../../errors/Error'\n\nconst PAGE_SIZE = 300\nconst TIMEOUT = 300000\n\nexport interface NextcloudBookmarksConfig {\n  type: 'nextcloud-folders'|'nextcloud-bookmarks'\n  url: string\n  username: string\n  password: string\n  serverRoot?: string\n  includeCredentials?: boolean\n  allowRedirects?: boolean\n  allowNetwork?: boolean\n  label?: string\n}\n\ninterface IChildFolder {\n  id: string|number\n  title: string\n  parentId?: string|number\n  children?: IChildFolder[]\n}\n\ninterface IChildOrderItem {\n  type: 'bookmark' | 'folder'\n  id: string|number\n  children?: IChildOrderItem[]\n}\n\nconst LOCK_INTERVAL = 2 * 60 * 1000 // Set lock every two minutes while syncing\n\nexport default class NextcloudBookmarksAdapter implements Adapter, BulkImportResource<typeof ItemLocation.SERVER>, LoadFolderChildrenResource<typeof ItemLocation.SERVER>, OrderFolderResource<typeof ItemLocation.SERVER>, ClickCountResource<typeof ItemLocation.SERVER> {\n  private server: NextcloudBookmarksConfig\n  private fetchQueue: PQueue<{ concurrency: 12 }>\n  private bookmarkLock: AsyncLock\n  public hasFeatureBulkImport:boolean = null\n  private list: Bookmark<typeof ItemLocation.SERVER>[]\n  private tree: Folder<typeof ItemLocation.SERVER>\n  private abortController: AbortController\n  private abortSignal: AbortSignal\n  private canceled = false\n  private cancelCallback: () => void = null\n  private lockingInterval: any\n  private lockingPromise: Promise<boolean>\n  private ended = false\n  private locked = false\n  private hasFeatureJavascriptLinks: boolean = null\n\n  constructor(server: NextcloudBookmarksConfig) {\n    this.server = server\n    this.fetchQueue = new PQueue({ concurrency: 12 })\n    this.bookmarkLock = new AsyncLock()\n    this.abortController = new AbortController()\n    this.abortSignal = this.abortController.signal\n  }\n\n  static getDefaultValues(): NextcloudBookmarksConfig {\n    return {\n      type: 'nextcloud-bookmarks',\n      url: 'https://example.org',\n      username: 'bob',\n      password: 's3cret',\n      serverRoot: '',\n      includeCredentials: false,\n      allowRedirects: false,\n      allowNetwork: false,\n    }\n  }\n\n  setData(data:NextcloudBookmarksConfig):void {\n    this.server = { ...data }\n  }\n\n  getData():NextcloudBookmarksConfig {\n    return { ...NextcloudBookmarksAdapter.getDefaultValues(), ...this.server }\n  }\n\n  getLabel():string {\n    const data = this.getData()\n    return data.label || (data.username.includes('@') ? data.username + ' on ' + new URL(data.url).hostname : data.username + '@' + new URL(data.url).hostname)\n  }\n\n  acceptsBookmark(bm: Bookmark<typeof ItemLocation.SERVER>):boolean {\n    try {\n      return Boolean(~['https:', 'http:', 'ftp:'].concat(this.hasFeatureJavascriptLinks ? ['javascript:'] : []).indexOf(new URL(bm.url).protocol))\n    } catch (e) {\n      return false\n    }\n  }\n\n  normalizeServerURL(input:string):string {\n    const serverURL = new URL(input)\n    const indexLoc = serverURL.pathname.indexOf('index.php')\n    if (!serverURL.pathname) serverURL.pathname = ''\n    serverURL.search = ''\n    serverURL.hash = ''\n    serverURL.pathname = serverURL.pathname.substring(0, ~indexLoc ? indexLoc : undefined)\n    const output = serverURL.toString()\n    return output + (output[output.length - 1] !== '/' ? '/' : '')\n  }\n\n  async onSyncStart(needLock = true, forceLock = false): Promise<void> {\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../browser-api')).default\n      let hasPermissions, error = false\n      try {\n        hasPermissions = await browser.permissions.contains({ origins: [this.server.url + '/'] })\n      } catch (e) {\n        error = true\n        console.warn(e)\n      }\n      if (!error && !hasPermissions) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    await this.checkFeatureJavascriptLinks()\n\n    this.abortController = new AbortController()\n    this.abortSignal = this.abortController.signal\n\n    if (this.lockingInterval) {\n      clearInterval(this.lockingInterval)\n    }\n\n    // if needLock -- we always need it\n    this.locked = await this.acquireLock()\n    if (forceLock) {\n      this.locked = true\n    } else if (!this.locked) {\n      throw new ResourceLockedError()\n    }\n    this.lockingInterval = setInterval(() => !this.ended && this.acquireLock(), LOCK_INTERVAL)\n\n    this.canceled = false\n    this.ended = false\n  }\n\n  async onSyncComplete(): Promise<void> {\n    this.ended = true\n    clearInterval(this.lockingInterval)\n    await this.releaseLock()\n  }\n\n  async onSyncFail(): Promise<void> {\n    this.ended = true\n    clearInterval(this.lockingInterval)\n    await this.releaseLock()\n  }\n\n  cancel() {\n    this.canceled = true\n    this.fetchQueue.clear()\n    this.abortController.abort()\n    this.cancelCallback && this.cancelCallback()\n  }\n\n  async getBookmarksList():Promise<Bookmark<typeof ItemLocation.SERVER>[]> {\n    return this.bookmarkLock.acquire('list', async() => {\n      if (this.list) {\n        return this.list\n      }\n\n      Logger.log('Fetching bookmarks')\n      let i = 0\n      let data = []\n      let json\n      do {\n        json = await this.sendRequest(\n          'GET',\n          `index.php/apps/bookmarks/public/rest/v2/bookmark?page=${i}&limit=${PAGE_SIZE}`\n        )\n        if (!Array.isArray(json.data)) {\n          throw new UnexpectedServerResponseError()\n        }\n        data = data.concat(json.data)\n        i++\n      } while (json.data.length === PAGE_SIZE)\n\n      const bookmarks = flatten(\n        data.map((bm) => {\n          const bookmark = {\n            id: bm.id as number | string,\n            url: (bm.target || bm.url) as string,\n            title: bm.title as string,\n            parentId: null,\n            location: ItemLocation.SERVER,\n          }\n\n          return bm.folders.map((parentId) => {\n            const b = { ...bookmark }\n            b.parentId = parentId\n            return new Bookmark(b)\n          })\n        })\n      )\n\n      Logger.log('Received bookmarks from server', bookmarks)\n      this.list = bookmarks\n      return bookmarks\n    })\n  }\n\n  async getBookmarksTree(loadAll = false):Promise<Folder<typeof ItemLocation.SERVER>> {\n    this.list = null // clear cache before starting a new sync\n\n    if (!loadAll) {\n      return this.getSparseBookmarksTree()\n    } else {\n      return this.getCompleteBookmarksTree()\n    }\n  }\n\n  async _getChildFolders(folderId:string|number, layers = 0):Promise<IChildFolder[]> {\n    const folderJson = await this.sendRequest(\n      'GET',\n      `index.php/apps/bookmarks/public/rest/v2/folder?root=${folderId}&layers=${layers}`\n    )\n    if (!Array.isArray(folderJson.data)) {\n      throw new UnexpectedServerResponseError()\n    }\n    return folderJson.data\n  }\n\n  async _findServerRoot():Promise<Folder<typeof ItemLocation.SERVER>> {\n    let tree = new Folder({ id: -1, location: ItemLocation.SERVER })\n    let childFolders\n    await Parallel.each(\n      this.server.serverRoot.split('/').slice(1),\n      async(segment) => {\n        childFolders = (tree.children && tree.children.length) ? tree.children : (await this._getChildFolders(tree.id))\n        let currentChild = childFolders.find(\n          (folder) => folder.title === segment\n        )\n        if (!currentChild) {\n          // create folder\n          const body = {\n            parent_folder: tree.id,\n            title: segment,\n          }\n          const json = await this.sendRequest(\n            'POST',\n            'index.php/apps/bookmarks/public/rest/v2/folder',\n            'application/json',\n            body\n          )\n          if (typeof json.item !== 'object') {\n            throw new UnexpectedServerResponseError()\n          }\n          currentChild = { id: json.item.id, children: [], title: json.item.title }\n        }\n        tree = new Folder({ id: currentChild.id, title: currentChild.title, location: ItemLocation.SERVER })\n      },\n      1\n    )\n    return tree\n  }\n\n  async getCompleteBookmarksTree():Promise<Folder<typeof ItemLocation.SERVER>> {\n    let tree = new Folder({ id: -1, location: ItemLocation.SERVER })\n    if (this.server.serverRoot) {\n      tree = await this._findServerRoot()\n    }\n\n    tree.children = await this._getChildren(tree.id, -1)\n    this.tree = tree\n    return tree.clone()\n  }\n\n  async getSparseBookmarksTree() :Promise<Folder<typeof ItemLocation.SERVER>> {\n    let tree = new Folder({ id: -1, location: ItemLocation.SERVER })\n\n    if (this.server.serverRoot) {\n      tree = await this._findServerRoot()\n    }\n\n    this.list = null\n    tree.loaded = false\n    tree.hashValue = { true: await this._getFolderHash(tree.id) }\n    this.tree = tree.clone(true) // we clone (withHash), so we can mess with our own version\n    return tree\n  }\n\n  async _getFolderHash(folderId:string|number):Promise<string> {\n    return this.sendRequest(\n      'GET',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${folderId}/hash`\n    )\n      .catch(() => {\n        return { data: '0' } // fallback\n      })\n      .then((json) => {\n        return json.data\n      })\n  }\n\n  async _getChildren(folderId:string|number, layers:number):Promise<TItem<typeof ItemLocation.SERVER>[]> {\n    const childrenJson = await this.sendRequest(\n      'GET',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${folderId}/children?layers=${layers}`\n    )\n    const children = childrenJson.data\n    const recurseChildren = (folderId, children) => {\n      return children.map((item) => {\n        if (item.type === 'bookmark') {\n          if ('target' in item && this.hasFeatureJavascriptLinks === null) {\n            this.hasFeatureJavascriptLinks = true\n          }\n          return new Bookmark({\n            id: item.id + ';' + folderId,\n            title: item.title,\n            parentId: folderId,\n            url: item.target || item.url,\n            location: ItemLocation.SERVER,\n          })\n        } else if (item.type === 'folder') {\n          const childFolder = new Folder({\n            id: item.id,\n            parentId: folderId,\n            title: item.title,\n            location: ItemLocation.SERVER,\n          })\n          childFolder.loaded = Boolean(item.children) // not children.length but whether the whole children field exists\n          childFolder.children = recurseChildren(item.id, item.children || [])\n          return childFolder\n        }\n      })\n    }\n    return recurseChildren(folderId, children)\n  }\n\n  async loadFolderChildren(folderId:string|number, all?: boolean): Promise<TItem<typeof ItemLocation.SERVER>[]> {\n    const folder = this.tree.findFolder(folderId)\n    if (!folder) {\n      throw new Error('Could not find folder for loadFolderChildren')\n    }\n    if (folder.loaded) {\n      return folder.clone(true).children\n    }\n    let children\n    if (all) {\n      children = await this._getChildren(folderId, -1)\n    } else {\n      children = await this._getChildren(folderId, 1)\n      const recurse = async(children) => {\n        return Parallel.each(children, async(child) => {\n          if (!(child instanceof Folder)) {\n            return\n          }\n          if (!child.loaded) {\n            const folderHash = await this._getFolderHash(child.id)\n            child.hashValue = { true: folderHash }\n          }\n          await recurse(child.children)\n        }, 5)\n      }\n      await recurse(children)\n    }\n    folder.children = children\n    folder.loaded = true\n    this.tree.createIndex()\n    return folder.clone(true).children\n  }\n\n  async createFolder(folder:Folder<typeof ItemLocation.SERVER>):Promise<string|number> {\n    Logger.log('(nextcloud-folders)CREATEFOLDER', {folder})\n    const parentId = folder.parentId\n    const title = folder.title\n\n    const parentFolder = this.tree.findFolder(parentId)\n    if (!parentFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    const body = {\n      parent_folder: parentId,\n      title: title,\n    }\n    const json = await this.sendRequest(\n      'POST',\n      'index.php/apps/bookmarks/public/rest/v2/folder',\n      'application/json',\n      body\n    )\n    if (typeof json.item !== 'object') {\n      throw new UnexpectedServerResponseError()\n    }\n\n    parentFolder.children.push(\n      new Folder({ id: json.item.id, title, parentId, location: ItemLocation.SERVER })\n    )\n    this.tree.createIndex()\n    return json.item.id\n  }\n\n  async bulkImportFolder(parentId:string|number, folder:Folder<typeof ItemLocation.SERVER>):Promise<Folder<typeof ItemLocation.SERVER>> {\n    if (this.hasFeatureBulkImport === false) {\n      throw new Error('Current server does not support bulk import')\n    }\n    if (folder.count() > 75) {\n      throw new Error('Refusing to bulk import more than 75 bookmarks')\n    }\n    Logger.log('(nextcloud-folders)BULKIMPORT', { parentId, folder })\n    const parentFolder = this.tree.findFolder(parentId)\n    if (!parentFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    const blob = new Blob(\n      [\n        '<!DOCTYPE NETSCAPE-Bookmark-file-1>\\n',\n        '<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=UTF-8\">\\n',\n        HtmlSerializer.serialize(folder),\n      ],\n      {\n        type: 'text/html',\n      }\n    )\n\n    const body = new FormData()\n    body.append('bm_import', blob, 'upload.html')\n\n    let json\n    try {\n      json = await this.sendRequest(\n        'POST',\n        `index.php/apps/bookmarks/public/rest/v2/folder/${parentId}/import`,\n        'multipart/form-data',\n        body\n      )\n    } catch (e) {\n      this.hasFeatureBulkImport = false\n      throw e\n    }\n\n    const recurseChildren = (children, id, title, parentId) => {\n      return new Folder({\n        id,\n        title,\n        parentId,\n        location: ItemLocation.SERVER,\n        children: children.map((item) => {\n          if (item.type === 'bookmark') {\n            return new Bookmark({\n              id: item.id + ';' + id,\n              title: item.title,\n              url: item.target || item.url,\n              parentId: id,\n              location: ItemLocation.SERVER,\n            })\n          } else if (item.type === 'folder') {\n            return recurseChildren(item.children, item.id, item.title, id)\n          } else {\n            console.log('PEBCAK', item)\n            throw new Error('PEBKAC')\n          }\n        }),\n      })\n    }\n    const imported = recurseChildren(json.data, parentId, folder.title, folder.parentId)\n    parentFolder.children = imported.clone(true).children\n    this.tree.createIndex()\n    return imported\n  }\n\n  async updateFolder(folder:Folder<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)UPDATEFOLDER', { folder })\n    const id = folder.id\n    const oldFolder = this.tree.findFolder(folder.id)\n    if (!oldFolder) {\n      throw new UnknownFolderUpdateError()\n    }\n    if (oldFolder.findFolder(folder.parentId)) {\n      throw new Error('Detected folder loop creation')\n    }\n    const body = {\n      parent_folder: folder.parentId,\n      title: folder.title,\n    }\n    await this.sendRequest(\n      'PUT',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${id}`,\n      'application/json',\n      body\n    )\n    const oldParentFolder = this.tree.findFolder(oldFolder.parentId)\n    if (!oldParentFolder) {\n      throw new UnknownFolderParentUpdateError()\n    }\n    oldParentFolder.children = oldParentFolder.children.filter(\n      (child) => String(child.id) !== String(id)\n    )\n    const newParentFolder = this.tree.findFolder(folder.parentId)\n    if (!newParentFolder) {\n      throw new UnknownMoveTargetError()\n    }\n    newParentFolder.children.push(oldFolder)\n    oldFolder.title = folder.title\n    oldFolder.parentId = folder.parentId\n    this.tree.createIndex()\n  }\n\n  async orderFolder(id:string|number, order:Ordering<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)ORDERFOLDER', { id, order })\n    const body = {\n      data: order.map((item) => ({\n        id: String(item.id).split(';')[0],\n        type: item.type,\n      })),\n    }\n    await this.sendRequest(\n      'PATCH',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${id}/childorder`,\n      'application/json',\n      body\n    )\n  }\n\n  async removeFolder(folder:Folder<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)REMOVEFOLDER', { folder })\n    const id = folder.id\n    const oldFolder = this.tree.findFolder(id)\n    if (!oldFolder) {\n      return\n    }\n    await this.sendRequest(\n      'DELETE',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${id}`\n    )\n    const parent = this.tree.findFolder(oldFolder.parentId)\n    if (parent) {\n      parent.children = parent.children.filter(\n        (child) => String(child.id) !== String(id)\n      )\n      this.tree.createIndex()\n    }\n  }\n\n  async _getBookmark(id:string|number):Promise<Bookmark<typeof ItemLocation.SERVER>[]> {\n    Logger.log('Fetching single bookmark')\n\n    const json = await this.sendRequest(\n      'GET',\n      'index.php/apps/bookmarks/public/rest/v2/bookmark/' + id\n    )\n    if (typeof json.item !== 'object') {\n      throw new UnexpectedServerResponseError()\n    }\n\n    const bm = json.item\n    if (!bm.folders.length) {\n      bm.folders = [null]\n    }\n    return bm.folders.map((parentId) => {\n      return new Bookmark({\n        id: bm.id + ';' + parentId,\n        url: bm.target || bm.url,\n        title: bm.title,\n        parentId: parentId,\n        tags: bm.tags,\n        location: ItemLocation.SERVER,\n      })\n    })\n  }\n\n  async getExistingBookmark(url:string):Promise<false|Bookmark<typeof ItemLocation.SERVER>> {\n    if (url.toLowerCase().startsWith('javascript:')) {\n      if (!this.hasFeatureJavascriptLinks) {\n        return false\n      }\n      const json = await this.sendRequest(\n        'GET',\n        `index.php/apps/bookmarks/public/rest/v2/bookmark?page=-1&search[]=${encodeURIComponent(\n          'javascript:'\n        )}`\n      )\n      if (json.data.length) {\n        const bookmark = json.data.find(bookmark => bookmark.target === url)\n        if (bookmark) {\n          return {...bookmark, parentId: bookmark.folders[0], url}\n        } else {\n          return false\n        }\n      } else {\n        return false\n      }\n    }\n    const json = await this.sendRequest(\n      'GET',\n      `index.php/apps/bookmarks/public/rest/v2/bookmark?url=${encodeURIComponent(\n        url\n      )}`\n    )\n    if (json.data.length) {\n      return {...json.data[0], parentId: json.data[0].folders[0], url}\n    } else {\n      return false\n    }\n  }\n\n  async createBookmark(bm:Bookmark<typeof ItemLocation.SERVER>):Promise<string|number> {\n    Logger.log('(nextcloud-folders)CREATE', bm)\n\n    // We need this lock to avoid creating two boomarks with the same url\n    // in parallel\n    return this.bookmarkLock.acquire(bm.url, async() => {\n      let newParentFolder\n      if (this.tree) {\n        newParentFolder = this.tree.findFolder(bm.parentId)\n        if (!newParentFolder) {\n          throw new UnknownCreateTargetError()\n        }\n      }\n\n      const existingBookmark = await this.getExistingBookmark(bm.url)\n      if (existingBookmark) {\n        bm.id = existingBookmark.id + ';' + bm.parentId // We already use the new parentId here, to avoid moving it away from the old location\n        const updatedBookmark = bm.clone()\n        updatedBookmark.title = existingBookmark.title\n        await this.updateBookmark(updatedBookmark)\n      } else {\n        const body = {\n          url: bm.url,\n          title: bm.title,\n          folders: [bm.parentId],\n        }\n\n        let json\n        try {\n          json = await this.sendRequest(\n            'POST',\n            'index.php/apps/bookmarks/public/rest/v2/bookmark',\n            'application/json',\n            body\n          )\n        } catch (e) {\n          if (e instanceof HttpError) {\n            throw new CreateBookmarkError(bm)\n          }\n          throw e\n        }\n        if (typeof json.item !== 'object') {\n          throw new UnexpectedServerResponseError()\n        }\n        bm.id = json.item.id + ';' + bm.parentId\n      }\n      // add bookmark to cached list\n      const upstreamMark = bm.clone()\n      upstreamMark.id = bm.id.split(';')[0]\n      this.list && this.list.push(upstreamMark)\n      if (this.tree) {\n        newParentFolder.children.push(upstreamMark)\n        this.tree.createIndex()\n      }\n\n      return bm.id\n    })\n  }\n\n  async updateBookmark(newBm:Bookmark<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)UPDATE', newBm)\n\n    const [upstreamId, oldParentId] = String(newBm.id).split(';')\n\n    // We need this lock to avoid updating bookmarks which are in two places at Once\n    // in parallel\n    return this.bookmarkLock.acquire(upstreamId, async() => {\n      const bms = await this._getBookmark(upstreamId)\n\n      const newFolder = this.tree.findFolder(newBm.parentId)\n      if (!newFolder) {\n        throw new UnknownCreateTargetError()\n      }\n\n      const body = {\n        url: newBm.url,\n        title: newBm.title,\n        folders: bms\n          .map((bm) => bm.parentId)\n          .filter(\n            (parentId) =>\n              parentId && String(parentId) !== String(oldParentId) &&\n              // make sure this is not an outdated oldParentId (can happen due to canMergeWith in Scanner)\n              (!this.tree.findFolder(parentId) || this.tree.findFolder(parentId).findItemFilter('bookmark', i => i.canMergeWith(newBm)) || !this.tree.findFolder(parentId).loaded)\n          )\n          .concat([newBm.parentId]),\n        tags: bms[0].tags,\n      }\n\n      try {\n        await this.sendRequest(\n          'PUT',\n          `index.php/apps/bookmarks/public/rest/v2/bookmark/${upstreamId}`,\n          'application/json',\n          body\n        )\n      } catch (e) {\n        if (e instanceof HttpError) {\n          throw new UpdateBookmarkError(newBm)\n        }\n        throw e\n      }\n\n      if (!newFolder.children.find(item => String(item.id) === String(newBm.id) && item.type === 'bookmark')) {\n        newFolder.children.push(newBm)\n      }\n      newBm.id = upstreamId + ';' + newBm.parentId\n      this.tree.createIndex()\n\n      return newBm.id\n    })\n  }\n\n  async removeBookmark(bookmark:Bookmark<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)REMOVE', { bookmark })\n    const id = bookmark.id\n    const [upstreamId, parentId] = String(id).split(';')\n\n    // Just to be safe\n    return this.bookmarkLock.acquire(upstreamId, async() => {\n      try {\n        await this.sendRequest(\n          'DELETE',\n          `index.php/apps/bookmarks/public/rest/v2/folder/${parentId}/bookmarks/${upstreamId}`\n        )\n        // remove bookmark from the cached list\n        const list = await this.getBookmarksList()\n        const listIndex = list.findIndex(\n          (bookmark) => String(bookmark.id) === String(upstreamId)\n        )\n        list.splice(listIndex, 1)\n      } catch (e) {\n        Logger.log('Error removing bookmark from folder: ' + e.message + '\\n Moving on.')\n      }\n    })\n  }\n\n  async checkFeatureJavascriptLinks(): Promise<void> {\n    if (this.hasFeatureJavascriptLinks !== null) {\n      return\n    }\n    try {\n      const json = await this.sendRequest(\n        'GET',\n        `index.php/apps/bookmarks/public/rest/v2/bookmark?page=1&limit=1`\n      )\n      if (!json.data.length) {\n        this.hasFeatureJavascriptLinks = true\n        try {\n          const id = await this.createBookmark(new Bookmark({id: null, parentId: '-1', title: 'floccus', url: 'javascript:void(0)', location: ItemLocation.SERVER}))\n          await this.removeBookmark(new Bookmark({id, parentId: '-1', title: 'floccus', url: 'javascript:void(0)', location: ItemLocation.SERVER}))\n        } catch (e) {\n          this.hasFeatureJavascriptLinks = false\n        }\n        return\n      }\n      this.hasFeatureJavascriptLinks = 'target' in json.data[0]\n    } catch (e) {\n      this.hasFeatureJavascriptLinks = false\n    }\n  }\n\n  async sendRequest(verb:string, relUrl:string, type:string = null, body:any = null, returnRawResponse = false):Promise<any> {\n    const url = this.normalizeServerURL(this.server.url) + relUrl\n    let res\n    let timedOut = false\n\n    if (type && type.includes('application/json')) {\n      body = JSON.stringify(body)\n    } else if (type && type.includes('application/x-www-form-urlencoded')) {\n      const params = new URLSearchParams()\n      for (const [key, value] of Object.entries(body || {})) {\n        params.set(key, value as any)\n      }\n      body = params.toString()\n    }\n\n    Logger.log(`QUEUING ${verb} ${url}`)\n\n    if (Capacitor.getPlatform() !== 'web') {\n      return this.sendRequestNative(verb, url, type, body, returnRawResponse)\n    }\n\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n\n    try {\n      res = await this.fetchQueue.add(() => {\n        Logger.log(`FETCHING ${verb} ${url}`)\n        return Promise.race([\n          fetch(url, {\n            method: verb,\n            credentials: this.server.includeCredentials ? 'include' : 'omit',\n            headers: {\n              ...(type && type !== 'multipart/form-data' && { 'Content-type': type }),\n              Authorization: 'Basic ' + authString,\n            },\n            signal: this.abortSignal,\n            ...(body && !['get', 'head'].includes(verb.toLowerCase()) && { body }),\n          }),\n          new Promise((resolve, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(new RequestTimeoutError())\n            }, TIMEOUT)\n          ),\n        ])\n      })\n    } catch (e) {\n      if (timedOut) throw e\n      if (this.canceled) throw new CancelledSyncError()\n      console.log(e)\n      throw new NetworkError()\n    }\n\n    Logger.log(`Receiving response for ${verb} ${url}`)\n\n    if (res.redirected && !this.server.allowRedirects) {\n      throw new RedirectError()\n    }\n\n    if (returnRawResponse) {\n      return res\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status === 503 || res.status >= 400) {\n      Logger.log(`${verb} ${url}: Server responded with ${res.status}: ` + (await res.text()).substring(0, 250))\n      throw new HttpError(res.status, verb)\n    }\n    let json\n    try {\n      json = await res.json()\n    } catch (e) {\n      throw new ParseResponseError(e.message)\n    }\n    if (json.status !== 'success') {\n      throw new Error('Nextcloud API error for request ' + verb + ' ' + relUrl + ' : \\n' + JSON.stringify(json))\n    }\n\n    return json\n  }\n\n  private async acquireLock():Promise<boolean> {\n    this.lockingPromise = (async() => {\n      const res = await this.sendRequest(\n        'POST',\n        'index.php/apps/bookmarks/public/rest/v2/lock',\n        null,\n        null,\n        true\n      )\n\n      if (res.status === 401 || res.status === 403) {\n        throw new AuthenticationError()\n      }\n      if (res.status !== 200 && res.status !== 405 && res.status !== 423) {\n        throw new HttpError(res.status, 'POST')\n      }\n\n      return res.status === 200 || res.status === 405\n    })()\n    return this.lockingPromise\n  }\n\n  private async releaseLock():Promise<boolean> {\n    if (this.lockingPromise) {\n      await this.lockingPromise\n    }\n    if (!this.locked) {\n      return\n    }\n    const res = await this.sendRequest(\n      'DELETE',\n      'index.php/apps/bookmarks/public/rest/v2/lock',\n      null,\n      null,\n      true\n    )\n\n    return res.status === 200\n  }\n\n  private async sendRequestNative(verb: string, url: string, type: string, body: any, returnRawResponse: boolean) {\n    let res\n    let timedOut = false\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n    try {\n      res = await this.fetchQueue.add(() => {\n        Logger.log(`FETCHING ${verb} ${url}`)\n        return Promise.race([\n          Http.request({\n            url,\n            method: verb,\n            disableRedirects: !this.server.allowRedirects,\n            headers: {\n              ...(type && type !== 'multipart/form-data' && { 'Content-type': type }),\n              Authorization: 'Basic ' + authString,\n            },\n            responseType: 'json',\n            ...(body && !['get', 'head'].includes(verb.toLowerCase()) && { data: body }),\n          }),\n          new Promise((resolve, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(new RequestTimeoutError())\n            }, TIMEOUT)\n          ),\n        ])\n      })\n    } catch (e) {\n      if (timedOut) throw e\n      console.log(e)\n      throw new NetworkError()\n    }\n\n    Logger.log(`Receiving response for ${verb} ${url}`)\n\n    if (res.status < 400 && res.status >= 300) {\n      throw new RedirectError()\n    }\n\n    if (returnRawResponse) {\n      return res\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status === 503 || res.status >= 400) {\n      throw new HttpError(res.status, verb)\n    }\n    const json = res.data\n    if (json.status !== 'success') {\n      throw new Error('Nextcloud API error for request ' + verb + ' ' + url + ' : \\n' + JSON.stringify(json))\n    }\n\n    return json\n  }\n\n  isAvailable(): Promise<boolean> {\n    return Promise.resolve(true)\n  }\n\n  async countClick(url: string): Promise<void> {\n    try {\n      await this.sendRequest(\n        'POST',\n        'index.php/apps/bookmarks/public/rest/v2/bookmark/click',\n        'application/json',\n        {\n          url,\n        }\n      )\n    } catch (e) {\n      console.warn(e)\n    }\n  }\n}\n","import Serializer from '../interfaces/Serializer'\nimport { Bookmark, Folder, ItemLocation, TItem } from '../Tree'\nimport * as cheerio from 'cheerio'\n\nclass HtmlSerializer implements Serializer {\n  serialize(folder) {\n    return `<DL><p>\\n${this._serializeFolder(folder, '')}</DL><p>\\n`\n  }\n\n  _htmlentities_encode(string) {\n    return string.replace(/[<>&\"']/g, char => '&#' + char.charCodeAt(0) + ';')\n  }\n\n  _serializeFolder(folder, indent) {\n    return folder.children\n      .map(child => {\n        if (child instanceof Bookmark) {\n          return (\n            `${indent}<DT><A HREF=\"${this._htmlentities_encode(child.url)}\" TAGS=\"${''}\" ID=\"${child.id}\">${this._htmlentities_encode(child.title)}</A>\\n`\n          )\n        } else if (child instanceof Folder) {\n          const nextIndent = indent + '  '\n          return (\n            `${indent}<DT><H3 ID=\"${child.id}\">${this._htmlentities_encode(child.title)}</H3>\\n` +\n            `${indent}<DL><p>\\n${this._serializeFolder(\n              child,\n              nextIndent\n            )}${indent}</DL><p>\\n`\n          )\n        }\n      })\n      .join('')\n  }\n\n  deserialize(html): Folder<typeof ItemLocation.SERVER> {\n    const items: TItem<typeof ItemLocation.SERVER>[] = parseByString(html)\n    items.forEach(f => { f.parentId = '0' })\n    return new Folder({id: '0', title: 'root', children: items, location: ItemLocation.SERVER, isRoot: true})\n  }\n}\n\nexport default new HtmlSerializer()\n\n// The following code is based on https://github.com/hold-baby/bookmark-file-parser\n// Copyright (c) 2019 hold-baby\n// MIT License\n\nexport const getRootFolder = (body: cheerio.Cheerio<any>) => {\n  const h3 = body.find('h3').first()\n\n  const isChrome = typeof h3.attr('personal_toolbar_folder') === 'string'\n\n  if (isChrome) {\n    return body.children('dl').first()\n  }\n\n  const isSafari = typeof h3.attr('folded') === 'string'\n\n  if (isSafari) {\n    return body\n  }\n\n  const isIE = typeof h3.attr('item_id') === 'string'\n\n  if (isIE) {\n    return body.children('dl').first()\n  }\n\n  const isFireFox = h3.text() === 'Mozilla Firefox'\n\n  if (isFireFox) {\n    return body.children('dl').first()\n  }\n\n  return body.children('dl').first()\n}\n\nexport const parseByString = (content: string) => {\n  const $ = cheerio.load(content)\n\n  const body = $('body')\n  const root: TItem<typeof ItemLocation.SERVER>[] = []\n  const rdt = getRootFolder(body).children('dt')\n\n  const parseNode = (node: cheerio.Cheerio<any>, parentId?: string|number) => {\n    const eq0 = node.children().eq(0)\n    const title = typeof eq0.text() !== 'undefined' ? eq0.text() : ''\n    let url = ''\n    const id = typeof eq0.attr('id') !== 'undefined' ? eq0.attr('id') : ''\n    let children: TItem<typeof ItemLocation.SERVER>[] = []\n\n    switch (eq0[0].name) {\n      case 'h3':\n        // folder\n        const dl = node.children('dl').first()\n        const dts = dl.children()\n\n        const ls = dts.toArray().map((ele) => {\n          if (ele.name !== 'dt') return null\n          return parseNode($(ele), id)\n        })\n        children = ls.filter((item) => item !== null) as TItem<typeof ItemLocation.SERVER>[]\n        return new Folder({id, title, parentId, children, location: ItemLocation.SERVER})\n      case 'a':\n        // site\n        url = eq0.attr('href') || ''\n        return new Bookmark({id, title, url, parentId, location: ItemLocation.SERVER})\n    }\n    throw new Error('Failed to parse')\n  }\n\n  rdt.each((_, item) => {\n    const node = $(item)\n    const child = parseNode(node)\n    root.push(child)\n  })\n\n  return root\n}\n","import DefaultStrategy, { ISerializedSyncProcess } from './Default'\nimport Diff, { ActionType, PlanRevert, PlanStage1, PlanStage3, ReorderAction } from '../Diff'\nimport * as Parallel from 'async-parallel'\nimport Mappings, { MappingSnapshot } from '../Mappings'\nimport { Folder, ItemLocation, TItem, TItemLocation, TOppositeLocation } from '../Tree'\nimport Logger from '../Logger'\nimport { CancelledSyncError } from '../../errors/Error'\nimport TResource from '../interfaces/Resource'\nimport Scanner, { ScanResult } from '../Scanner'\nimport DefaultSyncProcess from './Default'\n\nconst ACTION_CONCURRENCY = 12\n\nexport default class UnidirectionalSyncProcess extends DefaultStrategy {\n  protected direction: TItemLocation\n  protected revertPlan: PlanStage1<TItemLocation, TOppositeLocation<TItemLocation>>\n  protected revertDonePlan: PlanRevert<TItemLocation, TOppositeLocation<TItemLocation>>\n  protected revertReorders: Diff<TItemLocation, TOppositeLocation<TItemLocation>, ReorderAction<TItemLocation, TOppositeLocation<TItemLocation>>>\n\n  setDirection(direction: TItemLocation): void {\n    this.direction = direction\n  }\n\n  getMembersToPersist() {\n    return [\n      // Stage 0\n      'localScanResult',\n      'serverScanResult',\n\n      // Stage 1\n      'revertPlan',\n      'revertDonePlan',\n\n      // Stage 2\n      'revertReorders',\n    ]\n  }\n\n  async getDiffs():Promise<{localScanResult:ScanResult<typeof ItemLocation.LOCAL, TItemLocation>, serverScanResult:ScanResult<typeof ItemLocation.SERVER, TItemLocation>}> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const newMappings = []\n    const localScanner = new Scanner(\n      this.serverTreeRoot,\n      this.localTreeRoot,\n      // We can't rely on a cacheTree, thus we have to accept canMergeWith results as well\n      (serverItem, localItem) => {\n        if (localItem.type !== serverItem.type) {\n          return false\n        }\n        // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n        if (serverItem.type === 'bookmark' && localItem.type === 'bookmark' && serverItem.url !== localItem.url) {\n          return false\n        }\n        if (serverItem.canMergeWith(localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        if (Mappings.mappable(mappingsSnapshot, serverItem, localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        return false\n      },\n      this.preserveOrder,\n      false,\n      false\n    )\n    const serverScanner = new Scanner(\n      this.localTreeRoot,\n      this.serverTreeRoot,\n      (localItem, serverItem) => {\n        if (serverItem.type !== localItem.type) {\n          return false\n        }\n        // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n        if (serverItem.type === 'bookmark' && localItem.type === 'bookmark' && serverItem.url !== localItem.url) {\n          return false\n        }\n        if (serverItem.canMergeWith(localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        if (Mappings.mappable(mappingsSnapshot, serverItem, localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        return false\n      },\n      this.preserveOrder,\n      false,\n      false\n    )\n    const localScanResult = await localScanner.run()\n    const serverScanResult = await serverScanner.run()\n    await Parallel.map(newMappings, ([localItem, serverItem]) => {\n      return this.addMapping(this.server, localItem, serverItem.id)\n    })\n\n    return {localScanResult, serverScanResult}\n  }\n\n  async loadChildren(serverTreeRoot:Folder<typeof ItemLocation.SERVER>) :Promise<void> {\n    Logger.log('Unidirectional: Loading whole tree')\n    serverTreeRoot.children = (await this.server.getBookmarksTree(true)).children\n  }\n\n  async sync(): Promise<void> {\n    this.progressCb(0.15)\n\n    this.masterLocation = this.direction === ItemLocation.SERVER ? ItemLocation.LOCAL : ItemLocation.SERVER\n    await this.prepareSync()\n\n    this.progressCb(0.35)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log({localTreeRoot: this.localTreeRoot, serverTreeRoot: this.serverTreeRoot, cacheTreeRoot: this.cacheTreeRoot})\n\n    if (!this.localScanResult && !this.serverScanResult) {\n      const { localScanResult, serverScanResult } = await this.getDiffs()\n      Logger.log({ localScanResult, serverScanResult })\n      this.localScanResult = localScanResult\n      this.serverScanResult = serverScanResult\n      this.progressCb(0.45)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    let sourceScanResult: ScanResult<TItemLocation, TItemLocation>,\n      targetScanResult: ScanResult<TItemLocation, TItemLocation>,\n      target: TResource<TItemLocation>\n    if (this.direction === ItemLocation.SERVER) {\n      sourceScanResult = this.localScanResult\n      targetScanResult = this.serverScanResult\n      target = this.server\n    } else {\n      sourceScanResult = this.serverScanResult\n      targetScanResult = this.localScanResult\n      target = this.localTree\n    }\n\n    // First revert slave modifications\n\n    if (!this.revertPlan) {\n      this.revertPlan = await this.revertDiff(targetScanResult, sourceScanResult, this.direction)\n      Logger.log({revertPlan: this.revertPlan})\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    this.actionsPlanned = Object.values(this.revertPlan).reduce((acc, diff) => diff.getActions().length + acc, 0)\n\n    if (this.direction === ItemLocation.LOCAL) {\n      this.applyFailsafe(this.revertPlan.REMOVE)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log('Executing ' + this.direction + ' revert plan')\n\n    this.revertDonePlan = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: new Diff(),\n    }\n\n    await this.executeRevert(target, this.revertPlan, this.direction, this.revertDonePlan, sourceScanResult.REORDER)\n\n    if ('orderFolder' in this.server && !this.revertReorders) {\n      const mappingsSnapshot = this.mappings.getSnapshot()\n      Logger.log('Mapping reorderings')\n      this.revertReorders = sourceScanResult.REORDER.map(mappingsSnapshot, this.direction)\n    }\n\n    if ('orderFolder' in this.server && 'orderFolder' in target) {\n      await this.executeReorderings(target, this.revertReorders)\n    }\n  }\n\n  async revertDiff<L1 extends TItemLocation, L2 extends TItemLocation>(\n    targetScanResult: ScanResult<L1, L2>,\n    sourceScanResult: ScanResult<L2, L1>,\n    targetLocation: L1\n  ): Promise<PlanRevert<L1, L2>> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const slavePlan: PlanRevert<L1, L2> = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: targetScanResult.REORDER.clone(),\n    }\n\n    // Prepare slave plan for reversing slave changes\n\n    await Parallel.each(sourceScanResult.CREATE.getActions(), async(action) => {\n      // recreate it on slave resource otherwise\n      const payload = await this.translateCompleteItem(action.payload, mappingsSnapshot, targetLocation)\n      const oldItem = action.payload\n      payload.createIndex()\n      oldItem.createIndex()\n\n      slavePlan.CREATE.commit({...action, type: ActionType.CREATE, payload, oldItem })\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(targetScanResult.CREATE.getActions(), async(action) => {\n      slavePlan.REMOVE.commit({ ...action, type: ActionType.REMOVE })\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(targetScanResult.UPDATE.getActions(), async(action) => {\n      const payload = action.oldItem.cloneWithLocation(false, action.payload.location)\n      payload.id = action.payload.id\n      payload.parentId = action.payload.parentId\n\n      const oldItem = action.payload.cloneWithLocation(false, action.oldItem.location)\n      oldItem.id = action.oldItem.id\n      oldItem.parentId = action.oldItem.parentId\n      slavePlan.UPDATE.commit({ type: ActionType.UPDATE, payload, oldItem })\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(targetScanResult.MOVE.getActions(), async(action) => {\n      const payload = action.payload.cloneWithLocation(false, action.oldItem.location)\n      payload.id = action.oldItem.id\n      payload.parentId = action.oldItem.parentId\n\n      slavePlan.MOVE.commit({ type: ActionType.MOVE, payload }) // no oldItem, because we want to map the id after having executed the CREATEs\n    }, ACTION_CONCURRENCY)\n\n    return slavePlan\n  }\n\n  private async translateCompleteItem<L1 extends TItemLocation, L2 extends TItemLocation>(item: TItem<L1>, mappingsSnapshot: MappingSnapshot, fakeLocation: L2) {\n    const newItem = item.cloneWithLocation(false, fakeLocation)\n    newItem.id = Mappings.mapId(mappingsSnapshot, item, fakeLocation)\n    newItem.parentId = Mappings.mapParentId(mappingsSnapshot, item, fakeLocation)\n    if (newItem instanceof Folder) {\n      const nonexistingItems = []\n      await newItem.traverse(async(child, parentFolder) => {\n        child.id = Mappings.mapId(mappingsSnapshot, child, fakeLocation)\n        if (typeof child.id === 'undefined') {\n          nonexistingItems.push(child)\n        }\n        child.parentId = parentFolder.id\n      })\n      newItem.createIndex()\n      // filter out all items that couldn't be mapped: These are creations from the slave side\n      nonexistingItems.forEach(item => {\n        const folder = newItem.findFolder(item.parentId)\n        folder.children = folder.children.filter(i => i.id)\n      })\n    } else {\n      newItem.createIndex()\n    }\n    return newItem\n  }\n\n  async executeRevert<L1 extends TItemLocation>(\n    resource:TResource<L1>,\n    planRevert:PlanRevert<L1, TOppositeLocation<L1>>,\n    targetLocation:L1,\n    donePlan: PlanStage3<TOppositeLocation<L1>, TItemLocation, L1>,\n    reorders: Diff<TOppositeLocation<L1>, TItemLocation, ReorderAction<TOppositeLocation<L1>, TItemLocation>>): Promise<void> {\n    Logger.log('Executing revert plan for ' + targetLocation)\n\n    let createActions = planRevert.CREATE.getActions()\n    while (createActions.length > 0) {\n      Logger.log(targetLocation + ': executing CREATEs')\n      await Parallel.each(\n        createActions,\n        (action) => this.executeCreate(resource, action, targetLocation, planRevert.CREATE, reorders, donePlan),\n        ACTION_CONCURRENCY\n      )\n      createActions = planRevert.CREATE.getActions()\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing CREATEs')\n\n    await Parallel.each(\n      planRevert.UPDATE.getActions(),\n      (action) => this.executeUpdate(resource, action, targetLocation, planRevert.UPDATE, donePlan),\n      ACTION_CONCURRENCY\n    )\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const mappingsSnapshot = this.mappings.getSnapshot()\n    // TODO: Store this in continuation\n    const mappedMoves = planRevert.MOVE.map(mappingsSnapshot, targetLocation)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const batches = Diff.sortMoves(mappedMoves.getActions(), this.getTargetTree(targetLocation))\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing MOVEs')\n    await Parallel.each(batches, batch => Parallel.each(batch, (action) => {\n      return this.executeUpdate(resource, action, targetLocation, mappedMoves, donePlan)\n    }, ACTION_CONCURRENCY), 1)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing REMOVEs')\n    await Parallel.each(planRevert.REMOVE.getActions(), (action) => {\n      return this.executeRemove(resource, action, targetLocation, planRevert.REMOVE, donePlan)\n    }, ACTION_CONCURRENCY)\n  }\n\n  toJSON(): ISerializedSyncProcess {\n    return {\n      ...DefaultSyncProcess.prototype.toJSON.apply(this),\n      strategy: 'unidirectional'\n    }\n  }\n}\n","export default interface IController {\n  setEnabled(enabled:boolean): void;\n  unlock(key):Promise<void>;\n  scheduleSync(accountId, wait):Promise<void>;\n  scheduleAll():Promise<void>;\n  cancelSync(accountId, keepEnabled):Promise<void>;\n  syncAccount(accountId, strategy, forceSync):Promise<void>;\n  onStatusChange(listener):()=>void;\n  getUnlocked():Promise<boolean>;\n  onLoad():Promise<void>;\n}\n\nexport const STATUS_ERROR = Symbol('error')\nexport const STATUS_SYNCING = Symbol('syncing')\nexport const STATUS_ALLGOOD = Symbol('allgood')\nexport const STATUS_DISABLED = Symbol('disabled')\n","import { Bookmark, TItemLocation } from '../lib/Tree'\n\nexport class FloccusError extends Error {\n  public code: number\n\n  constructor(message) {\n    super(message)\n    // See https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript#22666069\n    Object.setPrototypeOf(this, FloccusError.prototype)\n  }\n}\n\nexport class UnknownCreateTargetError extends FloccusError {\n  constructor() {\n    super(\"E001: Folder to create in doesn't exist\")\n    this.code = 1\n    Object.setPrototypeOf(this, UnknownCreateTargetError.prototype)\n  }\n}\n\nexport class UnknownBookmarkUpdateError extends FloccusError {\n  constructor() {\n    super(\"E002: Bookmark to update doesn't exist anymore\")\n    this.code = 2\n    Object.setPrototypeOf(this, UnknownBookmarkUpdateError.prototype)\n  }\n}\n\nexport class UnknownMoveOriginError extends FloccusError {\n  constructor() {\n    super(\"E003: Folder to move out of doesn't exist\")\n    this.code = 3\n    Object.setPrototypeOf(this, UnknownMoveOriginError.prototype)\n  }\n}\n\nexport class UnknownMoveTargetError extends FloccusError {\n  constructor() {\n    super(\"E004: Folder to move into doesn't exist\")\n    this.code = 4\n    Object.setPrototypeOf(this, UnknownMoveTargetError.prototype)\n  }\n}\n\nexport class UnknownFolderParentUpdateError extends FloccusError {\n  constructor() {\n    super(\"E006: Parent of folder to update doesn't exist\")\n    this.code = 5\n    Object.setPrototypeOf(this, UnknownFolderParentUpdateError.prototype)\n  }\n}\n\nexport class UnknownFolderUpdateError extends FloccusError {\n  constructor() {\n    super(\"E006: Folder to update doesn't exist\")\n    this.code = 6\n    Object.setPrototypeOf(this, UnknownFolderUpdateError.prototype)\n  }\n}\n\nexport class UnknownFolderMoveError extends FloccusError {\n  constructor() {\n    super(\"E007: Folder to move doesn't exist\")\n    this.code = 7\n    Object.setPrototypeOf(this, UnknownFolderMoveError.prototype)\n  }\n}\n\n// code 8 is unused\n// code 9 is unused\n\nexport class UnknownFolderOrderError extends FloccusError {\n  constructor() {\n    super('E010: Could not find folder to order')\n    this.code = 10\n    Object.setPrototypeOf(this, UnknownFolderOrderError.prototype)\n  }\n}\n\nexport class UnknownFolderItemOrderError extends FloccusError {\n  public item: string\n  constructor(item: string) {\n    super('E011: Item in folder ordering is not an actual child')\n    this.code = 11\n    this.item = item\n    Object.setPrototypeOf(this, UnknownFolderItemOrderError.prototype)\n  }\n}\n\nexport class MissingItemOrderError extends FloccusError {\n  public item: string\n  constructor(item: string) {\n    super(\"E012: Folder ordering is missing some of the folder's children\")\n    this.code = 12\n    this.item = item\n    Object.setPrototypeOf(this, MissingItemOrderError.prototype)\n  }\n}\n\nexport class UnknownFolderRemoveError extends FloccusError {\n  constructor() {\n    super(\"E013: Folder to remove doesn't exist\")\n    this.code = 13\n    Object.setPrototypeOf(this, UnknownFolderRemoveError.prototype)\n  }\n}\n\nexport class UnknownFolderParentRemoveError extends FloccusError {\n  constructor() {\n    super(\"E014: Parent folder to remove folder from of doesn't exist\")\n    this.code = 14\n    Object.setPrototypeOf(this, UnknownFolderParentRemoveError.prototype)\n  }\n}\n\nexport class UnexpectedServerResponseError extends FloccusError {\n  constructor() {\n    super('E015: Unexpected response data from server')\n    this.code = 15\n    Object.setPrototypeOf(this, UnexpectedServerResponseError.prototype)\n  }\n}\n\nexport class RequestTimeoutError extends FloccusError {\n  constructor() {\n    super('E016: Request timed out.')\n    this.code = 16\n    Object.setPrototypeOf(this, RequestTimeoutError.prototype)\n  }\n}\n\nexport class NetworkError extends FloccusError {\n  constructor() {\n    super('E017: Network error: Check your network connection and your profile details')\n    this.code = 17\n    Object.setPrototypeOf(this, NetworkError.prototype)\n  }\n}\n\nexport class AuthenticationError extends FloccusError {\n  constructor() {\n    super(\"E018: Couldn't authenticate with the server.\")\n    this.code = 18\n    Object.setPrototypeOf(this, AuthenticationError.prototype)\n  }\n}\n\nexport class HttpError extends FloccusError {\n  public status: number\n  public method: string\n  constructor(status: number, method: string) {\n    super(`E019: HTTP status ${status}. Failed ${method} request. Check your server configuration and log.`)\n    this.code = 19\n    this.status = status\n    this.method = method\n    Object.setPrototypeOf(this, HttpError.prototype)\n  }\n}\n\nexport class ParseResponseError extends FloccusError {\n  public response: string\n  constructor(response: string) {\n    super('E020: Could not parse server response. Is the bookmarks app installed on your server?')\n    this.code = 20\n    this.response = response\n    Object.setPrototypeOf(this, ParseResponseError.prototype)\n  }\n}\n\nexport class InconsistentServerStateError extends FloccusError {\n  constructor() {\n    super('E021: Inconsistent server state. Folder is present in childorder list but not in folder tree')\n    this.code = 21\n    Object.setPrototypeOf(this, InconsistentServerStateError.prototype)\n  }\n}\n\nexport class InconsistentBookmarksExistenceError extends FloccusError {\n  public folder: string\n  public bookmark: string\n  constructor(folder:string, bookmark:string) {\n    super(`E022: Folder ${folder} supposedly contains non-existent bookmark ${bookmark}`)\n    this.code = 22\n    this.folder = folder\n    this.bookmark = bookmark\n    Object.setPrototypeOf(this, InconsistentBookmarksExistenceError.prototype)\n  }\n}\n\nexport class UnclearedLockFileError extends FloccusError {\n  public lockFile: string\n\n  constructor(lockFile:string) {\n    super(`E023: Unable to clear lock file, consider deleting ${lockFile} manually.`)\n    this.code = 23\n    this.lockFile = lockFile\n    Object.setPrototypeOf(this, UnclearedLockFileError.prototype)\n  }\n}\n\nexport class LockFileError extends FloccusError {\n  public status: number\n  public lockFile: string\n\n  constructor(status:number, lockFile:string) {\n    super(`E024: HTTP status ${status} while trying to determine status of lock file ${lockFile}`)\n    this.code = 24\n    this.status = status\n    this.lockFile = lockFile\n    Object.setPrototypeOf(this, LockFileError.prototype)\n  }\n}\n\nexport class SlashError extends FloccusError {\n  public status: number\n  public lockFile: string\n\n  constructor() {\n    super(\"E025: Bookmarks file setting mustn't begin with a slash: '/'\")\n    this.code = 25\n    Object.setPrototypeOf(this, SlashError.prototype)\n  }\n}\n\nexport class CancelledSyncError extends FloccusError {\n  constructor() {\n    super('E026: Sync process was cancelled')\n    this.code = 26\n    Object.setPrototypeOf(this, InterruptedSyncError.prototype)\n  }\n}\n\nexport class InterruptedSyncError extends FloccusError {\n  constructor() {\n    super('E027: Sync process was interrupted')\n    this.code = 27\n    Object.setPrototypeOf(this, InterruptedSyncError.prototype)\n  }\n}\n\n// code 28 is unused\n\nexport class FailsafeError extends FloccusError {\n  public percent: number\n\n  constructor(percent:number) {\n    super(`E029: Failsafe: The current sync run would delete ${percent}% of your bookmarks. Refusing to execute. Disable this failsafe in the profile settings if you want to proceed anyway.`)\n    this.code = 29\n    this.percent = percent\n    Object.setPrototypeOf(this, FailsafeError.prototype)\n  }\n}\n\nexport class DecryptionError extends FloccusError {\n  constructor() {\n    super('E030: Failed to decrypt bookmarks file. The passphrase may be wrong or the file may be corrupted.')\n    this.code = 30\n    Object.setPrototypeOf(this, DecryptionError.prototype)\n  }\n}\n\nexport class GoogleDriveAuthenticationError extends FloccusError {\n  constructor() {\n    super('E031: Could not authenticate with Google Drive. Please connect floccus with your google account again.')\n    this.code = 31\n    Object.setPrototypeOf(this, GoogleDriveAuthenticationError.prototype)\n  }\n}\n\nexport class OAuthTokenError extends FloccusError {\n  constructor() {\n    super('E032: OAuth error. Token validation error. Please reconnect your Google Account.')\n    this.code = 32\n    Object.setPrototypeOf(this, OAuthTokenError.prototype)\n  }\n}\n\nexport class RedirectError extends FloccusError {\n  constructor() {\n    super(\"E033: Redirect detected. Please make sure the server supports the selected sync method and URL you entered is correct doesn't redirect to a different location.\")\n    this.code = 33\n    Object.setPrototypeOf(this, RedirectError.prototype)\n  }\n}\n\nexport class FileUnreadableError extends FloccusError {\n  constructor() {\n    super('E034: Remote bookmarks file is unreadable. Perhaps you forgot to set an encryption passphrase, or you set the wrong file format.')\n    this.code = 34\n    Object.setPrototypeOf(this, FileUnreadableError.prototype)\n  }\n}\n\nexport class CreateBookmarkError extends FloccusError {\n  public bookmark: Bookmark<TItemLocation>\n  constructor(bookmark: Bookmark<TItemLocation>) {\n    super(`E035: Failed to create the following bookmark on the server: ${bookmark.inspect()}`)\n    this.code = 35\n    this.bookmark = bookmark\n    Object.setPrototypeOf(this, CreateBookmarkError.prototype)\n  }\n}\n\nexport class MissingPermissionsError extends FloccusError {\n  constructor() {\n    super(`E036: Missing permissions to access the sync server`)\n    this.code = 36\n    Object.setPrototypeOf(this, MissingPermissionsError.prototype)\n  }\n}\n\nexport class ResourceLockedError extends FloccusError {\n  constructor() {\n    super(`E037: Resource is locked`)\n    this.code = 37\n    Object.setPrototypeOf(this, ResourceLockedError.prototype)\n  }\n}\n\nexport class LocalFolderNotFoundError extends FloccusError {\n  constructor() {\n    super(`E038: Could not find local folder`)\n    this.code = 38\n    Object.setPrototypeOf(this, LocalFolderNotFoundError.prototype)\n  }\n}\n\nexport class UpdateBookmarkError extends FloccusError {\n  public bookmark: Bookmark<TItemLocation>\n  constructor(bookmark: Bookmark<TItemLocation>) {\n    super(`E039: Failed to update the following bookmark on the server: ${bookmark.inspect()}`)\n    this.code = 39\n    this.bookmark = bookmark\n    Object.setPrototypeOf(this, UpdateBookmarkError.prototype)\n  }\n}\n\nexport class GoogleDriveSearchError extends FloccusError {\n  constructor() {\n    super('E040: Could not search for your file name in your Google Drive')\n    this.code = 40\n    Object.setPrototypeOf(this, GoogleDriveSearchError.prototype)\n  }\n}"],"names":["STRANGE_PROTOCOLS","ItemLocation","LOCAL","SERVER","ItemType","FOLDER","BOOKMARK","id","parentId","url","title","tags","location","type","isRoot","this","Error","some","proto","indexOf","urlObj","URL","href","e","log","canMergeWith","otherItem","Bookmark","childrenSimilarity","hash","hashValue","sha256","JSON","stringify","clone","withHash","cloneWithLocation","createIndex","findItem","String","findItemFilter","fn","prefer","count","inspect","depth","Array","fill","join","visitCreate","resource","createBookmark","visitUpdate","updateBookmark","visitRemove","removeBookmark","hydrate","obj","children","loaded","index","Object","values","filter","sort","a","b","pop","findFolder","folder","child","Folder","map","findBookmark","bookmark","find","bm","traverse","Parallel","each","item","Promise","resolve","reduce","i","Math","max","length","preserveOrder","slice","c1","c2","keys","countFolders","forEach","subIndex","assign","createFolder","updateFolder","removeFolder","getAncestorsOf","tree","ancestors","parent","push","reverse","message","msgBuffer","TextEncoder","encode","crypto","subtle","digest","hashBuffer","bufferToHexstr","Uint8Array","buffer","from","toString","hexstrToBuffer","hex","bytes","c","parseInt","substr","prepareKey","passphrase","salt","enc","passphraseBytes","saltBytes","importKey","key","deriveKey","name","iterations","Crypto","decryptAES","payload","cryptoKey","toUint8Array","iv","ivLength","ciphertext","decrypt","plaintextBytes","TextDecoder","decode","encryptAES","getRandomBytes","messageBytes","encrypt","resultBytes","concatBytes","fromUint8Array","array1","array2","result","set","bytelength","rand","getRandomValues","context","locale","locales","defaultMessages","messages","setLocales","load","fileName","replace","imported","console","warn","split","getMessage","messageName","content","formats","string","doGetMessage","format","isArray","getDefaultLocaleMessage","hasOwnProperty","call","i18n","I18n","ACTION_CONCURRENCY","mappings","localTree","server","progressCb","localTreeRoot","serverTreeRoot","localScanResult","serverScanResult","actionsDone","actionsPlanned","staticContinuation","throttle","canceled","isFirefox","self","protocol","getMembersToPersist","getMappingsInstance","setCacheTree","cacheTree","cacheTreeRoot","getTargetTree","targetLocation","cancel","updateProgress","min","setProgress","setDirection","direction","sync","masterLocation","prepareSync","CancelledSyncError","getDiffs","serverPlanStage1","reconcileDiffs","localPlanStage1","serverPlanStage2","mappingsSnapshot","getSnapshot","CREATE","UPDATE","MOVE","REMOVE","REORDER","localPlanStage2","localPlan","serverPlan","applyFailsafe","localDonePlan","serverDonePlan","localReorders","serverReorders","acc","diff","getActions","execute","localReordersFinal","reconcileReorderings","serverReorderFinal","all","executeReorderings","getBookmarksTree","filterOutUnacceptedBookmarks","filterOutDuplicatesInTheSameFolder","filterOutInvalidBookmarks","addFolder","localId","remoteId","loadChildren","removals","localCountTotal","localCountDeleted","action","failsafe","getData","FailsafeError","ceil","acceptsBookmark","startsWith","seenUrl","duplicates","newMappings","constructor","localScanner","oldItem","newItem","mappable","serverScanner","run","localItem","serverItem","addMapping","sourceScanResult","targetScanResult","targetCreations","targetRemovals","targetMoves","targetUpdates","targetReorders","sourceCreations","sourceRemovals","sourceMoves","targetTree","sourceTree","allCreateAndMoveActions","concat","avoidTargetReorders","targetPlan","targetRemoval","findChain","targetMove","commit","concurrentCreation","mapParentId","newId","complexTargetTargetRemoval","concurrentTargetOriginRemoval","concurrentSourceOriginRemoval","sourceRemoval","concurrentSourceTargetRemoval","ActionType","SyncProcess","removeItemFromReorders","originalCreation","creation","newPayload","removed","movedAway","splice","concurrentHierarchyReversals","mapId","move","remove","planStage2","donePlan","reorders","createActions","executeCreate","executeUpdate","planStage3","batches","sortMoves","batch","executeRemove","done","retract","bulkImportFolder","order","oldChildItem","tempItem","bookmarks","newAction","removeMapping","sourceDonePlan","mappingSnapshot","newReorders","oldReorderAction","reorderAction","removal","childAwayMoves","concurrentRemovals","reorder","reorderings","items","orderFolder","addBookmark","cacheItem","ServerToLocal","folderHasChanged","loadFolderChildren","localHash","cacheHash","serverHash","reconciled","changedLocally","changedUpstream","filterOutUnmappedItems","mapping","LocalToServer","sourceReorders","parentReorder","toJSON","membersToPersist","strategy","fromEntries","entries","includes","fromJSON","json","MergeSyncProcess","default","UnidirectionalSyncProcess","member","toLowerCase","worker","getSingleton","singleton","Capacitor","getPlatform","Controller","getWorker","navigator","userAgent","serviceWorker","controller","ready","then","registration","postMessage","active","args","addEventListener","listener","event","data","removeEventListener","runtime","sendMessage","onMessage","addListener","removeListener","cancelSync","accountId","keepEnabled","params","onStatusChange","eventListener","w","scheduleSync","wait","scheduleAll","setEnabled","enabled","syncAccount","forceSync","unlock","getUnlocked","onLoad","ChromePromise","root","window","prototype","chrome","setPromiseFunction","thisArg","arguments","reject","err","lastError","apply","fillProperties","source","target","val","browser","alarms","browserAction","sourceUpdates","registry","register","adapter","factory","getDefaultValues","dataLock","storageAdapter","serverAdapter","treeAdapter","storage","lockTimeout","getAccountClass","get","cache","updateFromStorage","account","create","import","accounts","accountData","export","accountIds","Account","delete","deleteAccountData","getLabel","localRoot","syncInterval","nestedSync","allowNetwork","label","errorCount","clickCountEnabled","getResource","getServer","setData","acquire","d","setAccountData","tracksBookmark","isInitialized","getMappings","snapshot","foundBookmark","foundFolder","init","syncing","localResource","isAvailable","Sentry","setUser","scheduled","error","onSyncStart","needLock","code","lastSync","Date","now","persist","getCache","getCurrentContinuation","continuation","progress","actionDone","progressCallback","syncProcess","createdAt","strategyClass","setCache","onSyncComplete","setCurrentContinuation","stringifyError","setContext","username","password","list","captureException","matchAllErrors","isTest","onSyncFail","er","getAllAccounts","getAccountsContainingLocalId","allAccounts","every","keyBuffer","Int8Array","webpackAsyncContext","req","__webpack_require__","o","ids","module","exports","getAccountData","NativeAccount","random","initMappings","initCache","nativeTree","Boolean","getEntry","UnknownFolderItemOrderError","MissingItemOrderError","padStart","HttpError","status","method","ParseResponseError","response","InconsistentBookmarksExistenceError","LockFileError","lockFile","percent","CreateBookmarkError","UpdateBookmarkError","FloccusError","locked","ended","lockingInterval","bookmark_file","bookmark_file_type","includeCredentials","allowRedirects","WebDavAdapter","normalizeServerURL","input","serverURL","pathname","search","output","abortController","abort","cancelCallback","getBookmarkURL","getBookmarkLockURL","checkLock","fullURL","downloadFile","timeout","ms","setTimeout","obtainLock","res","headers","ResourceLockedError","valueOf","setLock","lockingPromise","uploadFile","freeLock","fullUrl","authString","Base64","fetch","credentials","Authorization","signal","abortSignal","redirect","request","webFetchExtra","lockFreed","pullFromServer","AuthenticationError","resetCache","xmlDocText","parse","DecryptionError","FileUnreadableError","byNL","line","idxStart","idxEnd","lastIndexOf","highestId","substring","bookmarksCache","deserialize","forceLock","hasPermissions","permissions","contains","origins","MissingPermissionsError","SlashError","AbortController","resp","initialTreeHash","clearInterval","setInterval","xbel","rootFolder","serialize","createHTML","content_type","uploadFileWeb","uploadFileNative","body","aborted","NetworkError","RedirectError","downloadFileWeb","downloadFileNative","text","Pragma","responseType","BrowserAccount","accData","getTree","parentNode","bookmarksBar","node","getPathFromLocalId","rootPath","getSubTree","LocalTabs","localTabs","withDisallowNested","getIdPathFromLocalId","accountsInvolved","lastNesterIdx","findIndex","Logger","logMsg","toISOString","util","Storage","changeEntry","getLogs","anonymizeLogs","logs","regex","newLogs","async","replaceAsync","entry","match","p1","p2","p3","regex2","regex3","str","asyncFn","promises","_len","_key","promise","shift","downloadLogs","anonymous","undefined","blob","Blob","endings","download","packageJson","filename","element","document","createElement","objectUrl","createObjectURL","setAttribute","style","display","appendChild","click","revokeObjectURL","removeChild","uri","fileURI","Filesystem","writeFile","path","encoding","Encoding","UTF8","directory","Directory","External","recursive","Share","share","files","isVivaldi","tabs","query","currentWindow","oldHash","newHash","save","value","triggerSave","clearTimeout","saveTimeout","folderId","OAuthConfig","authorizationBaseUrl","accessTokenEndpoint","scope","resourceUrl","logsEnabled","android","appId","client_id","redirectUrl","ios","alwaysUpload","authorize","interactive","platform","OAuth2Client","authenticate","refresh_token","access_token_response","user","displayName","challenge","state","redirectURL","identity","getRedirectURL","scopes","authURL","web","encodeURIComponent","launchWebAuthFlow","redirectResult","m","URLSearchParams","resState","client_secret","OAuthTokenError","access_token","about","getAccessToken","refreshToken","grant_type","GoogleDriveAuthenticationError","getUrl","accessToken","listFiles","fileList","GoogleDriveSearchError","file","trashed","filesToDelete","fileToDelete","deleteFile","fileId","getFileMetadata","appProperties","lockedDate","Number","isInteger","newTreeHash","createFile","contentType","requestNative","requestWeb","limit","fields","SCOPES","GoogleDriveAdapter","hostname","UnknownCreateTargetError","newBm","UnknownBookmarkUpdateError","foundOldFolder","UnknownMoveOriginError","foundNewFolder","UnknownMoveTargetError","newFolder","Tree","foundParentFolder","oldFolder","UnknownFolderUpdateError","foundOldParentFolder","foundNewParentFolder","UnknownFolderOrderError","newChildren","parentFolder","xbelObj","_serializeFolder","XMLBuilder","ignoreAttributes","build","xmlObj","XMLParser","ignorePiTags","parseTagValue","_parseFolder","XbelSerializer","mappingsData","folders","Mappings","add","setMappings","item1","item2","branch","GitAdapter","dir","fs","wipe","git","addRemote","remote","force","http","pruneTags","onAuth","checkout","ref","Errors","NotFoundError","what","mode","filepath","author","currentBranch","renameBranch","oldref","remoteRef","clearAllLocks","indexedDB","deleteDatabase","fileContents","PushRejectedError","listTags","lockTag","tag","dateLocked","lockTags","readFile","clearServer","defaultBranch","TIMEOUT","fetchQueue","concurrency","serverFolder","LinkwardenAdapter","sendRequest","collection","ownerId","success","loadAll","links","collections","rootCollection","buildTree","col","link","collectionId","verb","relUrl","returnRawResponse","timedOut","sendRequestNative","race","RequestTimeoutError","redirected","disableRedirects","storageLock","AsyncLock","NativeAccountStorage","entryName","defaultVal","deleteEntry","DefunctCryptography","Cryptography","encData","deleteCache","deleteMappings","_","actions","newDiff","Diff","itemTree","currentItem","targetAction","chain","targetItemInTree","newCurrentActions","newCurrentAction","folderMoves","DAG","action1","action2","skipErroneousActions","oldId","oldOrder","absoluteRoot","rootId","queue","absoluteRootPromise","BrowserTree","getAbsoluteRootFolder","isVivaldiBrowser","LocalFolderNotFoundError","recurse","isOnToolbar","rng","overrideTitle","isToolbar","TITLE_BOOKMARKS_BAR","TITLE_OTHER_BOOKMARKS","TITLE_BOOKMARKS_MENU","TITLE_MOBILE_BOOKMARKS","TITLE_SEPARATOR_VERT","TITLE_SEPARATOR_HORZ","int","update","bookmarkId","realTree","untouchedChildren","removeTree","relativeToRoot","ancestor","unshift","bms","windowType","tab","incognito","t","windowId","t1","t2","BookmarkTreeNodeType","discarded","awaitTabsUpdated","windows","originalTabs","onUpdated","oldTree","newTree","mergeable","checkHashes","hasCache","diffItem","findMoves","addReorders","diffFolder","diffBookmark","unmatchedChildren","old","newChild","oldBookmark","newBookmark","bookmarkHasChanged","hasChanged","createAction","removeAction","createdItem","removeActions","removedItem","oldIndex","removedItemClone","oldParentClone","oldItemClone","createdItemClone","newParentClone","newClonedItem","moves","targets","sources","duplicate","MAX_BACKOFF_INTERVAL","AlarmManager","ctl","backgroundSyncEnabled","checkSync","Network","connected","interval","getBackoffInterval","maxErrorCount","log2","pow","NativeController","schedule","listeners","accountsLocked","_ref","unlocked","hashedKey","getStatus","STATUS_SYNCING","updateStatus","STATUS_ERROR","overallStatus","STATUS_ALLGOOD","STATUS_DISABLED","unregistered","hasFeatureBulkImport","hasFeatureJavascriptLinks","bookmarkLock","serverRoot","NextcloudBookmarksAdapter","indexLoc","checkFeatureJavascriptLinks","acquireLock","releaseLock","clear","getBookmarksList","UnexpectedServerResponseError","getCompleteBookmarksTree","getSparseBookmarksTree","_getChildFolders","layers","folderJson","_findServerRoot","segment","currentChild","parent_folder","_getChildren","_getFolderHash","true","catch","childrenJson","recurseChildren","childFolder","folderHash","FormData","append","oldParentFolder","UnknownFolderParentUpdateError","newParentFolder","_getBookmark","getExistingBookmark","existingBookmark","updatedBookmark","upstreamMark","upstreamId","oldParentId","listIndex","countClick","_htmlentities_encode","char","charCodeAt","indent","nextIndent","html","parseByString","f","HtmlSerializer","getRootFolder","h3","first","attr","$","cheerio","rdt","parseNode","eq0","eq","toArray","ele","revertPlan","revertDiff","revertDonePlan","executeRevert","revertReorders","slavePlan","translateCompleteItem","fakeLocation","planRevert","mappedMoves","Symbol","setPrototypeOf","UnknownFolderMoveError","UnknownFolderRemoveError","UnknownFolderParentRemoveError","InconsistentServerStateError","UnclearedLockFileError","InterruptedSyncError"],"sourceRoot":""}