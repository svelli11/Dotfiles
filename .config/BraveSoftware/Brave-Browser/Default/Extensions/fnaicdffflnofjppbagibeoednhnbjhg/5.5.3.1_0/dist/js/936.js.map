{"version":3,"file":"936.js","mappings":"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","sources":["webpack://floccus/./src/lib/browser/BrowserAccountStorage.js","webpack://floccus/./src/test/test.js","webpack://floccus/./src/lib/adapters/Fake.js"],"sourcesContent":["import browser from '../browser-api'\nimport Cryptography from '../Crypto'\nimport DefunctCryptography from '../DefunctCrypto'\nimport Mappings from '../Mappings'\nimport { Folder, ItemLocation } from '../Tree'\nimport AsyncLock from 'async-lock'\nimport Logger from '../Logger'\n\nconst storageLock = new AsyncLock()\n\nexport default class BrowserAccountStorage {\n  constructor(id) {\n    this.accountId = id\n  }\n\n  static async changeEntry(entryName, fn, defaultVal) {\n    await storageLock.acquire(entryName, async() => {\n      let entry = await BrowserAccountStorage.getEntry(entryName, defaultVal)\n      entry = fn(entry)\n\n      await browser.storage.local.set({ [entryName]: JSON.stringify(entry) })\n    })\n  }\n\n  static async getEntry(entryName, defaultVal) {\n    let entry = await browser.storage.local.get(entryName)\n    try {\n      if (entry[entryName]) {\n        while (typeof entry[entryName] === 'string') {\n          entry[entryName] = JSON.parse(entry[entryName])\n        }\n        return entry[entryName]\n      } else {\n        return defaultVal\n      }\n    } catch (e) {\n      Logger.log('Error while parsing BrowserAccountStorage entry value ' + e.message)\n      console.error(e)\n      return defaultVal\n    }\n  }\n\n  static deleteEntry(entryName) {\n    return browser.storage.local.remove(entryName)\n  }\n\n  static async getAllAccounts() {\n    let accounts = await BrowserAccountStorage.getEntry(`accounts`, {})\n    return Object.keys(accounts)\n  }\n\n  async getAccountData(key) {\n    let accounts = await BrowserAccountStorage.getEntry(`accounts`, {})\n    let data = accounts[this.accountId]\n    if (key) {\n      if (data.iv) {\n        data.password = await DefunctCryptography.decryptAES(key, data.iv, data.password)\n        delete data.iv\n      } else {\n        data.password = await Cryptography.decryptAES(key, data.password, data.username)\n        if (data.passphrase) {\n          data.passphrase = await Cryptography.decryptAES(key, data.passphrase, data.username)\n        }\n      }\n    }\n    return data\n  }\n\n  async setAccountData(data, key) {\n    let encData = data\n    if (key) {\n      if (data.iv) {\n        delete data.iv\n      }\n      encData = {\n        ...data,\n        password: await Cryptography.encryptAES(key, data.password, data.username),\n        ...(data.passphrase && {passphrase: await Cryptography.encryptAES(key, data.passphrase, data.username)})\n      }\n    }\n    return BrowserAccountStorage.changeEntry(\n      `accounts`,\n      accounts => {\n        accounts[this.accountId] = encData\n        return accounts\n      },\n      {}\n    )\n  }\n\n  async deleteAccountData() {\n    await BrowserAccountStorage.changeEntry(`accounts`, accounts => {\n      delete accounts[this.accountId]\n      return accounts\n    })\n    await this.deleteCache()\n    await this.deleteMappings()\n  }\n\n  async initCache() {\n    await BrowserAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].cache`,\n      () => ({})\n    )\n  }\n\n  async getCache() {\n    const data = await BrowserAccountStorage.getEntry(\n      `bookmarks[${this.accountId}].cache`\n    )\n    return Folder.hydrate(data && Object.keys(data).length ? data : {location: ItemLocation.LOCAL})\n  }\n\n  async setCache(data) {\n    await BrowserAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].cache`,\n      () => data\n    )\n  }\n\n  async deleteCache() {\n    await BrowserAccountStorage.deleteEntry(`bookmarks[${this.accountId}].cache`)\n  }\n\n  async initMappings() {\n    await BrowserAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].mappings`,\n      () => ({})\n    )\n  }\n\n  async getMappings() {\n    const data = await BrowserAccountStorage.getEntry(\n      `bookmarks[${this.accountId}].mappings`\n    )\n    return new Mappings(\n      this,\n      data && Object.keys(data).length\n        ? data\n        : {\n          bookmarks: {\n            ServerToLocal: {},\n            LocalToServer: {}\n          },\n          folders: {\n            ServerToLocal: {},\n            LocalToServer: {}\n          }\n        }\n    )\n  }\n\n  async setMappings(data) {\n    await BrowserAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].mappings`,\n      () => data\n    )\n  }\n\n  async deleteMappings() {\n    await BrowserAccountStorage.deleteEntry(`bookmarks[${this.accountId}].mappings`)\n  }\n\n  async getCurrentContinuation() {\n    return BrowserAccountStorage.getEntry(`bookmarks[${this.accountId}].continuation`)\n  }\n\n  async setCurrentContinuation(continuation) {\n    await BrowserAccountStorage.changeEntry(`bookmarks[${this.accountId}].continuation`, (_) => ({...continuation, createdAt: Date.now()}), null)\n  }\n}\n","import chai from 'chai'\nimport chaiAsPromised from 'chai-as-promised'\nimport random from 'random'\nimport seedrandom from 'seedrandom'\nimport Account from '../lib/Account'\nimport { Bookmark, Folder, ItemLocation } from '../lib/Tree'\nimport browser from '../lib/browser-api'\nimport Crypto from '../lib/Crypto'\nimport * as AsyncParallel from 'async-parallel'\nimport DefunctCrypto from '../lib/DefunctCrypto'\nimport Controller from '../lib/Controller'\nimport FakeAdapter from '../lib/adapters/Fake'\nimport BrowserTree from '../lib/browser/BrowserTree'\n\nchai.use(chaiAsPromised)\nconst expect = chai.expect\n\nlet expectTreeEqual = function(tree1, tree2, ignoreEmptyFolders, checkOrder = true) {\n  expectTreeEqualRec(tree1, tree2, 0, ignoreEmptyFolders, checkOrder)\n}\n\nlet expectTreeEqualRec = function(tree1, tree2, recDepth, ignoreEmptyFolders, checkOrder) {\n  try {\n    expect(tree1.title).to.equal(tree2.title)\n    if (tree2.url) {\n      expect(tree1.url).to.equal(tree2.url)\n    } else {\n      if (checkOrder === false) {\n        tree2.children.sort((a, b) => {\n          if (a.title < b.title) return -1\n          if (a.title > b.title) return 1\n          return 0\n        })\n        tree1.children.sort((a, b) => {\n          if (a.title < b.title) return -1\n          if (a.title > b.title) return 1\n          return 0\n        })\n      }\n      let children1 = ignoreEmptyFolders\n        ? tree1.children.filter(child => !hasNoBookmarks(child))\n        : tree1.children\n      let children2 = ignoreEmptyFolders\n        ? tree2.children.filter(child => !hasNoBookmarks(child))\n        : tree2.children\n      expect(children1).to.have.length(children2.length)\n      children2.forEach((child2, i) => {\n        expectTreeEqualRec(children1[i], child2, recDepth + 1, ignoreEmptyFolders, checkOrder)\n      })\n    }\n  } catch (e) {\n    console.log(\n      `Trees are not equal: (recDepth: ${recDepth}, checkOrder: ${checkOrder}, ignoreEmptyFolders: ${ignoreEmptyFolders})\\n`,\n      'Tree 1:\\n' + tree1.inspect(0) + '\\n',\n      'Tree 2:\\n' + tree2.inspect(0)\n    )\n    throw e\n  }\n}\n\ndescribe('Floccus', function() {\n  this.timeout(120000) // no test should run longer than 120s\n  this.slow(20000) // 20s is slow\n\n  const params = (new URL(window.location.href)).searchParams\n  let SERVER, CREDENTIALS, ACCOUNTS, APP_VERSION, SEED, BROWSER, RANDOM_MANIPULATION_ITERATIONS\n  SERVER =\n    params.get('server') ||\n    'http://localhost'\n  CREDENTIALS = {\n    username: params.get('username') || 'admin',\n    password: params.get('password') || 'admin'\n  }\n  APP_VERSION = params.get('app_version') || 'stable'\n  BROWSER = params.get('browser') || 'firefox'\n\n  SEED = (new URL(window.location.href)).searchParams.get('seed') || Math.random() + ''\n  console.log('RANDOMNESS SEED', SEED)\n  random.use(seedrandom(SEED))\n\n  RANDOM_MANIPULATION_ITERATIONS = 35\n\n  ACCOUNTS = [\n    FakeAdapter.getDefaultValues(),\n    {\n      ...FakeAdapter.getDefaultValues(),\n      noCache: true,\n    },\n    {\n      type: 'nextcloud-bookmarks',\n      url: SERVER,\n      ...CREDENTIALS\n    },\n    {\n      type: 'nextcloud-bookmarks',\n      url: SERVER,\n      serverRoot: '/my folder/some subfolder',\n      ...CREDENTIALS\n    },\n    {\n      type: 'webdav',\n      url: `${SERVER}/remote.php/webdav/`,\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      ...CREDENTIALS\n    },\n    {\n      type: 'webdav',\n      url: `${SERVER}/remote.php/webdav/`,\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      passphrase: random.float(),\n      ...CREDENTIALS\n    },\n    {\n      type: 'webdav',\n      url: `${SERVER}/remote.php/webdav/`,\n      bookmark_file: 'bookmarks.html',\n      bookmark_file_type: 'html',\n      ...CREDENTIALS\n    },\n    {\n      type: 'webdav',\n      url: `${SERVER}/remote.php/webdav/`,\n      bookmark_file: 'bookmarks.html',\n      bookmark_file_type: 'html',\n      passphrase: random.float(),\n      ...CREDENTIALS\n    },\n    {\n      type: 'git',\n      url: `${SERVER}/test.git`,\n      branch: 'main',\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      ...CREDENTIALS\n    },\n    {\n      type: 'git',\n      url: `${SERVER}/test.git`,\n      branch: 'main',\n      bookmark_file: 'bookmarks.html',\n      bookmark_file_type: 'html',\n      ...CREDENTIALS\n    },\n    {\n      type: 'google-drive',\n      bookmark_file: Math.random() + '.xbel',\n      password: '',\n      refreshToken: CREDENTIALS.password,\n    },\n    {\n      type: 'google-drive',\n      bookmark_file: Math.random() + '.xbel',\n      password: random.float(),\n      refreshToken: CREDENTIALS.password,\n    },\n    {\n      type: 'linkwarden',\n      url: SERVER,\n      serverFolder: 'Floccus-' + Math.random(),\n      ...CREDENTIALS,\n    },\n  ]\n\n  before(async function() {\n    const controller = await Controller.getSingleton()\n    controller.setEnabled(false)\n  })\n  after(async function() {\n    const controller = await Controller.getSingleton()\n    controller.setEnabled(true)\n  })\n\n  describe('Crypto', function() {\n    it('should encrypt and decrypt correctly', async function() {\n      const passphrase = 'test'\n      const salt = 'blah'\n      const message = 'I don\\'t know'\n      const payload = await Crypto.encryptAES(passphrase, message, salt)\n      console.log(payload)\n      const cleartext = await Crypto.decryptAES(passphrase, payload, salt)\n      expect(cleartext).to.equal(message)\n      console.log(cleartext)\n      console.log(message)\n    })\n\n    it('should encrypt and decrypt correctly (even with defunct crypto)', async function() {\n      const passphrase = 'test'\n      const message = 'I don\\'t know'\n      const payload = await DefunctCrypto.encryptAES(passphrase, DefunctCrypto.iv, message)\n      console.log(payload)\n      const cleartext = await DefunctCrypto.decryptAES(passphrase, DefunctCrypto.iv, payload)\n      expect(cleartext).to.equal(message)\n      console.log(cleartext)\n      console.log(message)\n    })\n  })\n\n  ACCOUNTS.forEach(ACCOUNT_DATA => {\n    describe(`${stringifyAccountData(ACCOUNT_DATA)} test ${ACCOUNT_DATA.serverRoot ? 'subfolder' : 'root'} Account`, function() {\n      let account\n      beforeEach('set up account', async function() {\n        account = await Account.create(ACCOUNT_DATA)\n      })\n      afterEach('clean up account', async function() {\n        if (account) {\n          let localRoot = account.getData().localRoot\n          if (localRoot) await browser.bookmarks.removeTree(localRoot)\n          await account.delete()\n        }\n      })\n      it('should create an account', async function() {\n        const secondInstance = await Account.get(account.id)\n        expect(secondInstance.getData()).to.deep.equal(account.getData())\n      })\n      it('should save and restore an account', async function() {\n        await account.setData(ACCOUNT_DATA)\n        expect(account.getData()).to.deep.equal({...account.getData(), ...ACCOUNT_DATA})\n\n        const secondInstance = await Account.get(account.id)\n        expect(secondInstance.getData()).to.deep.equal({...secondInstance.getData(), ...ACCOUNT_DATA})\n      })\n      it('should delete an account', async function() {\n        await account.delete()\n        expect(Account.get(account.id)).to.be.rejected\n        account = null // so afterEach notices it's deleted already\n      })\n      it('should not be initialized upon creation', async function() {\n        expect(await account.isInitialized()).to.be.false\n      })\n    })\n    describe(`${stringifyAccountData(ACCOUNT_DATA)} test ${ACCOUNT_DATA.serverRoot ? 'subfolder' : 'root'} Sync`,\n      function() {\n        context('with one client', function() {\n          let account\n          beforeEach('set up account', async function() {\n            account = await Account.create(ACCOUNT_DATA)\n            if (ACCOUNT_DATA.type === 'fake') {\n              account.server.bookmarksCache = new Folder({\n                id: '',\n                title: 'root',\n                location: 'Server'\n              })\n            }\n            await account.init()\n            if (ACCOUNT_DATA.noCache) {\n              account.storage.setCache = () => {\n                // noop\n              }\n              account.storage.setMappings = () => {\n                // noop\n              }\n            }\n          })\n          afterEach('clean up account', async function() {\n            if (!account) return\n            try {\n              await browser.bookmarks.removeTree(account.getData().localRoot)\n            } catch (e) {\n              console.error(e)\n            }\n            if (ACCOUNT_DATA.type === 'git') {\n              await account.server.clearServer()\n            } else if (ACCOUNT_DATA.type !== 'fake') {\n              await account.setData({ serverRoot: null })\n              account.lockTimeout = 0\n              const tree = await getAllBookmarks(account)\n              await withSyncConnection(account, async() => {\n                await AsyncParallel.each(tree.children, async child => {\n                  if (child instanceof Folder) {\n                    await account.server.removeFolder(child)\n                  } else {\n                    await account.server.removeBookmark(child)\n                  }\n                })\n              })\n            }\n            if (ACCOUNT_DATA.type === 'google-drive') {\n              const fileList = await account.server.listFiles('name = ' + \"'\" + account.server.bookmark_file + \"'\")\n              const files = fileList.files\n              for (const file of files) {\n                await account.server.deleteFile(file.id)\n              }\n              if (files.length > 1) {\n                throw new Error('Google Drive sync left more than one file behind')\n              }\n            }\n            await account.delete()\n          })\n          it('should create local bookmarks on the server', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({ title: 'url', url: bookmark.url })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create empty local folders on the server', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create local javascript bookmarks on the server', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'javascript:void(0)',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({ title: 'url', url: bookmark.url })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url2',\n              url: 'javascript:void(1)',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree2 = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree2,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({ title: 'url', url: bookmark.url }),\n                          new Bookmark({ title: 'url2', url: bookmark2.url }),\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should update the server on local changes', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const newData = { title: 'blah' }\n            await browser.bookmarks.update(bookmark.id, newData)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: newData.title,\n                            url: bookmark.url\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local changes of duplicates', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const newData = { title: 'blah' }\n            await browser.bookmarks.update(bookmark2.id, newData)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: newData.title,\n                            url: bookmark1.url\n                          })\n                        ]\n                      }),\n                      new Bookmark({\n                        title: ACCOUNT_DATA.type === 'nextcloud-bookmarks' ? newData.title : bookmark2.title,\n                        url: bookmark1.url\n                      }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local changes of url collisions', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'ur1l',\n              url: 'http://ur1.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const newData = { url: 'http://ur.l/' }\n            await browser.bookmarks.update(bookmark1.id, newData)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: bookmark2.title,\n                            url: bookmark2.url\n                          })\n                        ]\n                      }),\n                      new Bookmark({\n                        title: ACCOUNT_DATA.type === 'nextcloud-bookmarks' ? bookmark2.title : bookmark1.title,\n                        url: newData.url\n                      }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local removals', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.remove(bookmark.id)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local removals and recreations', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            expect(\n              (await getAllBookmarks(account)).children\n            ).to.have.lengthOf(0)\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.remove(bookmark.id)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree2 = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree2,\n              new Folder({\n                title: tree2.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            url: bookmark2.url,\n                            title: bookmark2.title\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local folder moves', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'test',\n              url: 'http://ureff.l/',\n              parentId: fooFolder.id\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(barFolder.id, { parentId: localRoot })\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark({ title: 'test', url: 'http://ureff.l/' })\n                    ]\n                  }),\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create server bookmarks locally', async function() {\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            let fooFolderId, barFolderId, serverMark\n            await withSyncConnection(account, async() => {\n              fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo'}))\n              barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar'}))\n              serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId\n              }\n\n              await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: serverMark.title,\n                            url: serverMark.url\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create empty server folders locally', async function() {\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            await withSyncConnection(account, async() => {\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo'}))\n              await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar'}))\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update local bookmarks on server changes', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            const adapter = account.server\n\n            const serverTree = await getAllBookmarks(account)\n            let fooFolderId, barFolderId, serverMarkId, serverMark\n            await withSyncConnection(account, async() => {\n              fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo'}))\n              barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar'}))\n              serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId\n              }\n\n              serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync() // propage creation\n            expect(account.getData().error).to.not.be.ok\n\n            const newServerMark = {\n              ...serverMark,\n              title: 'blah',\n              id: serverMarkId\n            }\n            await withSyncConnection(account, async() => {\n              await adapter.updateBookmark(new Bookmark(newServerMark))\n            })\n\n            await account.sync() // propage update\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: newServerMark.title,\n                            url: newServerMark.url\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update local bookmarks on server removals', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            const adapter = account.server\n\n            const serverTree = await getAllBookmarks(account)\n            if (adapter.onSyncStart) await adapter.onSyncStart()\n            const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo'}))\n            const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar'}))\n            const serverMark = {\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolderId\n            }\n\n            const serverMarkId = await adapter.createBookmark(\n              new Bookmark(serverMark)\n            )\n            if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n            await account.sync() // propage creation\n            expect(account.getData().error).to.not.be.ok\n\n            await withSyncConnection(account, async() => {\n              await adapter.removeBookmark({...serverMark, id: serverMarkId})\n            })\n\n            await account.sync() // propage update\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should not delete additions while sync is running', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n\n            const syncPromise = account.sync() // propagate to server\n            await new Promise(resolve => setTimeout(resolve, 1000))\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://secondur.l/',\n              parentId: fooFolder.id\n            })\n            await syncPromise\n\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [new Bookmark({\n                          title: 'url',\n                          url: 'http://ur.l/',\n                        })]\n                      }),\n                      new Bookmark({\n                        title: 'url2',\n                        url: 'http://secondur.l/',\n                      }),\n                    ]\n                  }),\n                ]\n              }),\n              false\n            )\n          })\n          it('should be able to handle duplicates', async function() {\n            const localRoot = account.getData().localRoot\n            const bookmarkData = {\n              title: 'url',\n              url: 'http://ur.l/'\n            }\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              ...bookmarkData,\n              parentId: fooFolder.id\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              ...bookmarkData,\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(barFolder.id, { parentId: localRoot })\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [new Bookmark(bookmarkData)]\n                  }),\n                  new Folder({\n                    title: 'bar',\n                    children: [new Bookmark(bookmarkData)]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should deduplicate unnormalized URLs', async function() {\n            const adapter = account.server\n\n            // create bookmark on server\n            const serverTree = await getAllBookmarks(account)\n            if (adapter.onSyncStart) await adapter.onSyncStart()\n            const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n            const serverMark1 = {\n              title: 'url',\n              url: 'http://ur.l/foo/bar?a=b&foo=b%C3%A1r+foo',\n              location: ItemLocation.SERVER\n            }\n            const serverMark2 = {\n              title: 'url2',\n              url: 'http://ur2.l/foo/bar?a=b&foo=b%C3%A1r+foo',\n              location: ItemLocation.SERVER\n            }\n            await adapter.createBookmark(\n              new Bookmark({ ...serverMark1, parentId: fooFolderId })\n            )\n            await adapter.createBookmark(\n              new Bookmark({ ...serverMark2, parentId: fooFolderId })\n            )\n            if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n            // create bookmark locally\n            const localRoot = account.getData().localRoot\n            const localMark1 = {\n              title: 'url',\n              url: 'http://ur.l/foo/bar?a=b&foo=bár+foo'\n            }\n            const localMark2 = {\n              title: 'url2',\n              url: 'http://ur2.l/foo/bar?a=b&foo=bár+foo'\n            }\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              ...localMark1,\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              ...localMark2,\n              parentId: fooFolder.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            // Sync again, so client can deduplicate\n            // necessary if using bookmarks < v0.12 or WebDAV\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark(serverMark1),\n                      new Bookmark(serverMark2)\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should deduplicate unnormalized URLs without getting stuck', async function() {\n            if (ACCOUNT_DATA.type === 'nextcloud-bookmarks' && (APP_VERSION !== 'stable' && APP_VERSION !== 'master' && APP_VERSION !== 'stable3')) {\n              this.skip()\n            }\n\n            // create bookmark locally\n            const localRoot = account.getData().localRoot\n            const localMark1 = {\n              title: 'url',\n              url: 'http://nextcloud.com/'\n            }\n            const localMark2 = {\n              title: 'url2',\n              url: 'https://nextcloud.com'\n            }\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              ...localMark1,\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              ...localMark2,\n              parentId: fooFolder.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            expect(account.getData().error).to.not.be.ok\n\n            // Sync again, so client can deduplicate\n            // necessary if using bookmarks < v0.12 or WebDAV\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark(localMark1),\n                      new Bookmark(localMark2)\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should not fail when moving both folders and contents', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'test',\n              url: 'http://ureff.l/',\n              parentId: fooFolder.id\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(barFolder.id, { parentId: localRoot })\n            await browser.bookmarks.move(fooFolder.id, {\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.move(bookmark1.id, {\n              parentId: barFolder.id\n            })\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                      new Folder({\n                        title: 'foo',\n                        children: [],\n                      }),\n                      new Bookmark({ title: 'test', url: 'http://ureff.l/' }),\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should not fail when both moving folders and deleting their contents', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'test',\n              url: 'http://ureff.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://uawdgr.l/',\n              parentId: fooFolder.id\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark3 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://urzur.l/',\n              parentId: barFolder.id\n            })\n            const bookmark4 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://uadgr.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(barFolder.id, { parentId: localRoot })\n            await browser.bookmarks.move(fooFolder.id, {\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.remove(bookmark3.id)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark(bookmark4),\n                      new Folder({\n                        title: 'foo',\n                        children: [\n                          new Bookmark(bookmark1),\n                          new Bookmark(bookmark2)\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should handle strange characters well', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo!\"§$%&/()=?\"',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: \"bar=?*'Ä_:-^;<script>\",\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url|!\"=)/§_:;Ä\\'*ü\"',\n              url: 'http://ur.l/?a&b=<script>',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo!\"§$%&/()=?\"',\n                    children: [\n                      new Folder({\n                        title: \"bar=?*'Ä_:-^;<script>\",\n                        children: [\n                          new Bookmark({\n                            title: 'url|!\"=)/§_:;Ä\\'*ü\"',\n                            url: bookmark.url\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should be able to delete a server folder', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.removeTree(fooFolder.id)\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: []\n              }),\n              false\n            )\n          })\n          it('should be able to delete a local folder', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            const adapter = account.server\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            await withSyncConnection(account, async() => {\n              await adapter.removeFolder({id: tree.children[0].id})\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: []\n              }),\n              false\n            )\n          })\n          it('should be ok if both server and local bookmark are removed', async function() {\n            const adapter = account.server\n            let serverTree = await getAllBookmarks(account)\n            if (adapter.onSyncStart) await adapter.onSyncStart()\n            const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n            const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n            const serverMark = {\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolderId,\n              location: ItemLocation.SERVER\n            }\n            const serverMarkId = await adapter.createBookmark(\n              new Bookmark(serverMark)\n            )\n            if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n            await account.sync() // propagate creation\n            expect(account.getData().error).to.not.be.ok\n\n            await withSyncConnection(account, async() => {\n              await adapter.removeBookmark({...serverMark, id: serverMarkId})\n            })\n            await account.sync() // propagate update\n\n            expect(account.getData().error).to.not.be.ok\n            const localTree = await account.localTree.getBookmarksTree(true)\n\n            serverTree = await getAllBookmarks(account)\n\n            // Root must also be equal in the assertion\n            localTree.title = serverTree.title\n\n            expectTreeEqual(localTree, serverTree)\n          })\n          it('should ignore duplicates in the same folder', async function() {\n            if (ACCOUNT_DATA.type !== 'nextcloud-bookmarks') {\n              return this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should move items successfully even into new folders', async function() {\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const subFolder = await browser.bookmarks.create({\n              title: 'sub',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.move(bookmark1.id, { parentId: subFolder.id })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'sub',\n                        children: [\n                          new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'sub',\n                        children: [\n                          new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should move items successfully when mixing creation and moving (1)', async function() {\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const topFolder = await browser.bookmarks.create({\n              title: 'top',\n              parentId: localRoot\n            })\n            const subFolder = await browser.bookmarks.create({\n              title: 'sub',\n              parentId: topFolder.id\n            })\n            await browser.bookmarks.move(fooFolder.id, { parentId: subFolder.id })\n            await browser.bookmarks.move(barFolder.id, { parentId: fooFolder.id })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'top',\n                    children: [\n                      new Folder({\n                        title: 'sub',\n                        children: [\n                          new Folder({\n                            title: 'foo',\n                            children: [\n                              new Folder({\n                                title: 'bar',\n                                children: [\n                                  new Bookmark({\n                                    title: 'url',\n                                    url: 'http://ur.l/'\n                                  })\n                                ]\n                              })\n                            ]\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'top',\n                    children: [\n                      new Folder({\n                        title: 'sub',\n                        children: [\n                          new Folder({\n                            title: 'foo',\n                            children: [\n                              new Folder({\n                                title: 'bar',\n                                children: [\n                                  new Bookmark({\n                                    title: 'url',\n                                    url: 'http://ur.l/'\n                                  })\n                                ]\n                              })\n                            ]\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should move items successfully when mixing creation and moving (2)', async function() {\n            const localRoot = account.getData().localRoot\n\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: aFolder.id\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            const dFolder = await browser.bookmarks.create({\n              title: 'd',\n              parentId: cFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: dFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const eFolder = await browser.bookmarks.create({\n              title: 'e',\n              parentId: localRoot\n            })\n            await browser.bookmarks.move(bFolder.id, { parentId: eFolder.id })\n            const fFolder = await browser.bookmarks.create({\n              title: 'f',\n              parentId: bFolder.id\n            })\n            await browser.bookmarks.move(cFolder.id, { parentId: fFolder.id })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'e',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Folder({\n                            title: 'f',\n                            children: [\n                              new Folder({\n                                title: 'c',\n                                children: [\n                                  new Folder({\n                                    title: 'd',\n                                    children: [\n                                      new Bookmark({\n                                        title: 'url',\n                                        url: 'http://ur.l/'\n                                      })\n                                    ]\n                                  })\n                                ]\n                              })\n                            ]\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'e',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Folder({\n                            title: 'f',\n                            children: [\n                              new Folder({\n                                title: 'c',\n                                children: [\n                                  new Folder({\n                                    title: 'd',\n                                    children: [\n                                      new Bookmark({\n                                        title: 'url',\n                                        url: 'http://ur.l/'\n                                      })\n                                    ]\n                                  })\n                                ]\n                              })\n                            ]\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should move items without creating a folder loop', async function() {\n            if (APP_VERSION !== 'stable' && APP_VERSION !== 'master') {\n              this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: bFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // sync to server again for order to kick in\n            expect(account.getData().error).to.not.be.ok\n\n            // move b into a in client\n            await browser.bookmarks.move(bFolder.id, { parentId: aFolder.id })\n\n            // move a into b on server\n            await withSyncConnection(account, async() => {\n              const initialTree = await account.server.getBookmarksTree(true)\n              const aFolder = initialTree.children[0]\n              const bFolder = initialTree.children[1]\n              aFolder.parentId = bFolder.id\n              await account.server.updateFolder(aFolder)\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Bookmark({\n                            title: 'url',\n                            url: 'http://ur.l/',\n                          })\n\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            localTree.title = tree.title\n            expectTreeEqual(\n              localTree,\n              tree,\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should move items without confusing folders', async function() {\n            const localRoot = account.getData().localRoot\n\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            const dFolder = await browser.bookmarks.create({\n              title: 'd',\n              parentId: localRoot\n            })\n            const cFolder1 = await browser.bookmarks.create({\n              title: 'c',\n              parentId: aFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: cFolder1.id\n            })\n            const cFolder2 = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'test',\n              url: 'http://urrr.l/',\n              parentId: cFolder2.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // make sure order is propagated\n            expect(account.getData().error).to.not.be.ok\n\n            await account.init()\n\n            // move b into a in client\n            await browser.bookmarks.move(cFolder1.id, { parentId: localRoot })\n            await browser.bookmarks.move(cFolder2.id, { parentId: dFolder.id })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'b',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'd',\n                    children: [\n                      new Folder({\n                        title: 'c',\n                        children: [\n                          new Bookmark({\n                            title: 'test',\n                            url: 'http://urrr.l/',\n                          })\n                        ]\n                      })\n                    ]\n                  }),\n                  new Folder({\n                    title: 'c',\n                    children: [\n                      new Bookmark({\n                        title: 'url',\n                        url: 'http://ur.l/',\n                      })\n                    ]\n                  }),\n                ]\n              }),\n              false,\n              false\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            localTree.title = tree.title\n            expectTreeEqual(\n              localTree,\n              tree,\n              false,\n              false\n            )\n          })\n          it('should integrate existing items from both sides', async function() {\n            const localRoot = account.getData().localRoot\n\n            const adapter = account.server\n\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: aFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: aFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur.l/dalfk',\n              parentId: bFolder.id\n            })\n\n            let aFolderId, bookmark1Id,bFolderId,bookmark2Id\n            await withSyncConnection(account, async() => {\n              aFolderId = await adapter.createFolder(\n                new Folder({parentId: (await adapter.getBookmarksTree()).id,\n                  title: 'a'})\n              )\n              bookmark1Id = await adapter.createBookmark(\n                new Bookmark({\n                  title: 'url',\n                  url: 'http://ur.l',\n                  parentId: aFolderId\n                })\n              )\n\n              bFolderId = await adapter.createFolder(new Folder({parentId: aFolderId, title: 'b'}))\n              bookmark2Id = await adapter.createBookmark(\n                new Bookmark({\n                  title: 'url2',\n                  url: 'http://ur.l/dalfk',\n                  parentId: bFolderId\n                })\n              )\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Bookmark({\n                            title: 'url2',\n                            url: 'http://ur.l/dalfk'\n                          })\n                        ]\n                      }),\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false /* checkOrder */\n            )\n\n            expect(tree.findBookmark(bookmark1Id)).to.be.ok\n            expect(tree.findBookmark(bookmark2Id)).to.be.ok\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Bookmark({\n                            title: 'url2',\n                            url: 'http://ur.l/dalfk'\n                          })\n                        ]\n                      }),\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false /* checkOrder */\n            )\n\n            expect(localTree.findBookmark(bookmark1.id)).to.be.ok\n            expect(localTree.findBookmark(bookmark2.id)).to.be.ok\n          })\n          it('should error when deleting too much local data', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await Promise.all([\n              'http://ur.l/',\n              'http://ur.ll/',\n              'http://ur2.l/',\n              'http://ur3.l/',\n              'http://ur4.l/',\n              'http://ur5.l/',\n              'http://ur6.l/',\n              'http://ur7.l/',\n              'http://ur8.l/',\n              'http://ur9.l/',\n              'http://ur10.l/',\n            ].map(url => browser.bookmarks.create({\n              title: 'url',\n              url,\n              parentId: barFolder.id\n            })))\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            // Remove everything on the server\n            const tree = await getAllBookmarks(account)\n            await withSyncConnection(account, async() => {\n              await AsyncParallel.each(tree.children, async child => {\n                if (child instanceof Folder) {\n                  await account.server.removeFolder(child)\n                } else {\n                  await account.server.removeBookmark(child)\n                }\n              })\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.be.ok // should have errored\n          })\n          it('should leave alone unaccepted bookmarks entirely', async function() {\n            if (!~ACCOUNT_DATA.type.indexOf('nextcloud')) {\n              return this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'chrome://extensions/',\n              parentId: fooFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // propagate to server -- if we had cached the unacceptables, they'd be deleted now\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                      new Folder({\n                        title: 'foo',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                      new Folder({\n                        title: 'foo',\n                        children: [\n                          new Bookmark({\n                            title: 'url2',\n                            url: 'chrome://extensions/'\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false\n            )\n          })\n          it('should convert vertical and horizontal separators', async function() {\n            if (BROWSER !== 'firefox') {\n              this.skip()\n              return\n            }\n\n            // Remove all nodes except the system nodes:\n            const deleteNonSysNodes = async(delNodeId) => {\n              let delChildren = await browser.bookmarks.getChildren(delNodeId)\n              for (const delChild of delChildren) {\n                await deleteNonSysNodes(delChild.id)\n              }\n              if (!delNodeId.endsWith('_____')) {\n                await browser.bookmarks.remove(delNodeId)\n              }\n            }\n            await deleteNonSysNodes('root________')\n\n            await browser.bookmarks.create({\n              title: 'url1',\n              url: 'http://url1/',\n              parentId: 'menu________'\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: 'menu________'\n            })\n            const toolbarNameNormalFolder = await browser.bookmarks.create({\n              title: BrowserTree.TITLE_BOOKMARKS_BAR,\n              parentId: 'menu________'\n            })\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://url2/',\n              parentId: toolbarNameNormalFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: toolbarNameNormalFolder.id\n            })\n\n            await browser.bookmarks.create({\n              title: 'url3',\n              url: 'http://url3/',\n              parentId: 'toolbar_____'\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: 'toolbar_____'\n            })\n            const onToolbarNormalFolder = await browser.bookmarks.create({\n              title: 'A Folder',\n              parentId: 'toolbar_____'\n            })\n            await browser.bookmarks.create({\n              title: 'url4',\n              url: 'http://url4/',\n              parentId: onToolbarNormalFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: onToolbarNormalFolder.id\n            })\n\n            let brTree = new BrowserTree('Dummy Storage', 'root________')\n            let bmTree = await brTree.getBookmarksTree()\n\n            expectTreeEqual(\n              bmTree,\n              new Folder({title: undefined,\n                children: [\n                  new Folder({title: 'Bookmarks Menu',\n                    children: [\n                      new Bookmark({title: 'url1', url: 'http://url1/'}),\n                      new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=242649'}),\n                      new Folder({title: 'Bookmarks Bar',\n                        children: [\n                          new Bookmark({title: 'url2', url: 'http://url2/'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=591710'}),\n                        ]}),\n                    ]}),\n                  new Folder({title: 'Bookmarks Bar',\n                    children: [\n                      new Bookmark({title: 'url3', url: 'http://url3/'}),\n                      new Bookmark({title: '', url: 'https://separator.floccus.org/vertical.html?id=616887'}),\n                      new Folder({title: 'A Folder',\n                        children: [\n                          new Bookmark({title: 'url4', url: 'http://url4/'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=890296'}),\n                        ]}),\n                    ]})\n                ]}),\n              true\n            )\n            await deleteNonSysNodes('root________')\n          })\n          it('should sync separators', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              this.skip()\n              return\n            }\n            if (BROWSER !== 'firefox') {\n              this.skip()\n              return\n            }\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            const localRoot = account.getData().localRoot\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur2.l',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: fooFolder.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            let localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({title: localTree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=467366'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=731368'})\n                        ]})\n                    ]})\n                ]}),\n              false\n            )\n            expectTreeEqual(\n              tree,\n              new Folder({title: tree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=467366'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=731368'})\n                        ]})\n                    ]})\n                ]}),\n              false\n            )\n\n            console.log('initial sync done')\n\n            await withSyncConnection(account, async() => {\n              // move first separator\n              await account.server.updateBookmark({...tree.children[0].children[0].children[1], parentId: tree.children[0].id})\n            })\n\n            console.log('move done')\n\n            await account.sync() // propagate to browser\n            expect(account.getData().error).to.not.be.ok\n\n            localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({title: localTree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=467366'})\n                        ]}),\n                      new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=379999'})\n                    ]})\n                ]}),\n              false\n            )\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({title: tree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=731368'})\n                        ]}),\n                      new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=467366'})\n                    ]})\n                ]}),\n              false\n            )\n          })\n          it('should sync separators 2', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              this.skip()\n              return\n            }\n            if (BROWSER !== 'firefox') {\n              this.skip()\n              return\n            }\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur2.l',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: fooFolder.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            let localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({title: localTree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=467366'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=731368'})\n                        ]}),\n                    ]}),\n                ]}),\n              false\n            )\n            expectTreeEqual(\n              tree,\n              new Folder({title: tree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=467366'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=731368'})\n                        ]}),\n                    ]}),\n                ]}),\n              false\n            )\n\n            console.log('initial sync done')\n\n            await withSyncConnection(account, async() => {\n              // remove first separator\n              await account.server.removeBookmark(tree.children[0].children[0].children[1])\n            })\n            await account.sync() // propagate to browser\n            expect(account.getData().error).to.not.be.ok\n\n            localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({title: localTree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯', url: 'https://separator.floccus.org/?id=467366'})\n                        ]}),\n                    ]}),\n\n                ]}),\n              false\n            )\n          })\n          it('should sync root folder successfully', async function() {\n            const [root] = await browser.bookmarks.getTree()\n            await account.setData({ localRoot: root.id })\n            account = await Account.get(account.id)\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: root.children[0].id\n            })\n            await browser.bookmarks.create({\n              title: 'foo',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // propagate to server -- if we had cached the unacceptables, they'd be deleted now\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            const newRoot = await account.localTree.getBookmarksTree()\n            tree.title = newRoot.title\n            expectTreeEqual(\n              tree,\n              newRoot,\n              false,\n              false\n            )\n\n            // Switch it back to something harmless, so we don't attempt to clean up the root folder\n            await account.setData({ localRoot: barFolder.id})\n            account = await Account.get(account.id)\n          })\n          it('should sync root folder ignoring unsupported folders', async function() {\n            const [root] = await browser.bookmarks.getTree()\n\n            await Promise.all(\n              root.children.flatMap(child => child.children.map(child => browser.bookmarks.removeTree(child.id)))\n            )\n\n            const originalFolderId = account.getData().localRoot\n            await account.setData({ localRoot: root.id, })\n            account = await Account.get(account.id)\n            const adapter = account.server\n\n            let bookmark\n            let serverTree = await getAllBookmarks(account)\n            await withSyncConnection(account, async() => {\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url2',\n                url: 'http://ur2.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const id = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              bookmark = {...serverMark, id}\n            })\n\n            const secondBookmarkFolderTitle = root.children[0].title\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: root.children[0].id\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            serverTree = await getAllBookmarks(account)\n            const newRoot = await account.localTree.getBookmarksTree()\n            expect(serverTree.children).to.have.lengthOf(newRoot.children.length + 1)\n\n            await withSyncConnection(account, async() => {\n              bookmark.parentId = serverTree.children.find(folder => folder.title !== 'foo').id\n              const fooFolder = serverTree.children.find(folder => folder.title === 'foo')\n              await adapter.updateBookmark(new Bookmark(bookmark))\n              // toLowerCase to accommodate chrome (since we normalize the title)\n              const secondBookmark = serverTree.children.find(folder => folder.title.toLowerCase() === secondBookmarkFolderTitle.toLowerCase()).children.find(item => item.type === 'bookmark')\n              secondBookmark.parentId = fooFolder.id\n              await adapter.updateBookmark(secondBookmark)\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            serverTree = await getAllBookmarks(account)\n            const localTreeAfterSync = await account.localTree.getBookmarksTree()\n            expect(serverTree.children).to.have.lengthOf(localTreeAfterSync.children.length + 1)\n\n            // Switch it back to something harmless, so we don't attempt to clean up the root folder\n            await account.setData({ localRoot: originalFolderId})\n            account = await Account.get(account.id)\n          })\n          it('should synchronize ordering', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const folder1 = await browser.bookmarks.create({\n              title: 'folder1',\n              parentId: fooFolder.id\n            })\n            const folder2 = await browser.bookmarks.create({\n              title: 'folder2',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url1',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur.ll/',\n              parentId: fooFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(bookmark1.id, { index: 0 })\n            await browser.bookmarks.move(folder1.id, { index: 1 })\n            await browser.bookmarks.move(bookmark2.id, { index: 2 })\n            await browser.bookmarks.move(folder2.id, { index: 3 })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark({\n                        title: 'url1',\n                        url: bookmark1.url\n                      }),\n                      new Folder({\n                        title: 'folder1',\n                        children: []\n                      }),\n                      new Bookmark({\n                        title: 'url2',\n                        url: bookmark2.url\n                      }),\n                      new Folder({\n                        title: 'folder2',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              true\n            )\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark({\n                        title: 'url1',\n                        url: bookmark1.url\n                      }),\n                      new Folder({\n                        title: 'folder1',\n                        children: []\n                      }),\n                      new Bookmark({\n                        title: 'url2',\n                        url: bookmark2.url\n                      }),\n                      new Folder({\n                        title: 'folder2',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              true\n            )\n          })\n          context('with slave mode', function() {\n            it(\"shouldn't create local bookmarks on the server\", async function() {\n              await account.setData({ strategy: 'slave' })\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expect(tree.children).to.have.lengthOf(0)\n            })\n            it(\"shouldn't update the server on local changes\", async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              const originalTree = await getAllBookmarks(account)\n              await account.setData({ strategy: 'slave' })\n\n              const newData = { title: 'blah' }\n              await browser.bookmarks.update(bookmark.id, newData)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't update the server on local removals\", async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              const originalTree = await getAllBookmarks(account)\n              await account.setData({ strategy: 'slave' })\n\n              await browser.bookmarks.remove(bookmark.id)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't update the server on local folder moves\", async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              await browser.bookmarks.create({\n                title: 'test',\n                url: 'http://ureff.l/',\n                parentId: fooFolder.id\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              const originalTree = await getAllBookmarks(account)\n              await account.setData({ strategy: 'slave' })\n\n              await browser.bookmarks.move(barFolder.id, {\n                parentId: localRoot\n              })\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it('should create server bookmarks locally', async function() {\n              await account.setData({ strategy: 'slave' })\n              const adapter = account.server\n              const serverTree = await getAllBookmarks(account)\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: [\n                            new Bookmark({\n                              title: serverMark.title,\n                              url: serverMark.url\n                            })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n            })\n            it('should update local bookmarks on server changes', async function() {\n              if (ACCOUNT_DATA.noCache) {\n                return this.skip()\n              }\n              await account.setData({ strategy: 'slave' })\n              const adapter = account.server\n\n              const serverTree = await getAllBookmarks(account)\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync() // propage creation\n              expect(account.getData().error).to.not.be.ok\n\n              const newServerMark = {\n                ...serverMark,\n                title: 'blah',\n                id: serverMarkId,\n                location: ItemLocation.SERVER\n              }\n\n              await withSyncConnection(account, async() => {\n                await adapter.updateBookmark(new Bookmark(newServerMark))\n              })\n\n              await account.sync() // propage update\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: [\n                            new Bookmark({\n                              title: newServerMark.title,\n                              url: newServerMark.url\n                            })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n            })\n            it('should update local bookmarks on server removals', async function() {\n              await account.setData({ strategy: 'slave' })\n              const adapter = account.server\n              const serverTree = await getAllBookmarks(account)\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync() // propage creation\n              expect(account.getData().error).to.not.be.ok\n\n              await withSyncConnection(account, async() => {\n                await adapter.removeBookmark({...serverMark, id: serverMarkId})\n              })\n\n              await account.sync() // propage update\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: []\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n            })\n            it('should sync root folder ignoring unsupported folders', async function() {\n              const [root] = await browser.bookmarks.getTree()\n\n              await Promise.all(\n                root.children.flatMap(child => child.children.map(child => browser.bookmarks.removeTree(child.id)))\n              )\n\n              const originalFolderId = account.getData().localRoot\n              await account.setData({ localRoot: root.id, })\n              account = await Account.get(account.id)\n              const adapter = account.server\n\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              let bookmark\n              let serverTree = await getAllBookmarks(account)\n              await withSyncConnection(account, async() => {\n                const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n                const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n                const serverMark = {\n                  title: 'url2',\n                  url: 'http://ur2.l/',\n                  parentId: barFolderId,\n                  location: ItemLocation.SERVER\n                }\n                const id = await adapter.createBookmark(\n                  new Bookmark(serverMark)\n                )\n                bookmark = {...serverMark, id}\n              })\n\n              const secondBookmarkFolderTitle = root.children[0].title\n              await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: root.children[0].id\n              })\n\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              serverTree = await getAllBookmarks(account)\n              const newRoot = await account.localTree.getBookmarksTree()\n              expect(serverTree.children).to.have.lengthOf(newRoot.children.length + 1)\n\n              await withSyncConnection(account, async() => {\n                bookmark.parentId = serverTree.children.find(folder => folder.title !== 'foo').id\n                const fooFolder = serverTree.children.find(folder => folder.title === 'foo')\n                await adapter.updateBookmark(new Bookmark(bookmark))\n                // toLowerCase to accommodate chrome (since we normalize the title)\n                const secondBookmark = serverTree.children.find(folder => folder.title.toLowerCase() === secondBookmarkFolderTitle.toLowerCase()).children.find(item => item.type === 'bookmark')\n                secondBookmark.parentId = fooFolder.id\n                await adapter.updateBookmark(secondBookmark)\n              })\n\n              await account.setData({ strategy: 'slave' })\n\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              serverTree = await getAllBookmarks(account)\n              const localTreeAfterSync = await account.localTree.getBookmarksTree()\n              expect(serverTree.children).to.have.lengthOf(localTreeAfterSync.children.length + 1)\n\n              // Switch it back to something harmless, so we don't attempt to clean up the root folder\n              await account.setData({ localRoot: originalFolderId})\n              account = await Account.get(account.id)\n            })\n          })\n          context('with overwrite mode', function() {\n            it('should create local bookmarks on the server', async function() {\n              await account.setData({\n                strategy: 'overwrite'\n              })\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: [\n                            new Bookmark({ title: 'url', url: bookmark.url })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n            })\n            it('should create local bookmarks on the server respecting moves', async function() {\n              await account.setData({\n                strategy: 'overwrite'\n              })\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: [\n                            new Bookmark({ title: 'url', url: bookmark.url })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n\n              const bazFolder = await browser.bookmarks.create({\n                title: 'baz',\n                parentId: localRoot\n              })\n              const barazFolder = await browser.bookmarks.create({\n                title: 'baraz',\n                parentId: bazFolder.id\n              })\n              await browser.bookmarks.move(barFolder.id, {parentId: barazFolder.id})\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree2 = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree2,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: []\n                    }),\n                    new Folder({\n                      title: 'baz',\n                      children: [\n                        new Folder({\n                          title: 'baraz',\n                          children: [\n                            new Folder({\n                              title: 'bar',\n                              children: [\n                                new Bookmark({ title: 'url', url: bookmark.url })\n                              ]\n                            })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false,\n                Boolean(account.server.orderFolder)\n              )\n            })\n            it('should update the server on local changes', async function() {\n              if (ACCOUNT_DATA.noCache) {\n                return this.skip()\n              }\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              await account.setData({\n                strategy: 'overwrite'\n              })\n\n              const newData = { title: 'blah' }\n              await browser.bookmarks.update(bookmark.id, newData)\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it('should update the server on local removals', async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              await account.setData({\n                strategy: 'overwrite'\n              })\n\n              await browser.bookmarks.remove(bookmark.id)\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it('should update the server on local folder moves', async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              await browser.bookmarks.create({\n                title: 'test',\n                url: 'http://ureff.l/',\n                parentId: fooFolder.id\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              await account.setData({\n                strategy: 'overwrite'\n              })\n\n              await browser.bookmarks.move(barFolder.id, {\n                parentId: localRoot\n              })\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't create server bookmarks locally\", async function() {\n              await account.setData({\n                strategy: 'overwrite'\n              })\n              const adapter = account.server\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              const serverTree = await getAllBookmarks(account)\n\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't update local bookmarks on server changes\", async function() {\n              const adapter = account.server\n              const serverTree = await getAllBookmarks(account)\n\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync() // propage creation\n              expect(account.getData().error).to.not.be.ok\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.setData({\n                strategy: 'overwrite'\n              })\n\n              const newServerMark = {\n                ...serverMark,\n                title: 'blah',\n                id: serverMarkId,\n                location: ItemLocation.SERVER\n              }\n              await withSyncConnection(account, async() => {\n                await adapter.updateBookmark(new Bookmark(newServerMark))\n              })\n\n              await account.sync() // propage update\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't update local bookmarks on server removals\", async function() {\n              const adapter = account.server\n              const serverTree = await getAllBookmarks(account)\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync() // propage creation\n              expect(account.getData().error).to.not.be.ok\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.setData({\n                strategy: 'overwrite'\n              })\n\n              await withSyncConnection(account, async() => {\n                await adapter.removeBookmark({...serverMark, id: serverMarkId})\n              })\n\n              await account.sync() // propage update\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n          })\n        })\n        context('with two clients', function() {\n          this.timeout(40 * 60000) // timeout after 20mins\n          let account1, account2\n          beforeEach('set up accounts', async function() {\n            account1 = await Account.create(ACCOUNT_DATA)\n            await account1.init()\n            account2 = await Account.create(ACCOUNT_DATA)\n            await account2.init()\n\n            if (ACCOUNT_DATA.type === 'fake') {\n              // Wrire both accounts to the same fake db\n              account2.server.bookmarksCache = account1.server.bookmarksCache = new Folder(\n                { id: '', title: 'root', location: 'Server' }\n              )\n              account2.server.__defineSetter__('highestId', (id) => {\n                account1.server.highestId = id\n              })\n              account2.server.__defineGetter__('highestId', () => account1.server.highestId)\n            }\n          })\n          afterEach('clean up accounts', async function() {\n            await browser.bookmarks.removeTree(account1.getData().localRoot)\n            if (ACCOUNT_DATA.type === 'git') {\n              await account1.server.clearServer()\n            } else if (ACCOUNT_DATA.type !== 'fake') {\n              await account1.setData({\n                serverRoot: null\n              })\n              account1.lockTimeout = 0\n              await withSyncConnection(account1, async() => {\n                const tree = await account1.server.getBookmarksTree(true)\n                await AsyncParallel.each(tree.children, async child => {\n                  if (child instanceof Folder) {\n                    await account1.server.removeFolder(child)\n                  } else {\n                    await account1.server.removeBookmark(child)\n                  }\n                })\n              })\n            }\n            if (ACCOUNT_DATA.type === 'google-drive') {\n              const fileList = await account1.server.listFiles('name = ' + \"'\" + account1.server.bookmark_file + \"'\")\n              const files = fileList.files\n              for (const file of files) {\n                await account1.server.deleteFile(file.id)\n              }\n              if (files.length > 1) {\n                throw new Error('Google Drive sync left more than one file behind')\n              }\n            }\n            try {\n              await browser.bookmarks.removeTree(account1.getData().localRoot)\n            } catch (e) {\n              // noop\n            }\n            await account1.delete()\n            try {\n              await browser.bookmarks.removeTree(account2.getData().localRoot)\n            } catch (e) {\n              // noop\n            }\n            await account2.delete()\n          })\n          it('should not sync two clients at the same time', async function() {\n            if (ACCOUNT_DATA.type === 'fake') {\n              return this.skip()\n            }\n            if (ACCOUNT_DATA.type === 'nextcloud-bookmarks' && ['v1.1.2', 'v2.3.4', 'stable3', 'stable4'].includes(APP_VERSION)) {\n              return this.skip()\n            }\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n\n            // Sync once first, so the file exists on GDrive and a lock can be set\n            await account1.sync()\n\n            let sync2, resolved = false\n            console.log('Starting sync with account 1')\n            await withSyncConnection(account1, async() => {\n              console.log('Syncing account 1')\n              console.log('Starting sync with account 2')\n              sync2 = account2.sync()\n              sync2.then(() => {\n                console.log('Finished sync with account 2')\n                resolved = true\n              })\n              await new Promise(resolve => setTimeout(resolve, 60000))\n              expect(account2.getData().error).to.be.not.ok\n              expect(account2.getData().scheduled).to.be.ok\n              expect(resolved).to.equal(true)\n            })\n            console.log('Finished sync with account 1')\n            sync2 = account2.sync()\n            sync2.then(() => {\n              console.log('Finished sync with account 2')\n              resolved = true\n            })\n            await new Promise(resolve => setTimeout(resolve, 60000))\n            expect(account2.getData().error).to.be.not.ok\n            expect(account2.getData().scheduled).to.be.not.ok\n            expect(resolved).to.equal(true)\n          })\n          it('should propagate edits using \"last write wins\"', async function() {\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account1.sync()\n            await account2.sync()\n\n            const serverTree = await getAllBookmarks(account1)\n\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n            tree1.title = tree2.title\n            expectTreeEqual(tree1, tree2)\n            tree2.title = serverTree.title\n            expectTreeEqual(tree2, serverTree)\n\n            await browser.bookmarks.update(bookmark1.id, {\n              title: 'NEW TITLE FROM ACC1'\n            })\n            await account1.sync()\n\n            const bm2Id = (await account2.localTree.getBookmarksTree(true))\n              .children[0].children[0].children[0].id\n            const newBookmark2 = await browser.bookmarks.update(bm2Id, {\n              title: 'NEW TITLE FROM ACC2'\n            })\n            await account2.sync()\n\n            await account1.sync()\n\n            const serverTreeAfterSyncing = await getAllBookmarks(account1)\n            expectTreeEqual(\n              serverTreeAfterSyncing,\n              new Folder({\n                title: serverTreeAfterSyncing.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [new Bookmark(newBookmark2)]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            const tree1AfterSyncing = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterSyncing = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterSyncing,\n              tree2AfterSyncing,\n              false\n            )\n            tree2AfterSyncing.title = serverTreeAfterSyncing.title\n            expectTreeEqual(\n              tree2AfterSyncing,\n              serverTreeAfterSyncing,\n              false\n            )\n          })\n          it('should overtake moves to a different client', async function() {\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            await account2.sync()\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false\n            )\n            console.log('First round ok')\n\n            await browser.bookmarks.move(bookmark1.id, {\n              parentId: fooFolder.id\n            })\n            console.log('acc1: Moved bookmark from bar into foo')\n\n            const tree1BeforeSecondSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n\n            const serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            const tree1AfterSecondSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterSecondSync,\n              tree1BeforeSecondSync,\n              false\n            )\n            serverTreeAfterSecondSync.title = tree1AfterSecondSync.title\n            expectTreeEqual(\n              serverTreeAfterSecondSync,\n              tree1AfterSecondSync,\n              false\n            )\n            console.log('Second round first half ok')\n\n            await account2.sync()\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree2AfterThirdSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              tree1AfterSecondSync,\n              false\n            )\n            serverTreeAfterThirdSync.title = tree2AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree2AfterThirdSync,\n              false\n            )\n            console.log('Second round second half ok')\n\n            console.log('acc1: final sync')\n            await account1.sync()\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFinalSync,\n              tree2AfterThirdSync,\n              false\n            )\n            tree2AfterThirdSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              serverTreeAfterFinalSync,\n              false\n            )\n          })\n          it('should handle creations inside deletions gracefully', async function() {\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            // remove bar folder in account2\n            await browser.bookmarks.removeTree(tree2.children[0].children[0].id)\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur2.l/',\n              parentId: barFolder.id\n            })\n            console.log(\n              'acc1: Created bookmark in bar and deleted bar on the other side'\n            )\n\n            const tree2BeforeSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterThirdSync,\n              tree2BeforeSecondSync,\n              false\n            )\n            serverTreeAfterThirdSync.title = tree2BeforeSecondSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree2BeforeSecondSync,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree2BeforeSecondSync,\n              false\n            )\n            tree2BeforeSecondSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2BeforeSecondSync,\n              false\n            )\n          })\n          it('should handle duplicate bookmarks in different serverRoot folders', async function() {\n            if (ACCOUNT_DATA.type !== 'nextcloud-bookmarks') {\n              return this.skip()\n            }\n            await account1.setData({ serverRoot: '/folder1'})\n            await account2.setData({ serverRoot: '/folder2'})\n\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n\n            const localRoot2 = account2.getData().localRoot\n            const fooFolder2 = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot2\n            })\n            const barFolder2 = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder2.id\n            })\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await browser.bookmarks.create({\n              title: 'foo',\n              url: 'http://ur.l/',\n              parentId: barFolder2.id\n            })\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTree1 = await getAllBookmarks(account1)\n\n            const tree1AfterSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n\n            // Note that we compare two different trees from two different server roots\n            // here, which just happen to look the same by virtue of this test\n\n            serverTree1.title = tree1AfterSync.title\n            expectTreeEqual(\n              serverTree1,\n              tree1AfterSync,\n              false\n            )\n            expectTreeEqual(\n              tree2AfterSync,\n              tree1AfterSync,\n              false\n            )\n          })\n          it('should handle concurrent hierarchy reversals', async function() {\n            const localRoot = account1.getData().localRoot\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: aFolder.id\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: cFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur.la/',\n              parentId: bFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.move(aFolder.id, {parentId: cFolder.id})\n            console.log(\n              'acc1: MOVE a ->c'\n            )\n\n            // ---\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'c').id, {parentId: tree2.children.find(i => i.title === 'a').children.find(i => i.title === 'b').id})\n            console.log(\n              'acc2: MOVE c ->b'\n            )\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should handle complex hierarchy reversals', async function() {\n            const localRoot = account1.getData().localRoot\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: aFolder.id\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            const dFolder = await browser.bookmarks.create({\n              title: 'd',\n              parentId: localRoot\n            })\n            const eFolder = await browser.bookmarks.create({\n              title: 'e',\n              parentId: dFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'f',\n              parentId: dFolder.id\n            })\n            const gFolder = await browser.bookmarks.create({\n              title: 'g',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: bFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur.la/',\n              parentId: dFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur2.l/',\n              parentId: eFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.move(aFolder.id, {parentId: gFolder.id})\n            console.log(\n              'acc1: MOVE a ->g'\n            )\n            await browser.bookmarks.move(dFolder.id, {parentId: cFolder.id})\n            console.log(\n              'acc1: MOVE d ->c'\n            )\n\n            // ---\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'a').children.find(i => i.title === 'b').children.find(i => i.title === 'c').id, {parentId: tree2.children.find(i => i.title === 'd').children.find(i => i.title === 'f').id})\n            console.log(\n              'acc2: MOVE c ->f'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'a').children.find(i => i.title === 'b').id, {parentId: tree2.children.find(i => i.title === 'd').children.find(i => i.title === 'e').id})\n            console.log(\n              'acc2: MOVE b ->e'\n            )\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should handle complex hierarchy reversals 2', async function() {\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            const localRoot = account1.getData().localRoot\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const gFolder = await browser.bookmarks.create({\n              title: 'g',\n              parentId: aFolder.id\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            const dFolder = await browser.bookmarks.create({\n              title: 'd',\n              parentId: cFolder.id\n            })\n            const eFolder = await browser.bookmarks.create({\n              title: 'e',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'f',\n              parentId: eFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'h',\n              parentId: bFolder.id\n            })\n\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.move(aFolder.id, {parentId: dFolder.id})\n            console.log(\n              'acc1: MOVE a ->d'\n            )\n            await browser.bookmarks.remove(gFolder.id)\n            console.log(\n              'acc1: REMOVE g'\n            )\n\n            // ---\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'b').children.find(i => i.title === 'c').id, {parentId: tree2.children.find(i => i.title === 'b').children.find(i => i.title === 'h').id})\n            console.log(\n              'acc2: MOVE c ->h'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'b').id, {parentId: tree2.children.find(i => i.title === 'e').children.find(i => i.title === 'f').id})\n            console.log(\n              'acc2: MOVE b ->f'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'e').id, {parentId: tree2.children.find(i => i.title === 'a').children.find(i => i.title === 'g').id})\n            console.log(\n              'acc2: MOVE e ->g'\n            )\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should handle faux hierarchy reversals', async function() {\n            const localRoot = account1.getData().localRoot\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'd',\n              parentId: localRoot\n            })\n            const eFolder = await browser.bookmarks.create({\n              title: 'e',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: cFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur.la/',\n              parentId: bFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.move(aFolder.id, {parentId: cFolder.id})\n            console.log(\n              'acc1: MOVE a ->c'\n            )\n\n            await browser.bookmarks.remove(eFolder.id)\n            console.log(\n              'acc1: REMOVE e'\n            )\n\n            // ---\n\n            const newFolder = await browser.bookmarks.create({\n              title: 'new',\n              parentId: tree2.children.find(i => i.title === 'e').id\n            })\n            await browser.bookmarks.create({\n              title: 'urlabyrinth',\n              url: 'http://ur2.l/',\n              parentId: newFolder.id\n            })\n            console.log('acc2: CREATE new ->e')\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'b').children.find(i => i.title === 'c').id, {parentId: newFolder.id})\n            console.log(\n              'acc2: MOVE c ->new'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'b').id, {parentId: tree2.children.find(i => i.title === 'a').id})\n            console.log(\n              'acc2: MOVE b ->a'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'e').id, {parentId: tree2.children.find(i => i.title === 'd').id})\n            console.log(\n              'acc2: MOVE e ->d'\n            )\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should handle complex move-remove interactions', async function() {\n            const localRoot = account1.getData().localRoot\n            const zFolder = await browser.bookmarks.create({\n              title: 'z',\n              parentId: localRoot\n            })\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: zFolder.id\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: aFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur.la/',\n              parentId: bFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const newFolder = await browser.bookmarks.create({\n              title: 'new',\n              parentId: aFolder.id\n            })\n            await browser.bookmarks.move(bookmark2.id, {parentId: newFolder.id})\n            await browser.bookmarks.move(aFolder.id, {parentId: bFolder.id})\n            await browser.bookmarks.move(zFolder.id, {parentId: cFolder.id})\n\n            // ---\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.removeTree(tree2.children.find(i => i.title === 'z').id)\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should synchronize ordering', async function() {\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            expect(\n              (await getAllBookmarks(account1)).children\n            ).to.have.lengthOf(0)\n\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const folder1 = await browser.bookmarks.create({\n              title: 'folder1',\n              parentId: fooFolder.id\n            })\n            const folder2 = await browser.bookmarks.create({\n              title: 'folder2',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url1',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur.ll/',\n              parentId: fooFolder.id\n            })\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const localTree1 = await account1.localTree.getBookmarksTree(true)\n            const localTree2 = await account2.localTree.getBookmarksTree(true)\n            localTree2.title = localTree1.title\n            expectTreeEqual(localTree1, localTree2, true, true)\n\n            await browser.bookmarks.move(bookmark1.id, { index: 0 })\n            await browser.bookmarks.move(folder1.id, { index: 1 })\n            await browser.bookmarks.move(bookmark2.id, { index: 2 })\n            await browser.bookmarks.move(folder2.id, { index: 3 })\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const secondLocalTree1 = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              secondLocalTree1,\n              new Folder({\n                title: secondLocalTree1.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark({\n                        title: 'url1',\n                        url: bookmark1.url\n                      }),\n                      new Folder({\n                        title: 'folder1',\n                        children: []\n                      }),\n                      new Bookmark({\n                        title: 'url2',\n                        url: bookmark2.url\n                      }),\n                      new Folder({\n                        title: 'folder2',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              true,\n              true\n            )\n\n            const secondLocalTree2 = await account2.localTree.getBookmarksTree(\n              true\n            )\n            secondLocalTree2.title = secondLocalTree1.title\n            expectTreeEqual(secondLocalTree1, secondLocalTree2, true, true)\n          })\n\n          // Skipping this, because nextcloud adapter currently\n          // isn't able to track bookmarks across dirs, thus in this\n          // scenario both bookmarks survive :/\n          it('should propagate moves using \"last write wins\"', async function() {\n            if (ACCOUNT_DATA.type === 'nextcloud-bookmarks') {\n              return this.skip()\n            }\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            await account2.sync()\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false\n            )\n            console.log('First round ok')\n\n            await browser.bookmarks.move(bookmark1.id, {\n              parentId: fooFolder.id\n            })\n            console.log('acc1: Moved bookmark from bar into foo')\n\n            const tree1BeforeSecondSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n\n            const serverTreeAfterSecondSync = await getAllBookmarks(account1)\n            const tree1AfterSecondSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterSecondSync,\n              tree1BeforeSecondSync,\n              false\n            )\n            serverTreeAfterSecondSync.title = tree1AfterSecondSync.title\n            expectTreeEqual(\n              serverTreeAfterSecondSync,\n              tree1AfterSecondSync,\n              false\n            )\n            console.log('Second round first half ok')\n\n            const bm2Id = (await account2.localTree.getBookmarksTree(true))\n              .children[0].children[0].children[0].id\n            await browser.bookmarks.move(bm2Id, {\n              parentId: account2.getData().localRoot\n            })\n            console.log('acc2: Moved bookmark from bar into root')\n            const tree2BeforeThirdSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            await account2.sync()\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n            const tree2AfterThirdSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              tree2BeforeThirdSync,\n              false\n            )\n            serverTreeAfterThirdSync.title = tree2AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree2AfterThirdSync,\n              false\n            )\n            console.log('Second round second half ok')\n\n            console.log('acc1: final sync')\n            await account1.sync()\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n            const tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFinalSync,\n              tree2AfterThirdSync,\n              false\n            )\n            tree2AfterThirdSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              serverTreeAfterFinalSync,\n              false\n            )\n          })\n        })\n\n        context('with tabs', function() {\n          if (ACCOUNT_DATA.type === 'linkwarden') {\n            return\n          }\n          let account\n          beforeEach('set up account', async function() {\n            account = await Account.create(ACCOUNT_DATA)\n            if (ACCOUNT_DATA.type === 'fake') {\n              account.server.bookmarksCache = new Folder({\n                id: '',\n                title: 'root',\n                location: 'Server'\n              })\n            }\n            await account.init()\n            await account.setData({ localRoot: 'tabs'})\n            if (ACCOUNT_DATA.noCache) {\n              account.storage.setCache = () => {\n                // noop\n              }\n              account.storage.setMappings = () => {\n                // noop\n              }\n            }\n          })\n          afterEach('clean up account', async function() {\n            if (!account) return\n            try {\n              await awaitTabsUpdated()\n              const tabs = await browser.tabs.query({\n                windowType: 'normal' // no devtools or panels or popups\n              })\n              await browser.tabs.remove(tabs.filter(tab => tab.url.startsWith('http')).map(tab => tab.id))\n            } catch (e) {\n              console.error(e)\n            }\n            await awaitTabsUpdated()\n            if (ACCOUNT_DATA.type === 'git') {\n              await account.server.clearServer()\n            } else if (ACCOUNT_DATA.type !== 'fake') {\n              await account.setData({ serverRoot: null })\n              account.lockTimeout = 0\n              const tree = await getAllBookmarks(account)\n              await withSyncConnection(account, async() => {\n                await AsyncParallel.each(tree.children, async child => {\n                  if (child instanceof Folder) {\n                    await account.server.removeFolder(child)\n                  } else {\n                    await account.server.removeBookmark(child)\n                  }\n                })\n              })\n            }\n            if (ACCOUNT_DATA.type === 'google-drive') {\n              const fileList = await account.server.listFiles('name = ' + \"'\" + account.server.bookmark_file + \"'\")\n              const files = fileList.files\n              for (const file of files) {\n                await account.server.deleteFile(file.id)\n              }\n              if (files.length > 1) {\n                throw new Error('Google Drive sync left more than one file behind')\n              }\n            }\n            await account.delete()\n          })\n          it('should create local tabs on the server', async function() {\n            browser.tabs.create({\n              index: 1,\n              url: 'https://example.org/#test1'\n            })\n            browser.tabs.create({\n              index: 2,\n              url: 'https://example.org/#test2'\n            })\n            await awaitTabsUpdated()\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test2' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create server bookmarks as tabs', async function() {\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            let windowFolderId, serverMark\n            await withSyncConnection(account, async() => {\n              windowFolderId = await adapter.createFolder(new Folder({\n                parentId: serverTree.id,\n                title: 'Window 0',\n                location: ItemLocation.SERVER\n              }))\n              serverMark = {\n                title: 'Example Domain',\n                url: 'https://example.org/',\n                parentId: windowFolderId,\n                location: ItemLocation.SERVER\n              }\n\n              await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/' }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server when pushing local changes', async function() {\n            await account.setData({ strategy: 'overwrite'})\n\n            browser.tabs.create({\n              index: 1,\n              url: 'https://example.org/#test1'\n            })\n            const tab = browser.tabs.create({\n              index: 2,\n              url: 'https://example.org/#test2'\n            })\n            await awaitTabsUpdated()\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test2' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            await browser.tabs.update(tab.id, {url: 'https://example.org/#test3'})\n            await awaitTabsUpdated()\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test3' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update local tabs when pulling server changes', async function() {\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            let windowFolderId, serverMark, serverMarkId\n            await withSyncConnection(account, async() => {\n              windowFolderId = await adapter.createFolder(new Folder({\n                parentId: serverTree.id,\n                title: 'Window 0',\n                location: ItemLocation.SERVER\n              }))\n              serverMark = {\n                title: 'Example Domain',\n                url: 'https://example.org/#test1',\n                parentId: windowFolderId,\n                location: ItemLocation.SERVER\n              }\n\n              serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            let serverMark2\n            await withSyncConnection(account, async() => {\n              serverMark2 = {\n                title: 'Example Domain',\n                url: 'https://example.org/#test3',\n                parentId: tree.children[0].id,\n                location: ItemLocation.SERVER\n              }\n              await adapter.createBookmark(\n                new Bookmark(serverMark2)\n              )\n\n              await adapter.updateBookmark({ ...serverMark, id: serverMarkId, url: 'https://example.org/#test2', title: 'Example Domain', parentId: tree.children[0].id })\n            })\n\n            await account.setData({ strategy: 'slave'})\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test2' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test3' }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should sync tabs correctly when merging server and local changes', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            let windowFolderId, serverMark, serverMarkId\n            await withSyncConnection(account, async() => {\n              windowFolderId = await adapter.createFolder(new Folder({\n                parentId: serverTree.id,\n                title: 'Window 0',\n                location: ItemLocation.SERVER\n              }))\n              serverMark = {\n                title: 'Example Domain',\n                url: 'https://example.org/#test1',\n                parentId: windowFolderId,\n                location: ItemLocation.SERVER\n              }\n\n              serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            let serverMark2\n            await withSyncConnection(account, async() => {\n              serverMark2 = {\n                title: 'Example Domain',\n                url: 'https://example.org/#test3',\n                parentId: tree.children[0].id,\n                location: ItemLocation.SERVER\n              }\n              await adapter.createBookmark(\n                new Bookmark(serverMark2)\n              )\n\n              await adapter.updateBookmark({ ...serverMark, id: serverMarkId, url: 'https://example.org/#test2', title: 'Example Domain', parentId: tree.children[0].id })\n            })\n\n            await browser.tabs.create({url: 'https://example.org/#test4'})\n            await awaitTabsUpdated()\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test2' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test3' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test4' }),\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false, // We're merging which doesn't guarantee an order\n            )\n          })\n        })\n      })\n  })\n\n  ACCOUNTS.forEach(ACCOUNT_DATA => {\n    describe(`${stringifyAccountData(ACCOUNT_DATA)} benchmark ${ACCOUNT_DATA.serverRoot ? 'subfolder' : 'root'}`, function() {\n      context('with two clients', function() {\n        this.timeout(120 * 60000) // timeout after 2h\n        let account1, account2, RUN_INTERRUPTS = false\n        let timeouts = []\n        let i = 0\n        const setInterrupt = () => {\n          if (!timeouts.length) {\n            timeouts = new Array(1000).fill(0).map(() =>\n              ACCOUNT_DATA.type === 'nextcloud-bookmarks' ? random.int(50000, 150000) : random.int(100,3000)\n            )\n          }\n          const timeout = timeouts[(i++) % 1000]\n          setTimeout(() => {\n            if (RUN_INTERRUPTS) {\n              console.log('INTERRUPT! (after ' + timeout + ')')\n              account1.cancelSync()\n              account2.cancelSync()\n              setInterrupt()\n            }\n          }, timeout)\n        }\n\n        beforeEach('set up accounts', async function() {\n          let _expectTreeEqual = expectTreeEqual\n          expectTreeEqual = (tree1, tree2, ignoreEmptyFolders, checkOrder) => _expectTreeEqual(tree1, tree2, ignoreEmptyFolders, !!checkOrder)\n\n          // reset random seed\n          random.use(seedrandom(SEED))\n\n          account1 = await Account.create({...ACCOUNT_DATA, failsafe: false})\n          await account1.init()\n          account2 = await Account.create({...ACCOUNT_DATA, failsafe: false})\n          await account2.init()\n\n          if (ACCOUNT_DATA.type === 'fake') {\n            // Wire both accounts to the same fake db\n            // We do not set the cache properties to the same object, because we want to only write onSynComplete\n            let fakeServerDb = new Folder(\n              { id: '', title: 'root', location: 'Server' }\n            )\n            account1.server.bookmarksCache = new Folder(\n              { id: '', title: 'root', location: 'Server' }\n            )\n            account2.server.bookmarksCache = new Folder(\n              { id: '', title: 'root', location: 'Server' }\n            )\n            account1.server.onSyncStart = () => {\n              account1.server.bookmarksCache = fakeServerDb.clone(false)\n            }\n            account1.server.onSyncComplete = () => {\n              fakeServerDb = account1.server.bookmarksCache.clone(false)\n            }\n            account2.server.onSyncStart = () => {\n              account2.server.bookmarksCache = fakeServerDb.clone(false)\n            }\n            account2.server.onSyncComplete = () => {\n              fakeServerDb = account2.server.bookmarksCache.clone(false)\n            }\n            account2.server.__defineSetter__('highestId', (id) => {\n              account1.server.highestId = id\n            })\n            account2.server.__defineGetter__('highestId', () => account1.server.highestId)\n          }\n          if (ACCOUNT_DATA.noCache) {\n            account1.storage.setCache = () => {\n              // noop\n            }\n            account1.storage.setMappings = () => {\n              // noop\n            }\n            account2.storage.setCache = () => {\n              // noop\n            }\n            account2.storage.setMappings = () => {\n              // noop\n            }\n          }\n        })\n        afterEach('clean up accounts', async function() {\n          RUN_INTERRUPTS = false\n          await browser.bookmarks.removeTree(account1.getData().localRoot)\n          if (ACCOUNT_DATA.type === 'git') {\n            await account1.server.clearServer()\n          } else if (ACCOUNT_DATA.type !== 'fake') {\n            await account1.setData({\n              serverRoot: null\n            })\n            account1.lockTimeout = 0\n            const tree = await getAllBookmarks(account1)\n            await withSyncConnection(account1, async() => {\n              await AsyncParallel.each(tree.children, async child => {\n                if (child instanceof Folder) {\n                  await account1.server.removeFolder(child)\n                } else {\n                  await account1.server.removeBookmark(child)\n                }\n              })\n            })\n          }\n          if (ACCOUNT_DATA.type === 'google-drive') {\n            const fileList = await account1.server.listFiles('name = ' + \"'\" + account1.server.bookmark_file + \"'\")\n            const files = fileList.files\n            for (const file of files) {\n              await account1.server.deleteFile(file.id)\n            }\n            if (files.length > 1) {\n              throw new Error('Google Drive sync left more than one file behind')\n            }\n          }\n          await account1.delete()\n          await browser.bookmarks.removeTree(account2.getData().localRoot)\n          await account2.delete()\n        })\n\n        it('should handle deep hierarchies with lots of bookmarks', async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks = 0\n          let folders = 0\n          let magicFolder, magicBookmark\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + k,\n                url: 'http://ur.l/' + parentId + '/' + k,\n                parentId\n              })\n              bookmarks++\n              if (bookmarks === 33) magicBookmark = newBookmark\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + k,\n                parentId\n              })\n              folders++\n              if (folders === 33) magicFolder = newFolder\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          const tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n          }\n          serverTreeAfterFirstSync = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          console.log('First round ok')\n\n          await browser.bookmarks.move(magicBookmark.id, {\n            parentId: magicFolder.id\n          })\n          console.log('acc1: Moved bookmark')\n\n          let tree1BeforeSecondSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n\n          let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n          let tree1AfterSecondSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterSecondSync,\n              tree1BeforeSecondSync,\n              false\n            )\n            serverTreeAfterSecondSync.title = tree1AfterSecondSync.title\n            expectTreeEqual(\n              serverTreeAfterSecondSync,\n              tree1AfterSecondSync,\n              false\n            )\n          }\n          tree1BeforeSecondSync = null\n          serverTreeAfterSecondSync = null\n          console.log('Second round first half ok')\n\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n\n          let serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n          let tree2AfterThirdSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              tree1AfterSecondSync,\n              false\n            )\n            serverTreeAfterThirdSync.title = tree2AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree2AfterThirdSync,\n              false\n            )\n          }\n          serverTreeAfterThirdSync = null\n          console.log('Second round second half ok')\n\n          console.log('acc1: final sync')\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n\n          let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n          let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFinalSync,\n              tree2AfterThirdSync,\n              false\n            )\n            tree2AfterThirdSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              serverTreeAfterFinalSync,\n              false\n            )\n          }\n          serverTreeAfterFinalSync = null\n          tree1AfterFinalSync = null\n        })\n\n        it('should handle fuzzed changes from one client', async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks = []\n          let folders = []\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + k + ':' + j,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + k + '/' + j,\n                parentId\n              })\n              bookmarks.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          serverTreeAfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            serverTreeAfterFirstSync = null\n            tree1AfterFirstSync = null\n            tree2AfterFirstSync = null\n            console.log('Initial round ok')\n\n            await randomlyManipulateTree(account1, folders, bookmarks, 20)\n            console.log(' acc1: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            serverTreeAfterSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: second local tree tree ok')\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            serverTreeAfterFinalSync = null\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n            tree2AfterSecondSync = null\n          }\n        })\n\n        it('should handle fuzzed changes from two clients', async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          tree1AfterFirstSync = null\n          serverTreeAfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            tree1AfterFirstSync = null\n            serverTreeAfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            await randomlyManipulateTree(account1, folders1, bookmarks1, 20)\n            await randomlyManipulateTree(account2, folders2, bookmarks2, 20)\n\n            console.log(' acc1: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1AfterSync = null\n            serverTreeAfterSync = null\n            tree1BeforeSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            if (ACCOUNT_DATA.type === 'nextcloud-bookmarks') {\n              // Extra round-trip for Nextcloud Bookmarks' different ID system\n              await account1.sync()\n              expect(account1.getData().error).to.not.be.ok\n              await account2.sync()\n              expect(account2.getData().error).to.not.be.ok\n              console.log('Extra round-trip for Nextcloud Bookmarks completed')\n            }\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            serverTreeAfterFinalSync = null\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            tree2AfterSecondSync = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n\n        it('should handle fuzzed changes with deletions from two clients', async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          serverTreeAfterFirstSync = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            serverTreeAfterFirstSync = null\n            tree1AfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            await randomlyManipulateTreeWithDeletions(account1, folders1, bookmarks1, RANDOM_MANIPULATION_ITERATIONS)\n            await randomlyManipulateTreeWithDeletions(account2, folders2, bookmarks2, RANDOM_MANIPULATION_ITERATIONS)\n\n            console.log(' acc1&acc2: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            tree1AfterSync = null\n            serverTreeAfterSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            // Sync twice, because some removal-move mixes are hard to sort out consistently\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            console.log('second round: account2 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            serverTreeAfterInit = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n        let interruptBenchmark\n        it.skip('should handle fuzzed changes with deletions from two clients with interrupts' + (ACCOUNT_DATA.type === 'fake' ? ' (with caching)' : ''), interruptBenchmark = async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await syncAccountWithInterrupts(account1)\n          console.log('Initial round account1 completed')\n          await syncAccountWithInterrupts(account2)\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          serverTreeAfterFirstSync = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          console.log('Initial round ok')\n\n          RUN_INTERRUPTS = true\n          setInterrupt()\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            serverTreeAfterFirstSync = null\n            tree1AfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            RUN_INTERRUPTS = false\n            await randomlyManipulateTreeWithDeletions(account1, folders1, bookmarks1, RANDOM_MANIPULATION_ITERATIONS)\n            await randomlyManipulateTreeWithDeletions(account2, folders2, bookmarks2, RANDOM_MANIPULATION_ITERATIONS)\n            RUN_INTERRUPTS = true\n\n            console.log(' acc1 &acc2: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await syncAccountWithInterrupts(account1)\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            tree1AfterSync = null\n            serverTreeAfterSync = null\n            console.log('first half ok')\n\n            await syncAccountWithInterrupts(account2)\n\n            // Sync twice, because some removal-move mixes are hard to sort out consistently\n            await syncAccountWithInterrupts(account2)\n\n            console.log('second round: account2 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await syncAccountWithInterrupts(account1)\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await syncAccountWithInterrupts(account1)\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            serverTreeAfterInit = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n\n        if (ACCOUNT_DATA.type === 'fake') {\n          it.skip('should handle fuzzed changes with deletions from two clients with interrupts (no caching adapter)', async function() {\n            // Wire both accounts to the same fake db\n            // We set the cache properties to the same object, because we want to simulate nextcloud-bookmarks\n            account1.server.bookmarksCache = account2.server.bookmarksCache = new Folder(\n              { id: '', title: 'root', location: 'Server' }\n            )\n            delete account1.server.onSyncStart\n            delete account1.server.onSyncComplete\n            delete account2.server.onSyncStart\n            delete account2.server.onSyncComplete\n            await interruptBenchmark()\n          })\n        }\n\n        it('unidirectional should handle fuzzed changes from two clients', async function() {\n          await account2.setData({ strategy: 'slave'})\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          tree1AfterFirstSync = null\n          serverTreeAfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            tree1AfterFirstSync = null\n            serverTreeAfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            await randomlyManipulateTree(account1, folders1, bookmarks1, 20)\n            await randomlyManipulateTree(account2, folders2, bookmarks2, 20)\n\n            console.log(' acc1: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSecondSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree1AfterSync,\n                false\n              )\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            serverTreeAfterFinalSync = null\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterSync.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterSync,\n                serverTreeAfterInit,\n                false\n              )\n              tree1AfterInit.title = serverTreeAfterSync.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterSync,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            tree2AfterSecondSync = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n\n        it('unidirectional should handle fuzzed changes with deletions from two clients', async function() {\n          await account2.setData({ strategy: 'slave'})\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            tree1AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          serverTreeAfterFirstSync = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            serverTreeAfterFirstSync = null\n            tree1AfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            await randomlyManipulateTreeWithDeletions(account1, folders1, bookmarks1, RANDOM_MANIPULATION_ITERATIONS)\n            await randomlyManipulateTreeWithDeletions(account2, folders2, bookmarks2, RANDOM_MANIPULATION_ITERATIONS)\n\n            console.log(' acc1: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1BeforeSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            // Sync twice, because some removal-move mixes are hard to sort out consistently\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            console.log('second round: account2 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSync.title = serverTreeAfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                serverTreeAfterSync,\n                false\n              )\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFinalSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree1AfterSync,\n                false\n              )\n              tree2AfterSecondSync.title = tree1AfterFinalSync.title\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              serverTreeAfterSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                serverTreeAfterFinalSync,\n                serverTreeAfterSync,\n                false\n              )\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              tree1AfterInit.title = tree1AfterSync.title\n              expectTreeEqual(\n                tree1AfterInit,\n                tree1AfterSync,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              serverTreeAfterInit.title = serverTreeAfterSync.title\n              expectTreeEqual(\n                serverTreeAfterInit,\n                serverTreeAfterSync,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            serverTreeAfterInit = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n      })\n    })\n  })\n})\n\nfunction hasNoBookmarks(child) {\n  if (child instanceof Bookmark) return false\n  else return !child.children.some(child => !hasNoBookmarks(child))\n}\n\nasync function getAllBookmarks(account) {\n  let tree\n  await withSyncConnection(account, async() => {\n    tree = await account.server.getBookmarksTree(true)\n  })\n  return tree\n}\n\nasync function withSyncConnection(account, fn) {\n  const adapter = account.server\n  if (adapter.onSyncStart) await adapter.onSyncStart()\n  await fn()\n  if (adapter.onSyncComplete) await adapter.onSyncComplete()\n}\n\nasync function randomlyManipulateTree(account, folders, bookmarks, iterations) {\n  for (let i = 0; i < iterations; i++) {\n    let magicBookmark\n    let magicFolder1\n    let magicFolder2\n    let magicFolder3\n    let magicFolder4\n    let magicFolder5\n    try {\n      // Randomly move one bookmark\n      magicBookmark = bookmarks[random.int(0, bookmarks.length - 1)]\n      magicFolder1 = folders[random.int(0, folders.length - 1)]\n      await browser.bookmarks.move(magicBookmark.id, {\n        parentId: magicFolder1.id\n      })\n      console.log('Move ' + magicBookmark.title + ' to ' + magicFolder1.id)\n\n      // Randomly move two folders\n      magicFolder2 = folders[random.int(0, folders.length - 1)]\n      magicFolder3 = folders[random.int(0, folders.length - 1)]\n      if (magicFolder2 === magicFolder3) {\n        continue\n      }\n      const tree2 = (await browser.bookmarks.getSubTree(magicFolder2.id))[0]\n      const root = (await browser.bookmarks.getSubTree(account.getData().localRoot))[0]\n      if (Folder.hydrate(tree2).findFolder(magicFolder3.id)) {\n        continue\n      }\n      if (!Folder.hydrate(root).findFolder(magicFolder3.id)) { // This folder is not in our tree anymore for some reason\n        continue\n      }\n      await browser.bookmarks.move(magicFolder2.id, {\n        parentId: magicFolder3.id\n      })\n      console.log('Move #' + magicFolder2.id + '[' + magicFolder2.title + '] to ' + magicFolder3.id)\n\n      // Randomly create a folder\n      magicFolder4 = folders[random.int(0, folders.length - 1)]\n      const newFolder = await browser.bookmarks.create({\n        title: 'newFolder' + Math.random(),\n        parentId: magicFolder4.id\n      })\n      folders.push(newFolder)\n      console.log('Created #' + newFolder.id + '[' + newFolder.title + '] in ' + magicFolder4.id)\n\n      magicFolder5 = folders[random.int(0, folders.length - 1)]\n      const newBookmark = await browser.bookmarks.create({\n        title: 'newBookmark' + Math.random(),\n        url: 'http://ur.l/' + magicFolder5.id + '/' + Math.random(),\n        parentId: magicFolder5.id\n      })\n      bookmarks.push(newBookmark)\n      console.log('Created #' + newBookmark.id + '[' + newBookmark.title + '] in ' + magicFolder5.id)\n    } catch (e) {\n      console.log(e)\n    }\n  }\n}\n\nasync function randomlyManipulateTreeWithDeletions(account, folders, bookmarks, iterations) {\n  for (let i = 0; i < iterations; i++) {\n    let magicBookmark\n    let magicFolder1\n    let magicFolder2\n    let magicFolder3\n    let magicFolder4\n    let magicFolder5\n    try {\n      // Randomly remove one bookmark\n      magicBookmark = bookmarks[random.int(0, bookmarks.length - 1)]\n      await browser.bookmarks.remove(magicBookmark.id)\n      bookmarks.splice(bookmarks.indexOf(magicBookmark), 1)\n      console.log('Remove ' + magicBookmark.title)\n\n      // Randomly rename one bookmark\n      magicBookmark = bookmarks[random.int(0, bookmarks.length - 1)]\n      const newTitle = 'renamed' + Math.random()\n      await browser.bookmarks.update(magicBookmark.id, {title: newTitle})\n      console.log('Rename #' + magicBookmark.id + '[' + magicBookmark.title + '] to ' + newTitle)\n\n      // randomly remove one folder\n      magicFolder1 = folders[random.int(0, folders.length - 1)]\n      await browser.bookmarks.removeTree(magicFolder1.id)\n      folders.splice(folders.indexOf(magicFolder1), 1)\n      console.log('Removed #' + magicFolder1.id + '[' + magicFolder1.title + ']')\n\n      // Randomly move one bookmark\n      magicBookmark = bookmarks[random.int(0, bookmarks.length - 1)]\n      magicFolder1 = folders[random.int(0, folders.length - 1)]\n      await browser.bookmarks.move(magicBookmark.id, {\n        parentId: magicFolder1.id\n      })\n      console.log('Move ' + magicBookmark.title + ' to ' + magicFolder1.id)\n\n      // Randomly move two folders\n      magicFolder2 = folders[random.int(0, folders.length - 1)]\n      magicFolder3 = folders[random.int(0, folders.length - 1)]\n      if (magicFolder2 === magicFolder3) {\n        continue\n      }\n      const tree2 = (await browser.bookmarks.getSubTree(magicFolder2.id))[0]\n      const root = (await browser.bookmarks.getSubTree(account.getData().localRoot))[0]\n      if (Folder.hydrate(tree2).findFolder(magicFolder3.id)) {\n        continue\n      }\n      if (!Folder.hydrate(root).findFolder(magicFolder3.id)) { // This folder is not in our tree anymore for some reason\n        continue\n      }\n      await browser.bookmarks.move(magicFolder2.id, {\n        parentId: magicFolder3.id\n      })\n      console.log('Move #' + magicFolder2.id + '[' + magicFolder2.title + '] to ' + magicFolder3.id)\n\n      // Randomly create a folder\n      magicFolder4 = folders[random.int(0, folders.length - 1)]\n      const newFolder = await browser.bookmarks.create({\n        title: 'newFolder' + Math.random(),\n        parentId: magicFolder4.id\n      })\n      folders.push(newFolder)\n      console.log('Created #' + newFolder.id + '[' + newFolder.title + '] in ' + magicFolder4.id)\n\n      // Randomly create a bookmark\n      magicFolder5 = folders[random.int(0, folders.length - 1)]\n      const newBookmark = await browser.bookmarks.create({\n        title: 'newBookmark' + Math.random(),\n        url: 'http://ur.l/' + magicFolder5.id + '/' + Math.random(),\n        parentId: magicFolder5.id\n      })\n      bookmarks.push(newBookmark)\n      console.log('Created #' + newBookmark.id + '[' + newBookmark.title + '] in ' + magicFolder5.id)\n    } catch (e) {\n      console.log(e)\n    }\n  }\n}\n\nasync function syncAccountWithInterrupts(account) {\n  await account.sync()\n  try {\n    expect(account.getData().error).to.not.be.ok\n  } catch (e) {\n    if (!account.getData().error.includes('E026') && !account.getData().error.includes('E027')) {\n      throw e\n    } else {\n      console.log(account.getData().error)\n      account.lockTimeout = 0\n      await syncAccountWithInterrupts(account)\n    }\n  }\n}\n\nfunction stringifyAccountData(ACCOUNT_DATA) {\n  return `${ACCOUNT_DATA.type}${\n    (ACCOUNT_DATA.noCache ? '-noCache' : '') +\n    (typeof ACCOUNT_DATA.bookmark_file_type !== 'undefined' ? '-' + ACCOUNT_DATA.bookmark_file_type : '') +\n    ((ACCOUNT_DATA.type === 'google-drive' && ACCOUNT_DATA.password) || (ACCOUNT_DATA.type === 'webdav' && ACCOUNT_DATA.passphrase) ? '-encrypted' : '')\n  }`\n}\n\nfunction awaitTabsUpdated() {\n  return Promise.race([\n    new Promise(resolve => {\n      browser.tabs.onUpdated.addListener(() => {\n        browser.tabs.onUpdated.removeListener(resolve)\n        setTimeout(() => resolve(), 1000)\n      })\n    }),\n    new Promise(resolve => setTimeout(resolve, 1100))\n  ])\n}\n","import CachingAdapter from './Caching'\n\nexport default class FakeAdapter extends CachingAdapter {\n  constructor(server) {\n    super()\n    this.server = server\n  }\n\n  static getDefaultValues() {\n    return {\n      type: 'fake'\n    }\n  }\n\n  setData(data) {\n    this.server = data\n  }\n\n  getData() {\n    return JSON.parse(JSON.stringify(this.server))\n  }\n\n  getLabel() {\n    return 'Fake account (floccus)'\n  }\n}\n"],"names":["storageLock","AsyncLock","BrowserAccountStorage","constructor","id","this","accountId","changeEntry","entryName","fn","defaultVal","acquire","async","entry","getEntry","browser","storage","local","set","JSON","stringify","get","parse","e","Logger","log","message","console","error","deleteEntry","remove","getAllAccounts","accounts","Object","keys","getAccountData","key","data","iv","password","DefunctCryptography","decryptAES","Cryptography","username","passphrase","setAccountData","encData","deleteAccountData","deleteCache","deleteMappings","initCache","getCache","Folder","hydrate","length","location","ItemLocation","LOCAL","setCache","initMappings","getMappings","Mappings","bookmarks","ServerToLocal","LocalToServer","folders","setMappings","getCurrentContinuation","setCurrentContinuation","continuation","_","createdAt","Date","now","chai","chaiAsPromised","expect","expectTreeEqual","tree1","tree2","ignoreEmptyFolders","expectTreeEqualRec","arguments","undefined","recDepth","checkOrder","title","to","equal","url","children","sort","a","b","children1","filter","child","hasNoBookmarks","children2","have","forEach","child2","i","inspect","Bookmark","some","getAllBookmarks","account","tree","withSyncConnection","server","getBookmarksTree","adapter","onSyncStart","onSyncComplete","randomlyManipulateTree","iterations","magicBookmark","magicFolder1","magicFolder2","magicFolder3","magicFolder4","magicFolder5","random","move","parentId","getSubTree","root","getData","localRoot","findFolder","newFolder","create","Math","push","newBookmark","randomlyManipulateTreeWithDeletions","splice","indexOf","newTitle","update","removeTree","syncAccountWithInterrupts","sync","not","be","ok","includes","lockTimeout","stringifyAccountData","ACCOUNT_DATA","type","noCache","bookmark_file_type","awaitTabsUpdated","Promise","race","resolve","tabs","onUpdated","addListener","removeListener","setTimeout","describe","timeout","slow","params","URL","window","href","searchParams","SERVER","CREDENTIALS","ACCOUNTS","APP_VERSION","SEED","BROWSER","RANDOM_MANIPULATION_ITERATIONS","seedrandom","FakeAdapter","getDefaultValues","serverRoot","bookmark_file","branch","refreshToken","serverFolder","before","Controller","setEnabled","after","it","salt","payload","Crypto","cleartext","DefunctCrypto","encryptAES","beforeEach","Account","afterEach","delete","secondInstance","deep","setData","rejected","isInitialized","false","context","bookmarksCache","init","clearServer","AsyncParallel","removeFolder","removeBookmark","files","listFiles","file","deleteFile","Error","fooFolder","barFolder","bookmark","Boolean","orderFolder","bookmark2","skip","newData","bookmark1","lengthOf","serverTree","fooFolderId","barFolderId","serverMark","createFolder","createBookmark","serverMarkId","newServerMark","updateBookmark","syncPromise","bookmarkData","serverMark1","serverMark2","localMark1","localMark2","bookmark3","bookmark4","localTree","subFolder","topFolder","aFolder","bFolder","cFolder","dFolder","eFolder","fFolder","initialTree","updateFolder","cFolder1","cFolder2","aFolderId","bookmark1Id","bFolderId","bookmark2Id","findBookmark","all","map","deleteNonSysNodes","delChildren","getChildren","delNodeId","delChild","endsWith","toolbarNameNormalFolder","BrowserTree","onToolbarNormalFolder","brTree","bmTree","getTree","newRoot","flatMap","originalFolderId","secondBookmarkFolderTitle","find","folder","secondBookmark","toLowerCase","item","localTreeAfterSync","folder1","folder2","index","strategy","originalTree","bazFolder","barazFolder","account1","account2","__defineSetter__","highestId","__defineGetter__","sync2","resolved","then","scheduled","bm2Id","newBookmark2","serverTreeAfterSyncing","tree1AfterSyncing","tree2AfterSyncing","serverTreeAfterFirstSync","tree1AfterFirstSync","tree2AfterFirstSync","tree1BeforeSecondSync","serverTreeAfterSecondSync","tree1AfterSecondSync","serverTreeAfterThirdSync","tree2AfterThirdSync","serverTreeAfterFinalSync","tree1AfterFinalSync","tree2BeforeSecondSync","tree1AfterThirdSync","tree2AfterFinalSync","localRoot2","fooFolder2","barFolder2","serverTree1","tree1AfterSync","tree2AfterSync","gFolder","zFolder","localTree1","localTree2","secondLocalTree1","secondLocalTree2","tree2BeforeThirdSync","query","windowType","tab","startsWith","windowFolderId","RUN_INTERRUPTS","timeouts","setInterrupt","Array","fill","cancelSync","interruptBenchmark","_expectTreeEqual","failsafe","fakeServerDb","clone","magicFolder","createTree","j","len","abs","k","step","floor","tree1Initial","tree1BeforeSync","serverTreeAfterSync","tree2AfterSecondSync","serverTreeAfterInit","tree1AfterInit","bookmarks2","folders2","bookmarks1","folders1","createIndex","values","CachingAdapter","super","getLabel"],"sourceRoot":""}