var g=(r,e)=>(e=Symbol[r])?e:Symbol.for("Symbol."+r),p=r=>{throw TypeError(r)};var S=(r,e,s)=>e.has(r)||p("Cannot "+s);var l=(r,e,s)=>(S(r,e,"read from private field"),s?s.call(r):e.get(r)),d=(r,e,s)=>e.has(r)?p("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,s),u=(r,e,s,t)=>(S(r,e,"write to private field"),t?t.call(r,s):e.set(r,s),s);var x=(r,e,s)=>{if(e!=null){typeof e!="object"&&typeof e!="function"&&p("Object expected");var t;s&&(t=e[g("asyncDispose")]),t===void 0&&(t=e[g("dispose")]),typeof t!="function"&&p("Object not disposable"),r.push([s,t,e])}else s&&r.push([s]);return e},C=(r,e,s)=>{var t=typeof SuppressedError=="function"?SuppressedError:function(o,b,n,m){return m=Error(n),m.name="SuppressedError",m.error=o,m.suppressed=b,m},c=o=>e=s?new t(o,e,"An error was suppressed during disposal"):(s=!0,o),f=o=>{for(;o=r.pop();)try{var b=o[1]&&o[1].call(o[2]);if(o[0])return Promise.resolve(b).then(f,n=>(c(n),f()))}catch(n){c(n)}if(s)throw e};return f()};import{l as E,ag as v,av as B}from"./index-uVYElzgq.js";var h,i,a;class D{constructor(){d(this,h,[]);d(this,i,null);d(this,a,!1)}next(e){l(this,i)?l(this,i).next(e):l(this,h).push(e)}complete(){var e;(e=l(this,i))==null||e.complete(),u(this,i,null),u(this,a,!0)}error(e){var s;(s=l(this,i))==null||s.error(e),u(this,i,null),u(this,a,!0)}subscribe(e){var t=[];try{if(l(this,a))return E.warn("Cannot subscribe to closed SingleConsumerBufferedEmitter"),v(()=>{});if(l(this,i))return E.error("SingleConsumerBufferedEmitter supports only one subscriber."),v(()=>{});const s=x(t,new DisposableStack);u(this,i,B(e));s.defer(()=>u(this,i,null));l(this,h).forEach(b=>{var n;return(n=l(this,i))==null?void 0:n.next(b)});l(this,h).length=0;return s.move()}catch(c){var f=c,o=!0}finally{C(t,f,o)}}[Symbol.dispose](){this.complete()}}h=new WeakMap,i=new WeakMap,a=new WeakMap;export{D as S};
//# sourceMappingURL=SingleConsumerBufferedEmitter-_6WCMMUA-B9gRLjc-.js.map
